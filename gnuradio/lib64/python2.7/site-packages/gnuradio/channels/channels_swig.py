# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_channels_swig', [dirname(__file__)])
        except ImportError:
            import _channels_swig
            return _channels_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_channels_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _channels_swig = swig_import_helper()
    del swig_import_helper
else:
    import _channels_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _channels_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _channels_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _channels_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _channels_swig.high_res_timer_epoch()
class channel_model(object):
    """
    Basic channel simulator.

    This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set the voltage of an AWGN noise source (), a (normalized) frequency offset (), a sample timing offset (), and a seed () to randomize or make reproducable the AWGN noise source.

    Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

    To simulate a channel with time-variant channel, use gr::channels::channel_model2.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
        frequency_offset : The normalized frequency offset. 0 is no offset; 0.25 would be, for a digital modem, one quarter of the symbol rate.
        epsilon : The sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
        taps : Taps of a FIR filter to emulate a multipath delay profile.
        noise_seed : A random number generator seed for the noise source.
        block_tags : If true, tags will not be able to propagate through this block.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double noise_voltage=0.0, double frequency_offset=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
            double noise_seed=0, bool block_tags=False) -> channel_model_sptr

        Basic channel simulator.

        This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set the voltage of an AWGN noise source (), a (normalized) frequency offset (), a sample timing offset (), and a seed () to randomize or make reproducable the AWGN noise source.

        Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

        To simulate a channel with time-variant channel, use gr::channels::channel_model2.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
            frequency_offset : The normalized frequency offset. 0 is no offset; 0.25 would be, for a digital modem, one quarter of the symbol rate.
            epsilon : The sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
            taps : Taps of a FIR filter to emulate a multipath delay profile.
            noise_seed : A random number generator seed for the noise source.
            block_tags : If true, tags will not be able to propagate through this block.
        """
        return _channels_swig.channel_model_make(*args, **kwargs)

    make = staticmethod(make)
    def set_noise_voltage(self, *args, **kwargs):
        """set_noise_voltage(channel_model self, double noise_voltage)"""
        return _channels_swig.channel_model_set_noise_voltage(self, *args, **kwargs)

    def set_frequency_offset(self, *args, **kwargs):
        """set_frequency_offset(channel_model self, double frequency_offset)"""
        return _channels_swig.channel_model_set_frequency_offset(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(channel_model self, pmt_vector_cfloat taps)"""
        return _channels_swig.channel_model_set_taps(self, *args, **kwargs)

    def set_timing_offset(self, *args, **kwargs):
        """set_timing_offset(channel_model self, double epsilon)"""
        return _channels_swig.channel_model_set_timing_offset(self, *args, **kwargs)

    def noise_voltage(self):
        """noise_voltage(channel_model self) -> double"""
        return _channels_swig.channel_model_noise_voltage(self)

    def frequency_offset(self):
        """frequency_offset(channel_model self) -> double"""
        return _channels_swig.channel_model_frequency_offset(self)

    def taps(self):
        """taps(channel_model self) -> pmt_vector_cfloat"""
        return _channels_swig.channel_model_taps(self)

    def timing_offset(self):
        """timing_offset(channel_model self) -> double"""
        return _channels_swig.channel_model_timing_offset(self)

    __swig_destroy__ = _channels_swig.delete_channel_model
    __del__ = lambda self : None;
channel_model_swigregister = _channels_swig.channel_model_swigregister
channel_model_swigregister(channel_model)

def channel_model_make(*args, **kwargs):
  """
    channel_model_make(double noise_voltage=0.0, double frequency_offset=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
        double noise_seed=0, bool block_tags=False) -> channel_model_sptr

    Basic channel simulator.

    This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set the voltage of an AWGN noise source (), a (normalized) frequency offset (), a sample timing offset (), and a seed () to randomize or make reproducable the AWGN noise source.

    Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

    To simulate a channel with time-variant channel, use gr::channels::channel_model2.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
        frequency_offset : The normalized frequency offset. 0 is no offset; 0.25 would be, for a digital modem, one quarter of the symbol rate.
        epsilon : The sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
        taps : Taps of a FIR filter to emulate a multipath delay profile.
        noise_seed : A random number generator seed for the noise source.
        block_tags : If true, tags will not be able to propagate through this block.
    """
  return _channels_swig.channel_model_make(*args, **kwargs)

class channel_model2(object):
    """
    Basic channel simulator allowing time-varying frequency and timing inputs.

    This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set the voltage of an AWGN noise source (), an initial timing offset (), and a seed () to randomize the AWGN noise source.

    Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

    Unlike gr::channels::channel_model, this block is designed to enable time-varying frequency and timing offsets.


    Since the models for frequency and timing offset may vary and what we are trying to model may be different for different simulations, we provide the time-varying nature as an input function that is user-defined. If only constant frequency and timing offsets are required, it is easier and less expensive to use gr::channels::channel_model.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
        epsilon : The initial sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
        taps : Taps of a FIR filter to emulate a multipath delay profile.
        noise_seed : A random number generator seed for the noise source.
        block_tags : If true, tags will not be able to propagate through this block.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double noise_voltage=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
            double noise_seed=0, bool block_tags=False) -> channel_model2_sptr

        Basic channel simulator allowing time-varying frequency and timing inputs.

        This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set the voltage of an AWGN noise source (), an initial timing offset (), and a seed () to randomize the AWGN noise source.

        Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

        Unlike gr::channels::channel_model, this block is designed to enable time-varying frequency and timing offsets.


        Since the models for frequency and timing offset may vary and what we are trying to model may be different for different simulations, we provide the time-varying nature as an input function that is user-defined. If only constant frequency and timing offsets are required, it is easier and less expensive to use gr::channels::channel_model.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
            epsilon : The initial sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
            taps : Taps of a FIR filter to emulate a multipath delay profile.
            noise_seed : A random number generator seed for the noise source.
            block_tags : If true, tags will not be able to propagate through this block.
        """
        return _channels_swig.channel_model2_make(*args, **kwargs)

    make = staticmethod(make)
    def set_noise_voltage(self, *args, **kwargs):
        """set_noise_voltage(channel_model2 self, double noise_voltage)"""
        return _channels_swig.channel_model2_set_noise_voltage(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(channel_model2 self, pmt_vector_cfloat taps)"""
        return _channels_swig.channel_model2_set_taps(self, *args, **kwargs)

    def set_timing_offset(self, *args, **kwargs):
        """set_timing_offset(channel_model2 self, double epsilon)"""
        return _channels_swig.channel_model2_set_timing_offset(self, *args, **kwargs)

    def noise_voltage(self):
        """noise_voltage(channel_model2 self) -> double"""
        return _channels_swig.channel_model2_noise_voltage(self)

    def taps(self):
        """taps(channel_model2 self) -> pmt_vector_cfloat"""
        return _channels_swig.channel_model2_taps(self)

    def timing_offset(self):
        """timing_offset(channel_model2 self) -> double"""
        return _channels_swig.channel_model2_timing_offset(self)

    __swig_destroy__ = _channels_swig.delete_channel_model2
    __del__ = lambda self : None;
channel_model2_swigregister = _channels_swig.channel_model2_swigregister
channel_model2_swigregister(channel_model2)

def channel_model2_make(*args, **kwargs):
  """
    channel_model2_make(double noise_voltage=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
        double noise_seed=0, bool block_tags=False) -> channel_model2_sptr

    Basic channel simulator allowing time-varying frequency and timing inputs.

    This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set the voltage of an AWGN noise source (), an initial timing offset (), and a seed () to randomize the AWGN noise source.

    Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

    Unlike gr::channels::channel_model, this block is designed to enable time-varying frequency and timing offsets.


    Since the models for frequency and timing offset may vary and what we are trying to model may be different for different simulations, we provide the time-varying nature as an input function that is user-defined. If only constant frequency and timing offsets are required, it is easier and less expensive to use gr::channels::channel_model.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
        epsilon : The initial sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
        taps : Taps of a FIR filter to emulate a multipath delay profile.
        noise_seed : A random number generator seed for the noise source.
        block_tags : If true, tags will not be able to propagate through this block.
    """
  return _channels_swig.channel_model2_make(*args, **kwargs)

class cfo_model(object):
    """
    channel simulator

    This block implements a carrier frequency offset model that can be used to simulate carrier frequency drift typically from mixer LO drift on either transmit or receive hardware.

    A clipped gaussian random walk process is used.

    Constructor Specific Documentation:

    Build the carrier frequency offset model.

    Args:
        sample_rate_hz : Sample rate of the input signal in Hz
        std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
        max_dev_hz : Maximum carrier frequency deviation in Hz.
        noise_seed : A random number generator seed for the noise source.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> cfo_model_sptr

        channel simulator

        This block implements a carrier frequency offset model that can be used to simulate carrier frequency drift typically from mixer LO drift on either transmit or receive hardware.

        A clipped gaussian random walk process is used.

        Constructor Specific Documentation:

        Build the carrier frequency offset model.

        Args:
            sample_rate_hz : Sample rate of the input signal in Hz
            std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
            max_dev_hz : Maximum carrier frequency deviation in Hz.
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.cfo_model_make(*args, **kwargs)

    make = staticmethod(make)
    def set_std_dev(self, *args, **kwargs):
        """set_std_dev(cfo_model self, double _dev)"""
        return _channels_swig.cfo_model_set_std_dev(self, *args, **kwargs)

    def set_max_dev(self, *args, **kwargs):
        """set_max_dev(cfo_model self, double _dev)"""
        return _channels_swig.cfo_model_set_max_dev(self, *args, **kwargs)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(cfo_model self, double _rate)"""
        return _channels_swig.cfo_model_set_samp_rate(self, *args, **kwargs)

    def std_dev(self):
        """std_dev(cfo_model self) -> double"""
        return _channels_swig.cfo_model_std_dev(self)

    def max_dev(self):
        """max_dev(cfo_model self) -> double"""
        return _channels_swig.cfo_model_max_dev(self)

    def samp_rate(self):
        """samp_rate(cfo_model self) -> double"""
        return _channels_swig.cfo_model_samp_rate(self)

    __swig_destroy__ = _channels_swig.delete_cfo_model
    __del__ = lambda self : None;
cfo_model_swigregister = _channels_swig.cfo_model_swigregister
cfo_model_swigregister(cfo_model)

def cfo_model_make(*args, **kwargs):
  """
    cfo_model_make(double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> cfo_model_sptr

    channel simulator

    This block implements a carrier frequency offset model that can be used to simulate carrier frequency drift typically from mixer LO drift on either transmit or receive hardware.

    A clipped gaussian random walk process is used.

    Constructor Specific Documentation:

    Build the carrier frequency offset model.

    Args:
        sample_rate_hz : Sample rate of the input signal in Hz
        std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
        max_dev_hz : Maximum carrier frequency deviation in Hz.
        noise_seed : A random number generator seed for the noise source.
    """
  return _channels_swig.cfo_model_make(*args, **kwargs)

class dynamic_channel_model(object):
    """
    dynamic channel simulator

    This block implements a dynamic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set up an AWGN noise cource, a random walk process to simulate carrier frequency drift, a random walk process to simulate sample rate offset drive, and a frequency selective fading channel response that is either Rayleigh or Ricean for a user specified power delay profile.

    Constructor Specific Documentation:

    Build the dynamic channel simulator.

    Args:
        samp_rate : Input sample rate in Hz
        sro_std_dev : sample rate drift process standard deviation per sample in Hz
        sro_max_dev : maximum sample rate offset in Hz
        cfo_std_dev : carrier frequnecy drift process standard deviation per sample in Hz
        cfo_max_dev : maximum carrier frequency offset in Hz
        N : number of sinusoids used in frequency selective fading simulation
        doppler_freq : maximum doppler frequency used in fading simulation in Hz
        LOS_model : defines whether the fading model should include a line of site component. LOS->Rician, NLOS->Rayleigh
        K : Rician K-factor, the ratio of specular to diffuse power in the model
        delays : A list of fractional sample delays making up the power delay profile
        mags : A list of magnitudes corresponding to each delay time in the power delay profile
        ntaps_mpath : The length of the filter to interpolate the power delay profile over. Delays in the PDP must lie between 0 and ntaps_mpath, fractional delays will be sinc-interpolated only to the width of this filter.
        noise_amp : Specifies the standard deviation of the AWGN process
        noise_seed : A random number generator seed for the noise source.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double samp_rate, double sro_std_dev, double sro_max_dev, double cfo_std_dev, double cfo_max_dev, 
            unsigned int N, double doppler_freq, bool LOS_model, float K, 
            pmt_vector_float delays, pmt_vector_float mags, int ntaps_mpath, double noise_amp, 
            double noise_seed) -> dynamic_channel_model_sptr

        dynamic channel simulator

        This block implements a dynamic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set up an AWGN noise cource, a random walk process to simulate carrier frequency drift, a random walk process to simulate sample rate offset drive, and a frequency selective fading channel response that is either Rayleigh or Ricean for a user specified power delay profile.

        Constructor Specific Documentation:

        Build the dynamic channel simulator.

        Args:
            samp_rate : Input sample rate in Hz
            sro_std_dev : sample rate drift process standard deviation per sample in Hz
            sro_max_dev : maximum sample rate offset in Hz
            cfo_std_dev : carrier frequnecy drift process standard deviation per sample in Hz
            cfo_max_dev : maximum carrier frequency offset in Hz
            N : number of sinusoids used in frequency selective fading simulation
            doppler_freq : maximum doppler frequency used in fading simulation in Hz
            LOS_model : defines whether the fading model should include a line of site component. LOS->Rician, NLOS->Rayleigh
            K : Rician K-factor, the ratio of specular to diffuse power in the model
            delays : A list of fractional sample delays making up the power delay profile
            mags : A list of magnitudes corresponding to each delay time in the power delay profile
            ntaps_mpath : The length of the filter to interpolate the power delay profile over. Delays in the PDP must lie between 0 and ntaps_mpath, fractional delays will be sinc-interpolated only to the width of this filter.
            noise_amp : Specifies the standard deviation of the AWGN process
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.dynamic_channel_model_make(*args, **kwargs)

    make = staticmethod(make)
    def samp_rate(self):
        """samp_rate(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_samp_rate(self)

    def sro_dev_std(self):
        """sro_dev_std(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_sro_dev_std(self)

    def sro_dev_max(self):
        """sro_dev_max(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_sro_dev_max(self)

    def cfo_dev_std(self):
        """cfo_dev_std(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_cfo_dev_std(self)

    def cfo_dev_max(self):
        """cfo_dev_max(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_cfo_dev_max(self)

    def noise_amp(self):
        """noise_amp(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_noise_amp(self)

    def doppler_freq(self):
        """doppler_freq(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_doppler_freq(self)

    def K(self):
        """K(dynamic_channel_model self) -> double"""
        return _channels_swig.dynamic_channel_model_K(self)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_samp_rate(self, *args, **kwargs)

    def set_sro_dev_std(self, *args, **kwargs):
        """set_sro_dev_std(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_sro_dev_std(self, *args, **kwargs)

    def set_sro_dev_max(self, *args, **kwargs):
        """set_sro_dev_max(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_sro_dev_max(self, *args, **kwargs)

    def set_cfo_dev_std(self, *args, **kwargs):
        """set_cfo_dev_std(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_cfo_dev_std(self, *args, **kwargs)

    def set_cfo_dev_max(self, *args, **kwargs):
        """set_cfo_dev_max(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_cfo_dev_max(self, *args, **kwargs)

    def set_noise_amp(self, *args, **kwargs):
        """set_noise_amp(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_noise_amp(self, *args, **kwargs)

    def set_doppler_freq(self, *args, **kwargs):
        """set_doppler_freq(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_doppler_freq(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(dynamic_channel_model self, double arg2)"""
        return _channels_swig.dynamic_channel_model_set_K(self, *args, **kwargs)

    __swig_destroy__ = _channels_swig.delete_dynamic_channel_model
    __del__ = lambda self : None;
dynamic_channel_model_swigregister = _channels_swig.dynamic_channel_model_swigregister
dynamic_channel_model_swigregister(dynamic_channel_model)

def dynamic_channel_model_make(*args, **kwargs):
  """
    dynamic_channel_model_make(double samp_rate, double sro_std_dev, double sro_max_dev, double cfo_std_dev, double cfo_max_dev, 
        unsigned int N, double doppler_freq, bool LOS_model, float K, 
        pmt_vector_float delays, pmt_vector_float mags, int ntaps_mpath, double noise_amp, 
        double noise_seed) -> dynamic_channel_model_sptr

    dynamic channel simulator

    This block implements a dynamic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    This model allows the user to set up an AWGN noise cource, a random walk process to simulate carrier frequency drift, a random walk process to simulate sample rate offset drive, and a frequency selective fading channel response that is either Rayleigh or Ricean for a user specified power delay profile.

    Constructor Specific Documentation:

    Build the dynamic channel simulator.

    Args:
        samp_rate : Input sample rate in Hz
        sro_std_dev : sample rate drift process standard deviation per sample in Hz
        sro_max_dev : maximum sample rate offset in Hz
        cfo_std_dev : carrier frequnecy drift process standard deviation per sample in Hz
        cfo_max_dev : maximum carrier frequency offset in Hz
        N : number of sinusoids used in frequency selective fading simulation
        doppler_freq : maximum doppler frequency used in fading simulation in Hz
        LOS_model : defines whether the fading model should include a line of site component. LOS->Rician, NLOS->Rayleigh
        K : Rician K-factor, the ratio of specular to diffuse power in the model
        delays : A list of fractional sample delays making up the power delay profile
        mags : A list of magnitudes corresponding to each delay time in the power delay profile
        ntaps_mpath : The length of the filter to interpolate the power delay profile over. Delays in the PDP must lie between 0 and ntaps_mpath, fractional delays will be sinc-interpolated only to the width of this filter.
        noise_amp : Specifies the standard deviation of the AWGN process
        noise_seed : A random number generator seed for the noise source.
    """
  return _channels_swig.dynamic_channel_model_make(*args, **kwargs)

class fading_model(object):
    """
    fading simulator

    This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        N : The number of sinusiods to use in simulating the channel; 8 is a good value
        fDTs : normalized maximum Doppler frequency, fD * Ts
        LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
        K : Rician factor (ratio of the specular power to the scattered power)
        seed : a random number to seed the noise generators
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int N, float fDTs=0.01, bool LOS=True, float K=4, int seed=0) -> fading_model_sptr

        fading simulator

        This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            N : The number of sinusiods to use in simulating the channel; 8 is a good value
            fDTs : normalized maximum Doppler frequency, fD * Ts
            LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
            K : Rician factor (ratio of the specular power to the scattered power)
            seed : a random number to seed the noise generators
        """
        return _channels_swig.fading_model_make(*args, **kwargs)

    make = staticmethod(make)
    def fDTs(self):
        """fDTs(fading_model self) -> float"""
        return _channels_swig.fading_model_fDTs(self)

    def K(self):
        """K(fading_model self) -> float"""
        return _channels_swig.fading_model_K(self)

    def step(self):
        """step(fading_model self) -> float"""
        return _channels_swig.fading_model_step(self)

    def set_fDTs(self, *args, **kwargs):
        """set_fDTs(fading_model self, float fDTs)"""
        return _channels_swig.fading_model_set_fDTs(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(fading_model self, float K)"""
        return _channels_swig.fading_model_set_K(self, *args, **kwargs)

    def set_step(self, *args, **kwargs):
        """set_step(fading_model self, float step)"""
        return _channels_swig.fading_model_set_step(self, *args, **kwargs)

    __swig_destroy__ = _channels_swig.delete_fading_model
    __del__ = lambda self : None;
fading_model_swigregister = _channels_swig.fading_model_swigregister
fading_model_swigregister(fading_model)

def fading_model_make(*args, **kwargs):
  """
    fading_model_make(unsigned int N, float fDTs=0.01, bool LOS=True, float K=4, int seed=0) -> fading_model_sptr

    fading simulator

    This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        N : The number of sinusiods to use in simulating the channel; 8 is a good value
        fDTs : normalized maximum Doppler frequency, fD * Ts
        LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
        K : Rician factor (ratio of the specular power to the scattered power)
        seed : a random number to seed the noise generators
    """
  return _channels_swig.fading_model_make(*args, **kwargs)

class selective_fading_model(object):
    """
    fading simulator

    This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        N : The number of sinusiods to use in simulating the channel; 8 is a good value
        fDTs : normalized maximum Doppler frequency, fD * Ts
        LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
        K : Rician factor (ratio of the specular power to the scattered power)
        seed : a random number to seed the noise generators
        delays : A vector of values the specify the time delay of each impulse
        mags : A vector of values that specifies the magnitude of each impulse
        ntaps : The number of filter taps.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int N, float fDTs, bool LOS, float K, int seed, pmt_vector_float delays, 
            pmt_vector_float mags, int ntaps) -> selective_fading_model_sptr

        fading simulator

        This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            N : The number of sinusiods to use in simulating the channel; 8 is a good value
            fDTs : normalized maximum Doppler frequency, fD * Ts
            LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
            K : Rician factor (ratio of the specular power to the scattered power)
            seed : a random number to seed the noise generators
            delays : A vector of values the specify the time delay of each impulse
            mags : A vector of values that specifies the magnitude of each impulse
            ntaps : The number of filter taps.
        """
        return _channels_swig.selective_fading_model_make(*args, **kwargs)

    make = staticmethod(make)
    def fDTs(self):
        """fDTs(selective_fading_model self) -> float"""
        return _channels_swig.selective_fading_model_fDTs(self)

    def K(self):
        """K(selective_fading_model self) -> float"""
        return _channels_swig.selective_fading_model_K(self)

    def step(self):
        """step(selective_fading_model self) -> float"""
        return _channels_swig.selective_fading_model_step(self)

    def set_fDTs(self, *args, **kwargs):
        """set_fDTs(selective_fading_model self, float fDTs)"""
        return _channels_swig.selective_fading_model_set_fDTs(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(selective_fading_model self, float K)"""
        return _channels_swig.selective_fading_model_set_K(self, *args, **kwargs)

    def set_step(self, *args, **kwargs):
        """set_step(selective_fading_model self, float step)"""
        return _channels_swig.selective_fading_model_set_step(self, *args, **kwargs)

    __swig_destroy__ = _channels_swig.delete_selective_fading_model
    __del__ = lambda self : None;
selective_fading_model_swigregister = _channels_swig.selective_fading_model_swigregister
selective_fading_model_swigregister(selective_fading_model)
cvar = _channels_swig.cvar
default_delays = cvar.default_delays
default_mags = cvar.default_mags

def selective_fading_model_make(*args, **kwargs):
  """
    selective_fading_model_make(unsigned int N, float fDTs, bool LOS, float K, int seed, pmt_vector_float delays, 
        pmt_vector_float mags, int ntaps) -> selective_fading_model_sptr

    fading simulator

    This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

    Constructor Specific Documentation:

    Build the channel simulator.

    Args:
        N : The number of sinusiods to use in simulating the channel; 8 is a good value
        fDTs : normalized maximum Doppler frequency, fD * Ts
        LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
        K : Rician factor (ratio of the specular power to the scattered power)
        seed : a random number to seed the noise generators
        delays : A vector of values the specify the time delay of each impulse
        mags : A vector of values that specifies the magnitude of each impulse
        ntaps : The number of filter taps.
    """
  return _channels_swig.selective_fading_model_make(*args, **kwargs)

class sro_model(object):
    """
    Sample Rate Offset Model.

    This block implements a model that varies sample rate offset with respect to time by performing a random walk on the interpolation rate.

    Constructor Specific Documentation:

    Build the sample rate offset model.

    Args:
        sample_rate_hz : Sample rate of the input signal in Hz
        std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
        max_dev_hz : Maximum sample rate deviation from zero in Hz.
        noise_seed : A random number generator seed for the noise source.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> sro_model_sptr

        Sample Rate Offset Model.

        This block implements a model that varies sample rate offset with respect to time by performing a random walk on the interpolation rate.

        Constructor Specific Documentation:

        Build the sample rate offset model.

        Args:
            sample_rate_hz : Sample rate of the input signal in Hz
            std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
            max_dev_hz : Maximum sample rate deviation from zero in Hz.
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.sro_model_make(*args, **kwargs)

    make = staticmethod(make)
    def set_std_dev(self, *args, **kwargs):
        """set_std_dev(sro_model self, double _dev)"""
        return _channels_swig.sro_model_set_std_dev(self, *args, **kwargs)

    def set_max_dev(self, *args, **kwargs):
        """set_max_dev(sro_model self, double _dev)"""
        return _channels_swig.sro_model_set_max_dev(self, *args, **kwargs)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(sro_model self, double _rate)"""
        return _channels_swig.sro_model_set_samp_rate(self, *args, **kwargs)

    def std_dev(self):
        """std_dev(sro_model self) -> double"""
        return _channels_swig.sro_model_std_dev(self)

    def max_dev(self):
        """max_dev(sro_model self) -> double"""
        return _channels_swig.sro_model_max_dev(self)

    def samp_rate(self):
        """samp_rate(sro_model self) -> double"""
        return _channels_swig.sro_model_samp_rate(self)

    __swig_destroy__ = _channels_swig.delete_sro_model
    __del__ = lambda self : None;
sro_model_swigregister = _channels_swig.sro_model_swigregister
sro_model_swigregister(sro_model)

def sro_model_make(*args, **kwargs):
  """
    sro_model_make(double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> sro_model_sptr

    Sample Rate Offset Model.

    This block implements a model that varies sample rate offset with respect to time by performing a random walk on the interpolation rate.

    Constructor Specific Documentation:

    Build the sample rate offset model.

    Args:
        sample_rate_hz : Sample rate of the input signal in Hz
        std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
        max_dev_hz : Maximum sample rate deviation from zero in Hz.
        noise_seed : A random number generator seed for the noise source.
    """
  return _channels_swig.sro_model_make(*args, **kwargs)

class channel_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::channel_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::channel_model)> self) -> channel_model_sptr
        __init__(boost::shared_ptr<(gr::channels::channel_model)> self, channel_model p) -> channel_model_sptr
        """
        this = _channels_swig.new_channel_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(channel_model_sptr self) -> channel_model"""
        return _channels_swig.channel_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_channel_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(channel_model_sptr self, double noise_voltage=0.0, double frequency_offset=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
            double noise_seed=0, bool block_tags=False) -> channel_model_sptr

        Basic channel simulator.

        This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set the voltage of an AWGN noise source (), a (normalized) frequency offset (), a sample timing offset (), and a seed () to randomize or make reproducable the AWGN noise source.

        Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

        To simulate a channel with time-variant channel, use gr::channels::channel_model2.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
            frequency_offset : The normalized frequency offset. 0 is no offset; 0.25 would be, for a digital modem, one quarter of the symbol rate.
            epsilon : The sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
            taps : Taps of a FIR filter to emulate a multipath delay profile.
            noise_seed : A random number generator seed for the noise source.
            block_tags : If true, tags will not be able to propagate through this block.
        """
        return _channels_swig.channel_model_sptr_make(self, *args, **kwargs)

    def set_noise_voltage(self, *args, **kwargs):
        """set_noise_voltage(channel_model_sptr self, double noise_voltage)"""
        return _channels_swig.channel_model_sptr_set_noise_voltage(self, *args, **kwargs)

    def set_frequency_offset(self, *args, **kwargs):
        """set_frequency_offset(channel_model_sptr self, double frequency_offset)"""
        return _channels_swig.channel_model_sptr_set_frequency_offset(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(channel_model_sptr self, pmt_vector_cfloat taps)"""
        return _channels_swig.channel_model_sptr_set_taps(self, *args, **kwargs)

    def set_timing_offset(self, *args, **kwargs):
        """set_timing_offset(channel_model_sptr self, double epsilon)"""
        return _channels_swig.channel_model_sptr_set_timing_offset(self, *args, **kwargs)

    def noise_voltage(self):
        """noise_voltage(channel_model_sptr self) -> double"""
        return _channels_swig.channel_model_sptr_noise_voltage(self)

    def frequency_offset(self):
        """frequency_offset(channel_model_sptr self) -> double"""
        return _channels_swig.channel_model_sptr_frequency_offset(self)

    def taps(self):
        """taps(channel_model_sptr self) -> pmt_vector_cfloat"""
        return _channels_swig.channel_model_sptr_taps(self)

    def timing_offset(self):
        """timing_offset(channel_model_sptr self) -> double"""
        return _channels_swig.channel_model_sptr_timing_offset(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(channel_model_sptr self, basic_block_sptr block)
        primitive_connect(channel_model_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.channel_model_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(channel_model_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(channel_model_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.channel_model_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(channel_model_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(channel_model_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.channel_model_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(channel_model_sptr self, basic_block_sptr block)
        primitive_disconnect(channel_model_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.channel_model_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(channel_model_sptr self)"""
        return _channels_swig.channel_model_sptr_disconnect_all(self)

    def lock(self):
        """lock(channel_model_sptr self)"""
        return _channels_swig.channel_model_sptr_lock(self)

    def unlock(self):
        """unlock(channel_model_sptr self)"""
        return _channels_swig.channel_model_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(channel_model_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.channel_model_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(channel_model_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.channel_model_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(channel_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.channel_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(channel_model_sptr self)"""
        return _channels_swig.channel_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(channel_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.channel_model_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(channel_model_sptr self) -> hier_block2_sptr"""
        return _channels_swig.channel_model_sptr_to_hier_block2(self)

    def name(self):
        """name(channel_model_sptr self) -> std::string"""
        return _channels_swig.channel_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(channel_model_sptr self) -> std::string"""
        return _channels_swig.channel_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(channel_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.channel_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(channel_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.channel_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(channel_model_sptr self) -> long"""
        return _channels_swig.channel_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(channel_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.channel_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(channel_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.channel_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(channel_model_sptr self) -> std::string"""
        return _channels_swig.channel_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(channel_model_sptr self, std::string name)"""
        return _channels_swig.channel_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(channel_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.channel_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(channel_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.channel_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(channel_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.channel_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(channel_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.channel_model_sptr_message_subscribers(self, *args, **kwargs)

channel_model_sptr_swigregister = _channels_swig.channel_model_sptr_swigregister
channel_model_sptr_swigregister(channel_model_sptr)

channel_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
channel_model = channel_model.make;

class channel_model2_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::channel_model2)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::channel_model2)> self) -> channel_model2_sptr
        __init__(boost::shared_ptr<(gr::channels::channel_model2)> self, channel_model2 p) -> channel_model2_sptr
        """
        this = _channels_swig.new_channel_model2_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(channel_model2_sptr self) -> channel_model2"""
        return _channels_swig.channel_model2_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_channel_model2_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(channel_model2_sptr self, double noise_voltage=0.0, double epsilon=1.0, pmt_vector_cfloat taps=std::vector< gr_complex >(1,1), 
            double noise_seed=0, bool block_tags=False) -> channel_model2_sptr

        Basic channel simulator allowing time-varying frequency and timing inputs.

        This block implements a basic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set the voltage of an AWGN noise source (), an initial timing offset (), and a seed () to randomize the AWGN noise source.

        Multipath can be approximated in this model by using a FIR filter representation of a multipath delay profile with the parameter .

        Unlike gr::channels::channel_model, this block is designed to enable time-varying frequency and timing offsets.


        Since the models for frequency and timing offset may vary and what we are trying to model may be different for different simulations, we provide the time-varying nature as an input function that is user-defined. If only constant frequency and timing offsets are required, it is easier and less expensive to use gr::channels::channel_model.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            noise_voltage : The AWGN noise level as a voltage (to be calculated externally to meet, say, a desired SNR).
            epsilon : The initial sample timing offset to emulate the different rates between the sample clocks of the transmitter and receiver. 1.0 is no difference.
            taps : Taps of a FIR filter to emulate a multipath delay profile.
            noise_seed : A random number generator seed for the noise source.
            block_tags : If true, tags will not be able to propagate through this block.
        """
        return _channels_swig.channel_model2_sptr_make(self, *args, **kwargs)

    def set_noise_voltage(self, *args, **kwargs):
        """set_noise_voltage(channel_model2_sptr self, double noise_voltage)"""
        return _channels_swig.channel_model2_sptr_set_noise_voltage(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(channel_model2_sptr self, pmt_vector_cfloat taps)"""
        return _channels_swig.channel_model2_sptr_set_taps(self, *args, **kwargs)

    def set_timing_offset(self, *args, **kwargs):
        """set_timing_offset(channel_model2_sptr self, double epsilon)"""
        return _channels_swig.channel_model2_sptr_set_timing_offset(self, *args, **kwargs)

    def noise_voltage(self):
        """noise_voltage(channel_model2_sptr self) -> double"""
        return _channels_swig.channel_model2_sptr_noise_voltage(self)

    def taps(self):
        """taps(channel_model2_sptr self) -> pmt_vector_cfloat"""
        return _channels_swig.channel_model2_sptr_taps(self)

    def timing_offset(self):
        """timing_offset(channel_model2_sptr self) -> double"""
        return _channels_swig.channel_model2_sptr_timing_offset(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(channel_model2_sptr self, basic_block_sptr block)
        primitive_connect(channel_model2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.channel_model2_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(channel_model2_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(channel_model2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.channel_model2_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(channel_model2_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(channel_model2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.channel_model2_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(channel_model2_sptr self, basic_block_sptr block)
        primitive_disconnect(channel_model2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.channel_model2_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(channel_model2_sptr self)"""
        return _channels_swig.channel_model2_sptr_disconnect_all(self)

    def lock(self):
        """lock(channel_model2_sptr self)"""
        return _channels_swig.channel_model2_sptr_lock(self)

    def unlock(self):
        """unlock(channel_model2_sptr self)"""
        return _channels_swig.channel_model2_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(channel_model2_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.channel_model2_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(channel_model2_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.channel_model2_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(channel_model2_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.channel_model2_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(channel_model2_sptr self)"""
        return _channels_swig.channel_model2_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(channel_model2_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.channel_model2_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(channel_model2_sptr self) -> hier_block2_sptr"""
        return _channels_swig.channel_model2_sptr_to_hier_block2(self)

    def name(self):
        """name(channel_model2_sptr self) -> std::string"""
        return _channels_swig.channel_model2_sptr_name(self)

    def symbol_name(self):
        """symbol_name(channel_model2_sptr self) -> std::string"""
        return _channels_swig.channel_model2_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(channel_model2_sptr self) -> io_signature_sptr"""
        return _channels_swig.channel_model2_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(channel_model2_sptr self) -> io_signature_sptr"""
        return _channels_swig.channel_model2_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(channel_model2_sptr self) -> long"""
        return _channels_swig.channel_model2_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(channel_model2_sptr self) -> basic_block_sptr"""
        return _channels_swig.channel_model2_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(channel_model2_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.channel_model2_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(channel_model2_sptr self) -> std::string"""
        return _channels_swig.channel_model2_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(channel_model2_sptr self, std::string name)"""
        return _channels_swig.channel_model2_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(channel_model2_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.channel_model2_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(channel_model2_sptr self) -> swig_int_ptr"""
        return _channels_swig.channel_model2_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(channel_model2_sptr self) -> swig_int_ptr"""
        return _channels_swig.channel_model2_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(channel_model2_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.channel_model2_sptr_message_subscribers(self, *args, **kwargs)

channel_model2_sptr_swigregister = _channels_swig.channel_model2_sptr_swigregister
channel_model2_sptr_swigregister(channel_model2_sptr)

channel_model2_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
channel_model2 = channel_model2.make;

class cfo_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::cfo_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::cfo_model)> self) -> cfo_model_sptr
        __init__(boost::shared_ptr<(gr::channels::cfo_model)> self, cfo_model p) -> cfo_model_sptr
        """
        this = _channels_swig.new_cfo_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(cfo_model_sptr self) -> cfo_model"""
        return _channels_swig.cfo_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_cfo_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(cfo_model_sptr self, double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> cfo_model_sptr

        channel simulator

        This block implements a carrier frequency offset model that can be used to simulate carrier frequency drift typically from mixer LO drift on either transmit or receive hardware.

        A clipped gaussian random walk process is used.

        Constructor Specific Documentation:

        Build the carrier frequency offset model.

        Args:
            sample_rate_hz : Sample rate of the input signal in Hz
            std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
            max_dev_hz : Maximum carrier frequency deviation in Hz.
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.cfo_model_sptr_make(self, *args, **kwargs)

    def set_std_dev(self, *args, **kwargs):
        """set_std_dev(cfo_model_sptr self, double _dev)"""
        return _channels_swig.cfo_model_sptr_set_std_dev(self, *args, **kwargs)

    def set_max_dev(self, *args, **kwargs):
        """set_max_dev(cfo_model_sptr self, double _dev)"""
        return _channels_swig.cfo_model_sptr_set_max_dev(self, *args, **kwargs)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(cfo_model_sptr self, double _rate)"""
        return _channels_swig.cfo_model_sptr_set_samp_rate(self, *args, **kwargs)

    def std_dev(self):
        """std_dev(cfo_model_sptr self) -> double"""
        return _channels_swig.cfo_model_sptr_std_dev(self)

    def max_dev(self):
        """max_dev(cfo_model_sptr self) -> double"""
        return _channels_swig.cfo_model_sptr_max_dev(self)

    def samp_rate(self):
        """samp_rate(cfo_model_sptr self) -> double"""
        return _channels_swig.cfo_model_sptr_samp_rate(self)

    def history(self):
        """history(cfo_model_sptr self) -> unsigned int"""
        return _channels_swig.cfo_model_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(cfo_model_sptr self, int which, int delay)
        declare_sample_delay(cfo_model_sptr self, unsigned int delay)
        """
        return _channels_swig.cfo_model_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(cfo_model_sptr self, int which) -> unsigned int"""
        return _channels_swig.cfo_model_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(cfo_model_sptr self) -> int"""
        return _channels_swig.cfo_model_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(cfo_model_sptr self) -> double"""
        return _channels_swig.cfo_model_sptr_relative_rate(self)

    def start(self):
        """start(cfo_model_sptr self) -> bool"""
        return _channels_swig.cfo_model_sptr_start(self)

    def stop(self):
        """stop(cfo_model_sptr self) -> bool"""
        return _channels_swig.cfo_model_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(cfo_model_sptr self, unsigned int which_input) -> uint64_t"""
        return _channels_swig.cfo_model_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(cfo_model_sptr self, unsigned int which_output) -> uint64_t"""
        return _channels_swig.cfo_model_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(cfo_model_sptr self) -> int"""
        return _channels_swig.cfo_model_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(cfo_model_sptr self, int m)"""
        return _channels_swig.cfo_model_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(cfo_model_sptr self)"""
        return _channels_swig.cfo_model_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(cfo_model_sptr self) -> bool"""
        return _channels_swig.cfo_model_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(cfo_model_sptr self, int m)"""
        return _channels_swig.cfo_model_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(cfo_model_sptr self) -> int"""
        return _channels_swig.cfo_model_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(cfo_model_sptr self, int i) -> long"""
        return _channels_swig.cfo_model_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(cfo_model_sptr self, long max_output_buffer)
        set_max_output_buffer(cfo_model_sptr self, int port, long max_output_buffer)
        """
        return _channels_swig.cfo_model_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(cfo_model_sptr self, int i) -> long"""
        return _channels_swig.cfo_model_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(cfo_model_sptr self, long min_output_buffer)
        set_min_output_buffer(cfo_model_sptr self, int port, long min_output_buffer)
        """
        return _channels_swig.cfo_model_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(cfo_model_sptr self, int which) -> float
        pc_input_buffers_full(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(cfo_model_sptr self, int which) -> float
        pc_input_buffers_full_avg(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(cfo_model_sptr self, int which) -> float
        pc_input_buffers_full_var(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(cfo_model_sptr self, int which) -> float
        pc_output_buffers_full(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(cfo_model_sptr self, int which) -> float
        pc_output_buffers_full_avg(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(cfo_model_sptr self, int which) -> float
        pc_output_buffers_full_var(cfo_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.cfo_model_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(cfo_model_sptr self) -> float"""
        return _channels_swig.cfo_model_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(cfo_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.cfo_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(cfo_model_sptr self)"""
        return _channels_swig.cfo_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(cfo_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.cfo_model_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(cfo_model_sptr self) -> int"""
        return _channels_swig.cfo_model_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(cfo_model_sptr self) -> int"""
        return _channels_swig.cfo_model_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(cfo_model_sptr self, int priority) -> int"""
        return _channels_swig.cfo_model_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(cfo_model_sptr self) -> std::string"""
        return _channels_swig.cfo_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(cfo_model_sptr self) -> std::string"""
        return _channels_swig.cfo_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(cfo_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.cfo_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(cfo_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.cfo_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(cfo_model_sptr self) -> long"""
        return _channels_swig.cfo_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(cfo_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.cfo_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(cfo_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.cfo_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(cfo_model_sptr self) -> std::string"""
        return _channels_swig.cfo_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(cfo_model_sptr self, std::string name)"""
        return _channels_swig.cfo_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(cfo_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.cfo_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(cfo_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.cfo_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(cfo_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.cfo_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(cfo_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.cfo_model_sptr_message_subscribers(self, *args, **kwargs)

cfo_model_sptr_swigregister = _channels_swig.cfo_model_sptr_swigregister
cfo_model_sptr_swigregister(cfo_model_sptr)

cfo_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
cfo_model = cfo_model.make;

class dynamic_channel_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::dynamic_channel_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::dynamic_channel_model)> self) -> dynamic_channel_model_sptr
        __init__(boost::shared_ptr<(gr::channels::dynamic_channel_model)> self, dynamic_channel_model p) -> dynamic_channel_model_sptr
        """
        this = _channels_swig.new_dynamic_channel_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(dynamic_channel_model_sptr self) -> dynamic_channel_model"""
        return _channels_swig.dynamic_channel_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_dynamic_channel_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(dynamic_channel_model_sptr self, double samp_rate, double sro_std_dev, double sro_max_dev, double cfo_std_dev, double cfo_max_dev, 
            unsigned int N, double doppler_freq, bool LOS_model, float K, 
            pmt_vector_float delays, pmt_vector_float mags, int ntaps_mpath, double noise_amp, 
            double noise_seed) -> dynamic_channel_model_sptr

        dynamic channel simulator

        This block implements a dynamic channel model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        This model allows the user to set up an AWGN noise cource, a random walk process to simulate carrier frequency drift, a random walk process to simulate sample rate offset drive, and a frequency selective fading channel response that is either Rayleigh or Ricean for a user specified power delay profile.

        Constructor Specific Documentation:

        Build the dynamic channel simulator.

        Args:
            samp_rate : Input sample rate in Hz
            sro_std_dev : sample rate drift process standard deviation per sample in Hz
            sro_max_dev : maximum sample rate offset in Hz
            cfo_std_dev : carrier frequnecy drift process standard deviation per sample in Hz
            cfo_max_dev : maximum carrier frequency offset in Hz
            N : number of sinusoids used in frequency selective fading simulation
            doppler_freq : maximum doppler frequency used in fading simulation in Hz
            LOS_model : defines whether the fading model should include a line of site component. LOS->Rician, NLOS->Rayleigh
            K : Rician K-factor, the ratio of specular to diffuse power in the model
            delays : A list of fractional sample delays making up the power delay profile
            mags : A list of magnitudes corresponding to each delay time in the power delay profile
            ntaps_mpath : The length of the filter to interpolate the power delay profile over. Delays in the PDP must lie between 0 and ntaps_mpath, fractional delays will be sinc-interpolated only to the width of this filter.
            noise_amp : Specifies the standard deviation of the AWGN process
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.dynamic_channel_model_sptr_make(self, *args, **kwargs)

    def samp_rate(self):
        """samp_rate(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_samp_rate(self)

    def sro_dev_std(self):
        """sro_dev_std(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_sro_dev_std(self)

    def sro_dev_max(self):
        """sro_dev_max(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_sro_dev_max(self)

    def cfo_dev_std(self):
        """cfo_dev_std(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_cfo_dev_std(self)

    def cfo_dev_max(self):
        """cfo_dev_max(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_cfo_dev_max(self)

    def noise_amp(self):
        """noise_amp(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_noise_amp(self)

    def doppler_freq(self):
        """doppler_freq(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_doppler_freq(self)

    def K(self):
        """K(dynamic_channel_model_sptr self) -> double"""
        return _channels_swig.dynamic_channel_model_sptr_K(self)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_samp_rate(self, *args, **kwargs)

    def set_sro_dev_std(self, *args, **kwargs):
        """set_sro_dev_std(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_sro_dev_std(self, *args, **kwargs)

    def set_sro_dev_max(self, *args, **kwargs):
        """set_sro_dev_max(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_sro_dev_max(self, *args, **kwargs)

    def set_cfo_dev_std(self, *args, **kwargs):
        """set_cfo_dev_std(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_cfo_dev_std(self, *args, **kwargs)

    def set_cfo_dev_max(self, *args, **kwargs):
        """set_cfo_dev_max(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_cfo_dev_max(self, *args, **kwargs)

    def set_noise_amp(self, *args, **kwargs):
        """set_noise_amp(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_noise_amp(self, *args, **kwargs)

    def set_doppler_freq(self, *args, **kwargs):
        """set_doppler_freq(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_doppler_freq(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(dynamic_channel_model_sptr self, double arg2)"""
        return _channels_swig.dynamic_channel_model_sptr_set_K(self, *args, **kwargs)

    def primitive_connect(self, *args):
        """
        primitive_connect(dynamic_channel_model_sptr self, basic_block_sptr block)
        primitive_connect(dynamic_channel_model_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.dynamic_channel_model_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(dynamic_channel_model_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(dynamic_channel_model_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.dynamic_channel_model_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(dynamic_channel_model_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(dynamic_channel_model_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _channels_swig.dynamic_channel_model_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(dynamic_channel_model_sptr self, basic_block_sptr block)
        primitive_disconnect(dynamic_channel_model_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _channels_swig.dynamic_channel_model_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(dynamic_channel_model_sptr self)"""
        return _channels_swig.dynamic_channel_model_sptr_disconnect_all(self)

    def lock(self):
        """lock(dynamic_channel_model_sptr self)"""
        return _channels_swig.dynamic_channel_model_sptr_lock(self)

    def unlock(self):
        """unlock(dynamic_channel_model_sptr self)"""
        return _channels_swig.dynamic_channel_model_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(dynamic_channel_model_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.dynamic_channel_model_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(dynamic_channel_model_sptr self, swig_int_ptr port_id)"""
        return _channels_swig.dynamic_channel_model_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(dynamic_channel_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.dynamic_channel_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(dynamic_channel_model_sptr self)"""
        return _channels_swig.dynamic_channel_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(dynamic_channel_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.dynamic_channel_model_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(dynamic_channel_model_sptr self) -> hier_block2_sptr"""
        return _channels_swig.dynamic_channel_model_sptr_to_hier_block2(self)

    def name(self):
        """name(dynamic_channel_model_sptr self) -> std::string"""
        return _channels_swig.dynamic_channel_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(dynamic_channel_model_sptr self) -> std::string"""
        return _channels_swig.dynamic_channel_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(dynamic_channel_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.dynamic_channel_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(dynamic_channel_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.dynamic_channel_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(dynamic_channel_model_sptr self) -> long"""
        return _channels_swig.dynamic_channel_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(dynamic_channel_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.dynamic_channel_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(dynamic_channel_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.dynamic_channel_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(dynamic_channel_model_sptr self) -> std::string"""
        return _channels_swig.dynamic_channel_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(dynamic_channel_model_sptr self, std::string name)"""
        return _channels_swig.dynamic_channel_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(dynamic_channel_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.dynamic_channel_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(dynamic_channel_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.dynamic_channel_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(dynamic_channel_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.dynamic_channel_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(dynamic_channel_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.dynamic_channel_model_sptr_message_subscribers(self, *args, **kwargs)

dynamic_channel_model_sptr_swigregister = _channels_swig.dynamic_channel_model_sptr_swigregister
dynamic_channel_model_sptr_swigregister(dynamic_channel_model_sptr)

dynamic_channel_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
dynamic_channel_model = dynamic_channel_model.make;

class fading_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::fading_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::fading_model)> self) -> fading_model_sptr
        __init__(boost::shared_ptr<(gr::channels::fading_model)> self, fading_model p) -> fading_model_sptr
        """
        this = _channels_swig.new_fading_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fading_model_sptr self) -> fading_model"""
        return _channels_swig.fading_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_fading_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fading_model_sptr self, unsigned int N, float fDTs=0.01, bool LOS=True, float K=4, int seed=0) -> fading_model_sptr

        fading simulator

        This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            N : The number of sinusiods to use in simulating the channel; 8 is a good value
            fDTs : normalized maximum Doppler frequency, fD * Ts
            LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
            K : Rician factor (ratio of the specular power to the scattered power)
            seed : a random number to seed the noise generators
        """
        return _channels_swig.fading_model_sptr_make(self, *args, **kwargs)

    def fDTs(self):
        """fDTs(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_fDTs(self)

    def K(self):
        """K(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_K(self)

    def step(self):
        """step(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_step(self)

    def set_fDTs(self, *args, **kwargs):
        """set_fDTs(fading_model_sptr self, float fDTs)"""
        return _channels_swig.fading_model_sptr_set_fDTs(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(fading_model_sptr self, float K)"""
        return _channels_swig.fading_model_sptr_set_K(self, *args, **kwargs)

    def set_step(self, *args, **kwargs):
        """set_step(fading_model_sptr self, float step)"""
        return _channels_swig.fading_model_sptr_set_step(self, *args, **kwargs)

    def history(self):
        """history(fading_model_sptr self) -> unsigned int"""
        return _channels_swig.fading_model_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fading_model_sptr self, int which, int delay)
        declare_sample_delay(fading_model_sptr self, unsigned int delay)
        """
        return _channels_swig.fading_model_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fading_model_sptr self, int which) -> unsigned int"""
        return _channels_swig.fading_model_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fading_model_sptr self) -> int"""
        return _channels_swig.fading_model_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fading_model_sptr self) -> double"""
        return _channels_swig.fading_model_sptr_relative_rate(self)

    def start(self):
        """start(fading_model_sptr self) -> bool"""
        return _channels_swig.fading_model_sptr_start(self)

    def stop(self):
        """stop(fading_model_sptr self) -> bool"""
        return _channels_swig.fading_model_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fading_model_sptr self, unsigned int which_input) -> uint64_t"""
        return _channels_swig.fading_model_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fading_model_sptr self, unsigned int which_output) -> uint64_t"""
        return _channels_swig.fading_model_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fading_model_sptr self) -> int"""
        return _channels_swig.fading_model_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fading_model_sptr self, int m)"""
        return _channels_swig.fading_model_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fading_model_sptr self)"""
        return _channels_swig.fading_model_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fading_model_sptr self) -> bool"""
        return _channels_swig.fading_model_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fading_model_sptr self, int m)"""
        return _channels_swig.fading_model_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fading_model_sptr self) -> int"""
        return _channels_swig.fading_model_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fading_model_sptr self, int i) -> long"""
        return _channels_swig.fading_model_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fading_model_sptr self, long max_output_buffer)
        set_max_output_buffer(fading_model_sptr self, int port, long max_output_buffer)
        """
        return _channels_swig.fading_model_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fading_model_sptr self, int i) -> long"""
        return _channels_swig.fading_model_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fading_model_sptr self, long min_output_buffer)
        set_min_output_buffer(fading_model_sptr self, int port, long min_output_buffer)
        """
        return _channels_swig.fading_model_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fading_model_sptr self, int which) -> float
        pc_input_buffers_full(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fading_model_sptr self, int which) -> float
        pc_input_buffers_full_avg(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fading_model_sptr self, int which) -> float
        pc_input_buffers_full_var(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fading_model_sptr self, int which) -> float
        pc_output_buffers_full(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fading_model_sptr self, int which) -> float
        pc_output_buffers_full_avg(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fading_model_sptr self, int which) -> float
        pc_output_buffers_full_var(fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.fading_model_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fading_model_sptr self) -> float"""
        return _channels_swig.fading_model_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fading_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.fading_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fading_model_sptr self)"""
        return _channels_swig.fading_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fading_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.fading_model_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fading_model_sptr self) -> int"""
        return _channels_swig.fading_model_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fading_model_sptr self) -> int"""
        return _channels_swig.fading_model_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fading_model_sptr self, int priority) -> int"""
        return _channels_swig.fading_model_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fading_model_sptr self) -> std::string"""
        return _channels_swig.fading_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fading_model_sptr self) -> std::string"""
        return _channels_swig.fading_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fading_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.fading_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fading_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.fading_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fading_model_sptr self) -> long"""
        return _channels_swig.fading_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fading_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.fading_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fading_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.fading_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fading_model_sptr self) -> std::string"""
        return _channels_swig.fading_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fading_model_sptr self, std::string name)"""
        return _channels_swig.fading_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fading_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.fading_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fading_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.fading_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fading_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.fading_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fading_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.fading_model_sptr_message_subscribers(self, *args, **kwargs)

fading_model_sptr_swigregister = _channels_swig.fading_model_sptr_swigregister
fading_model_sptr_swigregister(fading_model_sptr)

fading_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fading_model = fading_model.make;

class selective_fading_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::selective_fading_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::selective_fading_model)> self) -> selective_fading_model_sptr
        __init__(boost::shared_ptr<(gr::channels::selective_fading_model)> self, selective_fading_model p) -> selective_fading_model_sptr
        """
        this = _channels_swig.new_selective_fading_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(selective_fading_model_sptr self) -> selective_fading_model"""
        return _channels_swig.selective_fading_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_selective_fading_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(selective_fading_model_sptr self, unsigned int N, float fDTs, bool LOS, float K, int seed, pmt_vector_float delays, 
            pmt_vector_float mags, int ntaps) -> selective_fading_model_sptr

        fading simulator

        This block implements a basic fading model simulator that can be used to help evaluate, design, and test various signals, waveforms, and algorithms.

        Constructor Specific Documentation:

        Build the channel simulator.

        Args:
            N : The number of sinusiods to use in simulating the channel; 8 is a good value
            fDTs : normalized maximum Doppler frequency, fD * Ts
            LOS : include Line-of-Site path? selects between Rayleigh (NLOS) and Rician (LOS) models
            K : Rician factor (ratio of the specular power to the scattered power)
            seed : a random number to seed the noise generators
            delays : A vector of values the specify the time delay of each impulse
            mags : A vector of values that specifies the magnitude of each impulse
            ntaps : The number of filter taps.
        """
        return _channels_swig.selective_fading_model_sptr_make(self, *args, **kwargs)

    def fDTs(self):
        """fDTs(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_fDTs(self)

    def K(self):
        """K(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_K(self)

    def step(self):
        """step(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_step(self)

    def set_fDTs(self, *args, **kwargs):
        """set_fDTs(selective_fading_model_sptr self, float fDTs)"""
        return _channels_swig.selective_fading_model_sptr_set_fDTs(self, *args, **kwargs)

    def set_K(self, *args, **kwargs):
        """set_K(selective_fading_model_sptr self, float K)"""
        return _channels_swig.selective_fading_model_sptr_set_K(self, *args, **kwargs)

    def set_step(self, *args, **kwargs):
        """set_step(selective_fading_model_sptr self, float step)"""
        return _channels_swig.selective_fading_model_sptr_set_step(self, *args, **kwargs)

    def history(self):
        """history(selective_fading_model_sptr self) -> unsigned int"""
        return _channels_swig.selective_fading_model_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(selective_fading_model_sptr self, int which, int delay)
        declare_sample_delay(selective_fading_model_sptr self, unsigned int delay)
        """
        return _channels_swig.selective_fading_model_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(selective_fading_model_sptr self, int which) -> unsigned int"""
        return _channels_swig.selective_fading_model_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(selective_fading_model_sptr self) -> int"""
        return _channels_swig.selective_fading_model_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(selective_fading_model_sptr self) -> double"""
        return _channels_swig.selective_fading_model_sptr_relative_rate(self)

    def start(self):
        """start(selective_fading_model_sptr self) -> bool"""
        return _channels_swig.selective_fading_model_sptr_start(self)

    def stop(self):
        """stop(selective_fading_model_sptr self) -> bool"""
        return _channels_swig.selective_fading_model_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(selective_fading_model_sptr self, unsigned int which_input) -> uint64_t"""
        return _channels_swig.selective_fading_model_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(selective_fading_model_sptr self, unsigned int which_output) -> uint64_t"""
        return _channels_swig.selective_fading_model_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(selective_fading_model_sptr self) -> int"""
        return _channels_swig.selective_fading_model_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(selective_fading_model_sptr self, int m)"""
        return _channels_swig.selective_fading_model_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(selective_fading_model_sptr self)"""
        return _channels_swig.selective_fading_model_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(selective_fading_model_sptr self) -> bool"""
        return _channels_swig.selective_fading_model_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(selective_fading_model_sptr self, int m)"""
        return _channels_swig.selective_fading_model_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(selective_fading_model_sptr self) -> int"""
        return _channels_swig.selective_fading_model_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(selective_fading_model_sptr self, int i) -> long"""
        return _channels_swig.selective_fading_model_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(selective_fading_model_sptr self, long max_output_buffer)
        set_max_output_buffer(selective_fading_model_sptr self, int port, long max_output_buffer)
        """
        return _channels_swig.selective_fading_model_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(selective_fading_model_sptr self, int i) -> long"""
        return _channels_swig.selective_fading_model_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(selective_fading_model_sptr self, long min_output_buffer)
        set_min_output_buffer(selective_fading_model_sptr self, int port, long min_output_buffer)
        """
        return _channels_swig.selective_fading_model_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(selective_fading_model_sptr self, int which) -> float
        pc_input_buffers_full(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(selective_fading_model_sptr self, int which) -> float
        pc_input_buffers_full_avg(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(selective_fading_model_sptr self, int which) -> float
        pc_input_buffers_full_var(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(selective_fading_model_sptr self, int which) -> float
        pc_output_buffers_full(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(selective_fading_model_sptr self, int which) -> float
        pc_output_buffers_full_avg(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(selective_fading_model_sptr self, int which) -> float
        pc_output_buffers_full_var(selective_fading_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.selective_fading_model_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(selective_fading_model_sptr self) -> float"""
        return _channels_swig.selective_fading_model_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(selective_fading_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.selective_fading_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(selective_fading_model_sptr self)"""
        return _channels_swig.selective_fading_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(selective_fading_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.selective_fading_model_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(selective_fading_model_sptr self) -> int"""
        return _channels_swig.selective_fading_model_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(selective_fading_model_sptr self) -> int"""
        return _channels_swig.selective_fading_model_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(selective_fading_model_sptr self, int priority) -> int"""
        return _channels_swig.selective_fading_model_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(selective_fading_model_sptr self) -> std::string"""
        return _channels_swig.selective_fading_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(selective_fading_model_sptr self) -> std::string"""
        return _channels_swig.selective_fading_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(selective_fading_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.selective_fading_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(selective_fading_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.selective_fading_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(selective_fading_model_sptr self) -> long"""
        return _channels_swig.selective_fading_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(selective_fading_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.selective_fading_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(selective_fading_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.selective_fading_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(selective_fading_model_sptr self) -> std::string"""
        return _channels_swig.selective_fading_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(selective_fading_model_sptr self, std::string name)"""
        return _channels_swig.selective_fading_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(selective_fading_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.selective_fading_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(selective_fading_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.selective_fading_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(selective_fading_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.selective_fading_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(selective_fading_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.selective_fading_model_sptr_message_subscribers(self, *args, **kwargs)

selective_fading_model_sptr_swigregister = _channels_swig.selective_fading_model_sptr_swigregister
selective_fading_model_sptr_swigregister(selective_fading_model_sptr)

selective_fading_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
selective_fading_model = selective_fading_model.make;

class sro_model_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::channels::sro_model)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::channels::sro_model)> self) -> sro_model_sptr
        __init__(boost::shared_ptr<(gr::channels::sro_model)> self, sro_model p) -> sro_model_sptr
        """
        this = _channels_swig.new_sro_model_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(sro_model_sptr self) -> sro_model"""
        return _channels_swig.sro_model_sptr___deref__(self)

    __swig_destroy__ = _channels_swig.delete_sro_model_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(sro_model_sptr self, double sample_rate_hz, double std_dev_hz, double max_dev_hz, double noise_seed=0) -> sro_model_sptr

        Sample Rate Offset Model.

        This block implements a model that varies sample rate offset with respect to time by performing a random walk on the interpolation rate.

        Constructor Specific Documentation:

        Build the sample rate offset model.

        Args:
            sample_rate_hz : Sample rate of the input signal in Hz
            std_dev_hz : Desired standard deviation of the random walk process every sample in Hz
            max_dev_hz : Maximum sample rate deviation from zero in Hz.
            noise_seed : A random number generator seed for the noise source.
        """
        return _channels_swig.sro_model_sptr_make(self, *args, **kwargs)

    def set_std_dev(self, *args, **kwargs):
        """set_std_dev(sro_model_sptr self, double _dev)"""
        return _channels_swig.sro_model_sptr_set_std_dev(self, *args, **kwargs)

    def set_max_dev(self, *args, **kwargs):
        """set_max_dev(sro_model_sptr self, double _dev)"""
        return _channels_swig.sro_model_sptr_set_max_dev(self, *args, **kwargs)

    def set_samp_rate(self, *args, **kwargs):
        """set_samp_rate(sro_model_sptr self, double _rate)"""
        return _channels_swig.sro_model_sptr_set_samp_rate(self, *args, **kwargs)

    def std_dev(self):
        """std_dev(sro_model_sptr self) -> double"""
        return _channels_swig.sro_model_sptr_std_dev(self)

    def max_dev(self):
        """max_dev(sro_model_sptr self) -> double"""
        return _channels_swig.sro_model_sptr_max_dev(self)

    def samp_rate(self):
        """samp_rate(sro_model_sptr self) -> double"""
        return _channels_swig.sro_model_sptr_samp_rate(self)

    def history(self):
        """history(sro_model_sptr self) -> unsigned int"""
        return _channels_swig.sro_model_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(sro_model_sptr self, int which, int delay)
        declare_sample_delay(sro_model_sptr self, unsigned int delay)
        """
        return _channels_swig.sro_model_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(sro_model_sptr self, int which) -> unsigned int"""
        return _channels_swig.sro_model_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(sro_model_sptr self) -> int"""
        return _channels_swig.sro_model_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(sro_model_sptr self) -> double"""
        return _channels_swig.sro_model_sptr_relative_rate(self)

    def start(self):
        """start(sro_model_sptr self) -> bool"""
        return _channels_swig.sro_model_sptr_start(self)

    def stop(self):
        """stop(sro_model_sptr self) -> bool"""
        return _channels_swig.sro_model_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(sro_model_sptr self, unsigned int which_input) -> uint64_t"""
        return _channels_swig.sro_model_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(sro_model_sptr self, unsigned int which_output) -> uint64_t"""
        return _channels_swig.sro_model_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(sro_model_sptr self) -> int"""
        return _channels_swig.sro_model_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(sro_model_sptr self, int m)"""
        return _channels_swig.sro_model_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(sro_model_sptr self)"""
        return _channels_swig.sro_model_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(sro_model_sptr self) -> bool"""
        return _channels_swig.sro_model_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(sro_model_sptr self, int m)"""
        return _channels_swig.sro_model_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(sro_model_sptr self) -> int"""
        return _channels_swig.sro_model_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(sro_model_sptr self, int i) -> long"""
        return _channels_swig.sro_model_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(sro_model_sptr self, long max_output_buffer)
        set_max_output_buffer(sro_model_sptr self, int port, long max_output_buffer)
        """
        return _channels_swig.sro_model_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(sro_model_sptr self, int i) -> long"""
        return _channels_swig.sro_model_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(sro_model_sptr self, long min_output_buffer)
        set_min_output_buffer(sro_model_sptr self, int port, long min_output_buffer)
        """
        return _channels_swig.sro_model_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(sro_model_sptr self, int which) -> float
        pc_input_buffers_full(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(sro_model_sptr self, int which) -> float
        pc_input_buffers_full_avg(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(sro_model_sptr self, int which) -> float
        pc_input_buffers_full_var(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(sro_model_sptr self, int which) -> float
        pc_output_buffers_full(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(sro_model_sptr self, int which) -> float
        pc_output_buffers_full_avg(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(sro_model_sptr self, int which) -> float
        pc_output_buffers_full_var(sro_model_sptr self) -> pmt_vector_float
        """
        return _channels_swig.sro_model_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(sro_model_sptr self) -> float"""
        return _channels_swig.sro_model_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(sro_model_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _channels_swig.sro_model_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(sro_model_sptr self)"""
        return _channels_swig.sro_model_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(sro_model_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _channels_swig.sro_model_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(sro_model_sptr self) -> int"""
        return _channels_swig.sro_model_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(sro_model_sptr self) -> int"""
        return _channels_swig.sro_model_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(sro_model_sptr self, int priority) -> int"""
        return _channels_swig.sro_model_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(sro_model_sptr self) -> std::string"""
        return _channels_swig.sro_model_sptr_name(self)

    def symbol_name(self):
        """symbol_name(sro_model_sptr self) -> std::string"""
        return _channels_swig.sro_model_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(sro_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.sro_model_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(sro_model_sptr self) -> io_signature_sptr"""
        return _channels_swig.sro_model_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(sro_model_sptr self) -> long"""
        return _channels_swig.sro_model_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(sro_model_sptr self) -> basic_block_sptr"""
        return _channels_swig.sro_model_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(sro_model_sptr self, int ninputs, int noutputs) -> bool"""
        return _channels_swig.sro_model_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(sro_model_sptr self) -> std::string"""
        return _channels_swig.sro_model_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(sro_model_sptr self, std::string name)"""
        return _channels_swig.sro_model_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(sro_model_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _channels_swig.sro_model_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(sro_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.sro_model_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(sro_model_sptr self) -> swig_int_ptr"""
        return _channels_swig.sro_model_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(sro_model_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _channels_swig.sro_model_sptr_message_subscribers(self, *args, **kwargs)

sro_model_sptr_swigregister = _channels_swig.sro_model_sptr_swigregister
sro_model_sptr_swigregister(sro_model_sptr)

sro_model_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
sro_model = sro_model.make;



