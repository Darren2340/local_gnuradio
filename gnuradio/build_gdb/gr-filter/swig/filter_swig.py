# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_filter_swig', [dirname(__file__)])
        except ImportError:
            import _filter_swig
            return _filter_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_filter_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _filter_swig = swig_import_helper()
    del swig_import_helper
else:
    import _filter_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _filter_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _filter_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _filter_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _filter_swig.high_res_timer_epoch()
class firdes(object):
    """Finite Impulse Response (FIR) filter design functions."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    WIN_NONE = _filter_swig.firdes_WIN_NONE
    WIN_HAMMING = _filter_swig.firdes_WIN_HAMMING
    WIN_HANN = _filter_swig.firdes_WIN_HANN
    WIN_BLACKMAN = _filter_swig.firdes_WIN_BLACKMAN
    WIN_RECTANGULAR = _filter_swig.firdes_WIN_RECTANGULAR
    WIN_KAISER = _filter_swig.firdes_WIN_KAISER
    WIN_BLACKMAN_hARRIS = _filter_swig.firdes_WIN_BLACKMAN_hARRIS
    WIN_BLACKMAN_HARRIS = _filter_swig.firdes_WIN_BLACKMAN_HARRIS
    WIN_BARTLETT = _filter_swig.firdes_WIN_BARTLETT
    WIN_FLATTOP = _filter_swig.firdes_WIN_FLATTOP
    def window(*args, **kwargs):
        """window(gr::filter::firdes::win_type type, int ntaps, double beta) -> pmt_vector_float"""
        return _filter_swig.firdes_window(*args, **kwargs)

    window = staticmethod(window)
    def low_pass(*args, **kwargs):
        """
        low_pass(double gain, double sampling_freq, double cutoff_freq, double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a low-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_low_pass(*args, **kwargs)

    low_pass = staticmethod(low_pass)
    def low_pass_2(*args, **kwargs):
        """
        low_pass_2(double gain, double sampling_freq, double cutoff_freq, double transition_width, double attenuation_dB, 
            gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> pmt_vector_float

        use "window method" to design a low-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz).  required stopband attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuatin > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_low_pass_2(*args, **kwargs)

    low_pass_2 = staticmethod(low_pass_2)
    def high_pass(*args, **kwargs):
        """
        high_pass(double gain, double sampling_freq, double cutoff_freq, double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a high-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_high_pass(*args, **kwargs)

    high_pass = staticmethod(high_pass)
    def high_pass_2(*args, **kwargs):
        """
        high_pass_2(double gain, double sampling_freq, double cutoff_freq, double transition_width, double attenuation_dB, 
            gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> pmt_vector_float

        use "window method" to design a high-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_high_pass_2(*args, **kwargs)

    high_pass_2 = staticmethod(high_pass_2)
    def band_pass(*args, **kwargs):
        """
        band_pass(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a band-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_band_pass(*args, **kwargs)

    band_pass = staticmethod(band_pass)
    def band_pass_2(*args, **kwargs):
        """
        band_pass_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a band-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_band_pass_2(*args, **kwargs)

    band_pass_2 = staticmethod(band_pass_2)
    def complex_band_pass(*args, **kwargs):
        """
        complex_band_pass(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_cfloat

        use "window method" to design a complex band-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_complex_band_pass(*args, **kwargs)

    complex_band_pass = staticmethod(complex_band_pass)
    def complex_band_pass_2(*args, **kwargs):
        """
        complex_band_pass_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_cfloat

        use "window method" to design a complex band-pass FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_complex_band_pass_2(*args, **kwargs)

    complex_band_pass_2 = staticmethod(complex_band_pass_2)
    def band_reject(*args, **kwargs):
        """
        band_reject(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a band-reject FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_band_reject(*args, **kwargs)

    band_reject = staticmethod(band_reject)
    def band_reject_2(*args, **kwargs):
        """
        band_reject_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
            double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
            double beta=6.76) -> pmt_vector_float

        use "window method" to design a band-reject FIR filter

        overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
        """
        return _filter_swig.firdes_band_reject_2(*args, **kwargs)

    band_reject_2 = staticmethod(band_reject_2)
    def hilbert(*args, **kwargs):
        """
        hilbert(unsigned int ntaps=19, gr::filter::firdes::win_type windowtype=WIN_RECTANGULAR, double beta=6.76) -> pmt_vector_float

        design a Hilbert Transform Filter

        Number of taps, must be odd  What kind of window to use  Only used for Kaiser
        """
        return _filter_swig.firdes_hilbert(*args, **kwargs)

    hilbert = staticmethod(hilbert)
    def root_raised_cosine(*args, **kwargs):
        """
        root_raised_cosine(double gain, double sampling_freq, double symbol_rate, double alpha, int ntaps) -> pmt_vector_float

        design a Root Cosine FIR Filter (do we need a window?)

        overall gain of filter (typically 1.0)  sampling freq (Hz)  rate: symbol rate, must be a factor of sample rate  excess bandwidth factor  number of taps
        """
        return _filter_swig.firdes_root_raised_cosine(*args, **kwargs)

    root_raised_cosine = staticmethod(root_raised_cosine)
    def gaussian(*args, **kwargs):
        """
        gaussian(double gain, double spb, double bt, int ntaps) -> pmt_vector_float

        design a Gaussian filter

        overall gain of filter (typically 1.0)  per bit: symbol rate, must be a factor of sample rate  number of taps
        """
        return _filter_swig.firdes_gaussian(*args, **kwargs)

    gaussian = staticmethod(gaussian)
    def __init__(self): 
        """__init__(gr::filter::firdes self) -> firdes"""
        this = _filter_swig.new_firdes()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _filter_swig.delete_firdes
    __del__ = lambda self : None;
firdes_swigregister = _filter_swig.firdes_swigregister
firdes_swigregister(firdes)

def firdes_window(*args, **kwargs):
  """firdes_window(gr::filter::firdes::win_type type, int ntaps, double beta) -> pmt_vector_float"""
  return _filter_swig.firdes_window(*args, **kwargs)

def firdes_low_pass(*args, **kwargs):
  """
    firdes_low_pass(double gain, double sampling_freq, double cutoff_freq, double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a low-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_low_pass(*args, **kwargs)

def firdes_low_pass_2(*args, **kwargs):
  """
    firdes_low_pass_2(double gain, double sampling_freq, double cutoff_freq, double transition_width, double attenuation_dB, 
        gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> pmt_vector_float

    use "window method" to design a low-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz).  required stopband attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuatin > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_low_pass_2(*args, **kwargs)

def firdes_high_pass(*args, **kwargs):
  """
    firdes_high_pass(double gain, double sampling_freq, double cutoff_freq, double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a high-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_high_pass(*args, **kwargs)

def firdes_high_pass_2(*args, **kwargs):
  """
    firdes_high_pass_2(double gain, double sampling_freq, double cutoff_freq, double transition_width, double attenuation_dB, 
        gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> pmt_vector_float

    use "window method" to design a high-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_high_pass_2(*args, **kwargs)

def firdes_band_pass(*args, **kwargs):
  """
    firdes_band_pass(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a band-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_band_pass(*args, **kwargs)

def firdes_band_pass_2(*args, **kwargs):
  """
    firdes_band_pass_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a band-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_band_pass_2(*args, **kwargs)

def firdes_complex_band_pass(*args, **kwargs):
  """
    firdes_complex_band_pass(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_cfloat

    use "window method" to design a complex band-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_complex_band_pass(*args, **kwargs)

def firdes_complex_band_pass_2(*args, **kwargs):
  """
    firdes_complex_band_pass_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_cfloat

    use "window method" to design a complex band-pass FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_complex_band_pass_2(*args, **kwargs)

def firdes_band_reject(*args, **kwargs):
  """
    firdes_band_reject(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a band-reject FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz). The normalized width of the transition band is what sets the number of taps required. Narrow > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_band_reject(*args, **kwargs)

def firdes_band_reject_2(*args, **kwargs):
  """
    firdes_band_reject_2(double gain, double sampling_freq, double low_cutoff_freq, double high_cutoff_freq, 
        double transition_width, double attenuation_dB, gr::filter::firdes::win_type window=WIN_HAMMING, 
        double beta=6.76) -> pmt_vector_float

    use "window method" to design a band-reject FIR filter

    overall gain of filter (typically 1.0)  sampling freq (Hz)  center of transition band (Hz)  center of transition band (Hz)  width of transition band (Hz).  out of band attenuation The normalized width of the transition band and the required stop band attenuation is what sets the number of taps required. Narrow > more taps More attenuation > more taps  What kind of window to use. Determines maximum attenuation and passband ripple.  parameter for Kaiser window
    """
  return _filter_swig.firdes_band_reject_2(*args, **kwargs)

def firdes_hilbert(*args, **kwargs):
  """
    firdes_hilbert(unsigned int ntaps=19, gr::filter::firdes::win_type windowtype=WIN_RECTANGULAR, double beta=6.76) -> pmt_vector_float

    design a Hilbert Transform Filter

    Number of taps, must be odd  What kind of window to use  Only used for Kaiser
    """
  return _filter_swig.firdes_hilbert(*args, **kwargs)

def firdes_root_raised_cosine(*args, **kwargs):
  """
    firdes_root_raised_cosine(double gain, double sampling_freq, double symbol_rate, double alpha, int ntaps) -> pmt_vector_float

    design a Root Cosine FIR Filter (do we need a window?)

    overall gain of filter (typically 1.0)  sampling freq (Hz)  rate: symbol rate, must be a factor of sample rate  excess bandwidth factor  number of taps
    """
  return _filter_swig.firdes_root_raised_cosine(*args, **kwargs)

def firdes_gaussian(*args, **kwargs):
  """
    firdes_gaussian(double gain, double spb, double bt, int ntaps) -> pmt_vector_float

    design a Gaussian filter

    overall gain of filter (typically 1.0)  per bit: symbol rate, must be a factor of sample rate  number of taps
    """
  return _filter_swig.firdes_gaussian(*args, **kwargs)


def pm_remez(*args, **kwargs):
  """
    pm_remez(int order, pmt_vector_double bands, pmt_vector_double ampl, pmt_vector_double error_weight, 
        std::string const filter_type="bandpass", int grid_density=16) -> pmt_vector_double

    Parks-McClellan FIR filter design using Remez algorithm.

    Calculates the optimal (in the Chebyshev/minimax sense) FIR filter inpulse reponse given a set of band edges, the desired reponse on those bands, and the weight given to the error in those bands.


    Frequency is in the range [0, 1], with 1 being the Nyquist frequency (Fs/2)
    """
  return _filter_swig.pm_remez(*args, **kwargs)
class dc_blocker_cc(object):
    """
    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Constructor Specific Documentation:

    Make a DC blocker block.

    Args:
        D : (int) the length of the delay line
        long_form : (bool) whether to use long (true, default) or short form
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int D, bool long_form) -> dc_blocker_cc_sptr

        a computationally efficient controllable DC blocker

        This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

        The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

        The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

        The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

        The theory behind this block can be found in the paper:

        Constructor Specific Documentation:

        Make a DC blocker block.

        Args:
            D : (int) the length of the delay line
            long_form : (bool) whether to use long (true, default) or short form
        """
        return _filter_swig.dc_blocker_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def group_delay(self):
        """group_delay(dc_blocker_cc self) -> int"""
        return _filter_swig.dc_blocker_cc_group_delay(self)

    __swig_destroy__ = _filter_swig.delete_dc_blocker_cc
    __del__ = lambda self : None;
dc_blocker_cc_swigregister = _filter_swig.dc_blocker_cc_swigregister
dc_blocker_cc_swigregister(dc_blocker_cc)

def dc_blocker_cc_make(*args, **kwargs):
  """
    dc_blocker_cc_make(int D, bool long_form) -> dc_blocker_cc_sptr

    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Constructor Specific Documentation:

    Make a DC blocker block.

    Args:
        D : (int) the length of the delay line
        long_form : (bool) whether to use long (true, default) or short form
    """
  return _filter_swig.dc_blocker_cc_make(*args, **kwargs)

class dc_blocker_ff(object):
    """
    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Constructor Specific Documentation:

    Make a DC blocker block.

    Args:
        D : (int) the length of the delay line
        long_form : (bool) whether to use long (true, default) or short form
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int D, bool long_form=True) -> dc_blocker_ff_sptr

        a computationally efficient controllable DC blocker

        This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

        The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

        The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

        The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

        The theory behind this block can be found in the paper:

        Constructor Specific Documentation:

        Make a DC blocker block.

        Args:
            D : (int) the length of the delay line
            long_form : (bool) whether to use long (true, default) or short form
        """
        return _filter_swig.dc_blocker_ff_make(*args, **kwargs)

    make = staticmethod(make)
    def group_delay(self):
        """group_delay(dc_blocker_ff self) -> int"""
        return _filter_swig.dc_blocker_ff_group_delay(self)

    __swig_destroy__ = _filter_swig.delete_dc_blocker_ff
    __del__ = lambda self : None;
dc_blocker_ff_swigregister = _filter_swig.dc_blocker_ff_swigregister
dc_blocker_ff_swigregister(dc_blocker_ff)

def dc_blocker_ff_make(*args, **kwargs):
  """
    dc_blocker_ff_make(int D, bool long_form=True) -> dc_blocker_ff_sptr

    a computationally efficient controllable DC blocker

    This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

    The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

    The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

    The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

    The theory behind this block can be found in the paper:

    Constructor Specific Documentation:

    Make a DC blocker block.

    Args:
        D : (int) the length of the delay line
        long_form : (bool) whether to use long (true, default) or short form
    """
  return _filter_swig.dc_blocker_ff_make(*args, **kwargs)

class filter_delay_fc(object):
    """
    Filter-Delay Combination Block.

    The block takes one or two float stream and outputs a complex stream.

    If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output.

    If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output.

    The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.

    Constructor Specific Documentation:

    Build a filter with delay block.

    Args:
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float taps) -> filter_delay_fc_sptr

        Filter-Delay Combination Block.

        The block takes one or two float stream and outputs a complex stream.

        If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output.

        If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output.

        The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.

        Constructor Specific Documentation:

        Build a filter with delay block.

        Args:
            taps : 
        """
        return _filter_swig.filter_delay_fc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _filter_swig.delete_filter_delay_fc
    __del__ = lambda self : None;
filter_delay_fc_swigregister = _filter_swig.filter_delay_fc_swigregister
filter_delay_fc_swigregister(filter_delay_fc)

def filter_delay_fc_make(*args, **kwargs):
  """
    filter_delay_fc_make(pmt_vector_float taps) -> filter_delay_fc_sptr

    Filter-Delay Combination Block.

    The block takes one or two float stream and outputs a complex stream.

    If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output.

    If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output.

    The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.

    Constructor Specific Documentation:

    Build a filter with delay block.

    Args:
        taps : 
    """
  return _filter_swig.filter_delay_fc_make(*args, **kwargs)

class filterbank_vcvcf(object):
    """
    Filterbank with vector of gr_complex input, vector of gr_complex output and float taps.

    This block takes in complex vectors and outputs complex vectors of the same size. Vectors of length N, rather than N normal streams are used to reduce overhead.

    Constructor Specific Documentation:

    Build the filterbank.

    Args:
        taps : (vector of vector of floats/list of list of floats) Used to populate the filters.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & taps) -> filterbank_vcvcf_sptr

        Filterbank with vector of gr_complex input, vector of gr_complex output and float taps.

        This block takes in complex vectors and outputs complex vectors of the same size. Vectors of length N, rather than N normal streams are used to reduce overhead.

        Constructor Specific Documentation:

        Build the filterbank.

        Args:
            taps : (vector of vector of floats/list of list of floats) Used to populate the filters.
        """
        return _filter_swig.filterbank_vcvcf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(filterbank_vcvcf self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.filterbank_vcvcf_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(filterbank_vcvcf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.filterbank_vcvcf_print_taps(self)

    def taps(self):
        """
        taps(filterbank_vcvcf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.filterbank_vcvcf_taps(self)

    __swig_destroy__ = _filter_swig.delete_filterbank_vcvcf
    __del__ = lambda self : None;
filterbank_vcvcf_swigregister = _filter_swig.filterbank_vcvcf_swigregister
filterbank_vcvcf_swigregister(filterbank_vcvcf)

def filterbank_vcvcf_make(*args, **kwargs):
  """
    filterbank_vcvcf_make(std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & taps) -> filterbank_vcvcf_sptr

    Filterbank with vector of gr_complex input, vector of gr_complex output and float taps.

    This block takes in complex vectors and outputs complex vectors of the same size. Vectors of length N, rather than N normal streams are used to reduce overhead.

    Constructor Specific Documentation:

    Build the filterbank.

    Args:
        taps : (vector of vector of floats/list of list of floats) Used to populate the filters.
    """
  return _filter_swig.filterbank_vcvcf_make(*args, **kwargs)

class fir_filter_ccc(object):
    """
    FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps) -> fir_filter_ccc_sptr

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_ccc self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_ccc self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_ccc_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_ccc
    __del__ = lambda self : None;
fir_filter_ccc_swigregister = _filter_swig.fir_filter_ccc_swigregister
fir_filter_ccc_swigregister(fir_filter_ccc)

def fir_filter_ccc_make(*args, **kwargs):
  """
    fir_filter_ccc_make(int decimation, pmt_vector_cfloat taps) -> fir_filter_ccc_sptr

    FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.fir_filter_ccc_make(*args, **kwargs)

class fir_filter_ccf(object):
    """
    FIR filter with gr_complex input, gr_complex output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps) -> fir_filter_ccf_sptr

        FIR filter with gr_complex input, gr_complex output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_ccf self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_ccf self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_ccf_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_ccf
    __del__ = lambda self : None;
fir_filter_ccf_swigregister = _filter_swig.fir_filter_ccf_swigregister
fir_filter_ccf_swigregister(fir_filter_ccf)

def fir_filter_ccf_make(*args, **kwargs):
  """
    fir_filter_ccf_make(int decimation, pmt_vector_float taps) -> fir_filter_ccf_sptr

    FIR filter with gr_complex input, gr_complex output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.fir_filter_ccf_make(*args, **kwargs)

class fir_filter_fcc(object):
    """
    FIR filter with float input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps) -> fir_filter_fcc_sptr

        FIR filter with float input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_fcc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fcc self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_fcc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fcc self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_fcc_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fcc
    __del__ = lambda self : None;
fir_filter_fcc_swigregister = _filter_swig.fir_filter_fcc_swigregister
fir_filter_fcc_swigregister(fir_filter_fcc)

def fir_filter_fcc_make(*args, **kwargs):
  """
    fir_filter_fcc_make(int decimation, pmt_vector_cfloat taps) -> fir_filter_fcc_sptr

    FIR filter with float input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.fir_filter_fcc_make(*args, **kwargs)

class fir_filter_fff(object):
    """
    FIR filter with float input, float output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, float output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps) -> fir_filter_fff_sptr

        FIR filter with float input, float output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, float output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fff self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fff self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_fff_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fff
    __del__ = lambda self : None;
fir_filter_fff_swigregister = _filter_swig.fir_filter_fff_swigregister
fir_filter_fff_swigregister(fir_filter_fff)

def fir_filter_fff_make(*args, **kwargs):
  """
    fir_filter_fff_make(int decimation, pmt_vector_float taps) -> fir_filter_fff_sptr

    FIR filter with float input, float output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, float output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.fir_filter_fff_make(*args, **kwargs)

class fir_filter_fsf(object):
    """
    FIR filter with float input, short output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, short output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps) -> fir_filter_fsf_sptr

        FIR filter with float input, short output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, short output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_fsf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fsf self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_fsf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fsf self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_fsf_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fsf
    __del__ = lambda self : None;
fir_filter_fsf_swigregister = _filter_swig.fir_filter_fsf_swigregister
fir_filter_fsf_swigregister(fir_filter_fsf)

def fir_filter_fsf_make(*args, **kwargs):
  """
    fir_filter_fsf_make(int decimation, pmt_vector_float taps) -> fir_filter_fsf_sptr

    FIR filter with float input, short output, and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with float input, short output, and float taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.fir_filter_fsf_make(*args, **kwargs)

class fir_filter_scc(object):
    """
    FIR filter with short input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps) -> fir_filter_scc_sptr

        FIR filter with short input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_scc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_scc self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_scc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_scc self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_scc_taps(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_scc
    __del__ = lambda self : None;
fir_filter_scc_swigregister = _filter_swig.fir_filter_scc_swigregister
fir_filter_scc_swigregister(fir_filter_scc)

def fir_filter_scc_make(*args, **kwargs):
  """
    fir_filter_scc_make(int decimation, pmt_vector_cfloat taps) -> fir_filter_scc_sptr

    FIR filter with short input, gr_complex output, and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and gr_complex taps.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.fir_filter_scc_make(*args, **kwargs)

class fft_filter_ccc(object):
    """
    Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.

    This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter blocks.

    Args:
        decimation : >= 1
        taps : complex filter taps
        nthreads : number of threads for the FFT to use
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps, int nthreads=1) -> fft_filter_ccc_sptr

        Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.

        This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter blocks.

        Args:
            decimation : >= 1
            taps : complex filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_ccc self, pmt_vector_cfloat taps)"""
        return _filter_swig.fft_filter_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_ccc self) -> pmt_vector_cfloat"""
        return _filter_swig.fft_filter_ccc_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_ccc self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_ccc_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_ccc self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_ccc_nthreads(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_ccc
    __del__ = lambda self : None;
fft_filter_ccc_swigregister = _filter_swig.fft_filter_ccc_swigregister
fft_filter_ccc_swigregister(fft_filter_ccc)

def fft_filter_ccc_make(*args, **kwargs):
  """
    fft_filter_ccc_make(int decimation, pmt_vector_cfloat taps, int nthreads=1) -> fft_filter_ccc_sptr

    Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.

    This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter blocks.

    Args:
        decimation : >= 1
        taps : complex filter taps
        nthreads : number of threads for the FFT to use
    """
  return _filter_swig.fft_filter_ccc_make(*args, **kwargs)

class fft_filter_ccf(object):
    """
    Fast FFT filter with gr_complex input, gr_complex output and float taps.

    This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter blocks.

    Args:
        decimation : >= 1
        taps : complex filter taps
        nthreads : number of threads for the FFT to use
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_ccf_sptr

        Fast FFT filter with gr_complex input, gr_complex output and float taps.

        This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter blocks.

        Args:
            decimation : >= 1
            taps : complex filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_ccf self, pmt_vector_float taps)"""
        return _filter_swig.fft_filter_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_ccf self) -> pmt_vector_float"""
        return _filter_swig.fft_filter_ccf_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_ccf self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_ccf_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_ccf self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_ccf_nthreads(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_ccf
    __del__ = lambda self : None;
fft_filter_ccf_swigregister = _filter_swig.fft_filter_ccf_swigregister
fft_filter_ccf_swigregister(fft_filter_ccf)

def fft_filter_ccf_make(*args, **kwargs):
  """
    fft_filter_ccf_make(int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_ccf_sptr

    Fast FFT filter with gr_complex input, gr_complex output and float taps.

    This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter blocks.

    Args:
        decimation : >= 1
        taps : complex filter taps
        nthreads : number of threads for the FFT to use
    """
  return _filter_swig.fft_filter_ccf_make(*args, **kwargs)

class fft_filter_fff(object):
    """
    Fast FFT filter with float input, float output and float taps.

    This block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of real-valued taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter block.

    Args:
        decimation : >= 1
        taps : float filter taps
        nthreads : number of threads for the FFT to use
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_fff_sptr

        Fast FFT filter with float input, float output and float taps.

        This block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of real-valued taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter block.

        Args:
            decimation : >= 1
            taps : float filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_fff self, pmt_vector_float taps)"""
        return _filter_swig.fft_filter_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_fff self) -> pmt_vector_float"""
        return _filter_swig.fft_filter_fff_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_fff self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_fff_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_fff self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_fff_nthreads(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_fff
    __del__ = lambda self : None;
fft_filter_fff_swigregister = _filter_swig.fft_filter_fff_swigregister
fft_filter_fff_swigregister(fft_filter_fff)

def fft_filter_fff_make(*args, **kwargs):
  """
    fft_filter_fff_make(int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_fff_sptr

    Fast FFT filter with float input, float output and float taps.

    This block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

    The filter takes a set of real-valued taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

    This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

    Constructor Specific Documentation:

    Build an FFT filter block.

    Args:
        decimation : >= 1
        taps : float filter taps
        nthreads : number of threads for the FFT to use
    """
  return _filter_swig.fft_filter_fff_make(*args, **kwargs)

class fractional_interpolator_cc(object):
    """
    Interpolating MMSE filter with complex input, complex output.

    Constructor Specific Documentation:

    Build the interpolating MMSE filter (complex input, complex output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        interp_ratio : The interpolation ratio = input_rate / output_rate.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float phase_shift, float interp_ratio) -> fractional_interpolator_cc_sptr

        Interpolating MMSE filter with complex input, complex output.

        Constructor Specific Documentation:

        Build the interpolating MMSE filter (complex input, complex output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            interp_ratio : The interpolation ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_interpolator_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(fractional_interpolator_cc self) -> float"""
        return _filter_swig.fractional_interpolator_cc_mu(self)

    def interp_ratio(self):
        """interp_ratio(fractional_interpolator_cc self) -> float"""
        return _filter_swig.fractional_interpolator_cc_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_interpolator_cc self, float mu)"""
        return _filter_swig.fractional_interpolator_cc_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(fractional_interpolator_cc self, float interp_ratio)"""
        return _filter_swig.fractional_interpolator_cc_set_interp_ratio(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_fractional_interpolator_cc
    __del__ = lambda self : None;
fractional_interpolator_cc_swigregister = _filter_swig.fractional_interpolator_cc_swigregister
fractional_interpolator_cc_swigregister(fractional_interpolator_cc)

def fractional_interpolator_cc_make(*args, **kwargs):
  """
    fractional_interpolator_cc_make(float phase_shift, float interp_ratio) -> fractional_interpolator_cc_sptr

    Interpolating MMSE filter with complex input, complex output.

    Constructor Specific Documentation:

    Build the interpolating MMSE filter (complex input, complex output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        interp_ratio : The interpolation ratio = input_rate / output_rate.
    """
  return _filter_swig.fractional_interpolator_cc_make(*args, **kwargs)

class fractional_interpolator_ff(object):
    """
    Interpolating MMSE filter with float input, float output.

    Constructor Specific Documentation:

    Build the interpolating MMSE filter (float input, float output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        interp_ratio : The interpolation ratio = input_rate / output_rate.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float phase_shift, float interp_ratio) -> fractional_interpolator_ff_sptr

        Interpolating MMSE filter with float input, float output.

        Constructor Specific Documentation:

        Build the interpolating MMSE filter (float input, float output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            interp_ratio : The interpolation ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_interpolator_ff_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(fractional_interpolator_ff self) -> float"""
        return _filter_swig.fractional_interpolator_ff_mu(self)

    def interp_ratio(self):
        """interp_ratio(fractional_interpolator_ff self) -> float"""
        return _filter_swig.fractional_interpolator_ff_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_interpolator_ff self, float mu)"""
        return _filter_swig.fractional_interpolator_ff_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(fractional_interpolator_ff self, float interp_ratio)"""
        return _filter_swig.fractional_interpolator_ff_set_interp_ratio(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_fractional_interpolator_ff
    __del__ = lambda self : None;
fractional_interpolator_ff_swigregister = _filter_swig.fractional_interpolator_ff_swigregister
fractional_interpolator_ff_swigregister(fractional_interpolator_ff)

def fractional_interpolator_ff_make(*args, **kwargs):
  """
    fractional_interpolator_ff_make(float phase_shift, float interp_ratio) -> fractional_interpolator_ff_sptr

    Interpolating MMSE filter with float input, float output.

    Constructor Specific Documentation:

    Build the interpolating MMSE filter (float input, float output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        interp_ratio : The interpolation ratio = input_rate / output_rate.
    """
  return _filter_swig.fractional_interpolator_ff_make(*args, **kwargs)

class fractional_resampler_cc(object):
    """
    resampling MMSE filter with complex input, complex output

    Constructor Specific Documentation:

    Build the resampling MMSE filter (complex input, complex output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        resamp_ratio : The resampling ratio = input_rate / output_rate.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float phase_shift, float resamp_ratio) -> fractional_resampler_cc_sptr

        resampling MMSE filter with complex input, complex output

        Constructor Specific Documentation:

        Build the resampling MMSE filter (complex input, complex output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            resamp_ratio : The resampling ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_resampler_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(fractional_resampler_cc self) -> float"""
        return _filter_swig.fractional_resampler_cc_mu(self)

    def resamp_ratio(self):
        """resamp_ratio(fractional_resampler_cc self) -> float"""
        return _filter_swig.fractional_resampler_cc_resamp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_resampler_cc self, float mu)"""
        return _filter_swig.fractional_resampler_cc_set_mu(self, *args, **kwargs)

    def set_resamp_ratio(self, *args, **kwargs):
        """set_resamp_ratio(fractional_resampler_cc self, float resamp_ratio)"""
        return _filter_swig.fractional_resampler_cc_set_resamp_ratio(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_fractional_resampler_cc
    __del__ = lambda self : None;
fractional_resampler_cc_swigregister = _filter_swig.fractional_resampler_cc_swigregister
fractional_resampler_cc_swigregister(fractional_resampler_cc)

def fractional_resampler_cc_make(*args, **kwargs):
  """
    fractional_resampler_cc_make(float phase_shift, float resamp_ratio) -> fractional_resampler_cc_sptr

    resampling MMSE filter with complex input, complex output

    Constructor Specific Documentation:

    Build the resampling MMSE filter (complex input, complex output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        resamp_ratio : The resampling ratio = input_rate / output_rate.
    """
  return _filter_swig.fractional_resampler_cc_make(*args, **kwargs)

class fractional_resampler_ff(object):
    """
    Resampling MMSE filter with float input, float output.

    Constructor Specific Documentation:

    Build the resampling MMSE filter (float input, float output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        resamp_ratio : The resampling ratio = input_rate / output_rate.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float phase_shift, float resamp_ratio) -> fractional_resampler_ff_sptr

        Resampling MMSE filter with float input, float output.

        Constructor Specific Documentation:

        Build the resampling MMSE filter (float input, float output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            resamp_ratio : The resampling ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_resampler_ff_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(fractional_resampler_ff self) -> float"""
        return _filter_swig.fractional_resampler_ff_mu(self)

    def resamp_ratio(self):
        """resamp_ratio(fractional_resampler_ff self) -> float"""
        return _filter_swig.fractional_resampler_ff_resamp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_resampler_ff self, float mu)"""
        return _filter_swig.fractional_resampler_ff_set_mu(self, *args, **kwargs)

    def set_resamp_ratio(self, *args, **kwargs):
        """set_resamp_ratio(fractional_resampler_ff self, float resamp_ratio)"""
        return _filter_swig.fractional_resampler_ff_set_resamp_ratio(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_fractional_resampler_ff
    __del__ = lambda self : None;
fractional_resampler_ff_swigregister = _filter_swig.fractional_resampler_ff_swigregister
fractional_resampler_ff_swigregister(fractional_resampler_ff)

def fractional_resampler_ff_make(*args, **kwargs):
  """
    fractional_resampler_ff_make(float phase_shift, float resamp_ratio) -> fractional_resampler_ff_sptr

    Resampling MMSE filter with float input, float output.

    Constructor Specific Documentation:

    Build the resampling MMSE filter (float input, float output)

    Args:
        phase_shift : The phase shift of the output signal to the input
        resamp_ratio : The resampling ratio = input_rate / output_rate.
    """
  return _filter_swig.fractional_resampler_ff_make(*args, **kwargs)

class freq_xlating_fir_filter_ccc(object):
    """
    FIR filter combined with frequency translation with gr_complex input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccc_sptr

        FIR filter combined with frequency translation with gr_complex input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_ccc self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_ccc self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccc_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_ccc self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_ccc self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_ccc_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_ccc
    __del__ = lambda self : None;
freq_xlating_fir_filter_ccc_swigregister = _filter_swig.freq_xlating_fir_filter_ccc_swigregister
freq_xlating_fir_filter_ccc_swigregister(freq_xlating_fir_filter_ccc)

def freq_xlating_fir_filter_ccc_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_ccc_make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccc_sptr

    FIR filter combined with frequency translation with gr_complex input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_ccc_make(*args, **kwargs)

class freq_xlating_fir_filter_ccf(object):
    """
    FIR filter combined with frequency translation with gr_complex input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccf_sptr

        FIR filter combined with frequency translation with gr_complex input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_ccf self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_ccf self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccf_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_ccf self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_ccf self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_ccf
    __del__ = lambda self : None;
freq_xlating_fir_filter_ccf_swigregister = _filter_swig.freq_xlating_fir_filter_ccf_swigregister
freq_xlating_fir_filter_ccf_swigregister(freq_xlating_fir_filter_ccf)

def freq_xlating_fir_filter_ccf_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_ccf_make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccf_sptr

    FIR filter combined with frequency translation with gr_complex input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with gr_complex input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_ccf_make(*args, **kwargs)

class freq_xlating_fir_filter_fcc(object):
    """
    FIR filter combined with frequency translation with float input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcc_sptr

        FIR filter combined with frequency translation with float input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_fcc self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_fcc self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcc_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_fcc self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_fcc self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_fcc_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_fcc
    __del__ = lambda self : None;
freq_xlating_fir_filter_fcc_swigregister = _filter_swig.freq_xlating_fir_filter_fcc_swigregister
freq_xlating_fir_filter_fcc_swigregister(freq_xlating_fir_filter_fcc)

def freq_xlating_fir_filter_fcc_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_fcc_make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcc_sptr

    FIR filter combined with frequency translation with float input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_fcc_make(*args, **kwargs)

class freq_xlating_fir_filter_fcf(object):
    """
    FIR filter combined with frequency translation with float input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcf_sptr

        FIR filter combined with frequency translation with float input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_fcf self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_fcf self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcf_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_fcf self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_fcf self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_fcf
    __del__ = lambda self : None;
freq_xlating_fir_filter_fcf_swigregister = _filter_swig.freq_xlating_fir_filter_fcf_swigregister
freq_xlating_fir_filter_fcf_swigregister(freq_xlating_fir_filter_fcf)

def freq_xlating_fir_filter_fcf_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_fcf_make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcf_sptr

    FIR filter combined with frequency translation with float input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with float input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_fcf_make(*args, **kwargs)

class freq_xlating_fir_filter_scf(object):
    """
    FIR filter combined with frequency translation with short input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scf_sptr

        FIR filter combined with frequency translation with short input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_scf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_scf self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_scf_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_scf self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scf_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_scf self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_scf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_scf self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_scf_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_scf
    __del__ = lambda self : None;
freq_xlating_fir_filter_scf_swigregister = _filter_swig.freq_xlating_fir_filter_scf_swigregister
freq_xlating_fir_filter_scf_swigregister(freq_xlating_fir_filter_scf)

def freq_xlating_fir_filter_scf_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_scf_make(int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scf_sptr

    FIR filter combined with frequency translation with short input, gr_complex output and float taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and float taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type float
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_scf_make(*args, **kwargs)

class freq_xlating_fir_filter_scc(object):
    """
    FIR filter combined with frequency translation with short input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scc_sptr

        FIR filter combined with frequency translation with short input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_scc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_scc self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_scc_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_scc self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scc_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_scc self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_scc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_scc self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_scc_taps(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_scc
    __del__ = lambda self : None;
freq_xlating_fir_filter_scc_swigregister = _filter_swig.freq_xlating_fir_filter_scc_swigregister
freq_xlating_fir_filter_scc_swigregister(freq_xlating_fir_filter_scc)

def freq_xlating_fir_filter_scc_make(*args, **kwargs):
  """
    freq_xlating_fir_filter_scc_make(int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scc_sptr

    FIR filter combined with frequency translation with short input, gr_complex output and gr_complex taps.

    This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
    selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

    Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

    Constructor Specific Documentation:

    FIR filter with short input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

    Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

    Args:
        decimation : set the integer decimation rate
        taps : a vector/list of taps of type gr_complex
        center_freq : Center frequency of signal to down convert from (Hz)
        sampling_freq : Sampling rate of signal (in Hz)
    """
  return _filter_swig.freq_xlating_fir_filter_scc_make(*args, **kwargs)

class hilbert_fc(object):
    """
    Hilbert transformer.

    real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.

    Constructor Specific Documentation:

    Build a Hilbert transformer filter block.

    Args:
        ntaps : The number of taps for the filter.
        window : Window type (see firdes::win_type) to use.
        beta : Beta value for a Kaiser window.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int ntaps, gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> hilbert_fc_sptr

        Hilbert transformer.

        real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.

        Constructor Specific Documentation:

        Build a Hilbert transformer filter block.

        Args:
            ntaps : The number of taps for the filter.
            window : Window type (see firdes::win_type) to use.
            beta : Beta value for a Kaiser window.
        """
        return _filter_swig.hilbert_fc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _filter_swig.delete_hilbert_fc
    __del__ = lambda self : None;
hilbert_fc_swigregister = _filter_swig.hilbert_fc_swigregister
hilbert_fc_swigregister(hilbert_fc)

def hilbert_fc_make(*args, **kwargs):
  """
    hilbert_fc_make(unsigned int ntaps, gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> hilbert_fc_sptr

    Hilbert transformer.

    real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.

    Constructor Specific Documentation:

    Build a Hilbert transformer filter block.

    Args:
        ntaps : The number of taps for the filter.
        window : Window type (see firdes::win_type) to use.
        beta : Beta value for a Kaiser window.
    """
  return _filter_swig.hilbert_fc_make(*args, **kwargs)

class iir_filter_ffd(object):
    """
    IIR filter with float input, float output and double taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ffd_sptr

        IIR filter with float input, float output and double taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ffd_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ffd self, pmt_vector_double fftaps, pmt_vector_double fbtaps)"""
        return _filter_swig.iir_filter_ffd_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ffd
    __del__ = lambda self : None;
iir_filter_ffd_swigregister = _filter_swig.iir_filter_ffd_swigregister
iir_filter_ffd_swigregister(iir_filter_ffd)

def iir_filter_ffd_make(*args, **kwargs):
  """
    iir_filter_ffd_make(pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ffd_sptr

    IIR filter with float input, float output and double taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
  return _filter_swig.iir_filter_ffd_make(*args, **kwargs)

class iir_filter_ccc(object):
    """
    IIR filter with complex input, complex output, and complex taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat fftaps, pmt_vector_cfloat fbtaps, bool oldstyle=True) -> iir_filter_ccc_sptr

        IIR filter with complex input, complex output, and complex taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccc self, pmt_vector_cfloat fftaps, pmt_vector_cfloat fbtaps)"""
        return _filter_swig.iir_filter_ccc_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccc
    __del__ = lambda self : None;
iir_filter_ccc_swigregister = _filter_swig.iir_filter_ccc_swigregister
iir_filter_ccc_swigregister(iir_filter_ccc)

def iir_filter_ccc_make(*args, **kwargs):
  """
    iir_filter_ccc_make(pmt_vector_cfloat fftaps, pmt_vector_cfloat fbtaps, bool oldstyle=True) -> iir_filter_ccc_sptr

    IIR filter with complex input, complex output, and complex taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
  return _filter_swig.iir_filter_ccc_make(*args, **kwargs)

class iir_filter_ccf(object):
    """
    IIR filter with complex input, complex output, and float taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float fftaps, pmt_vector_float fbtaps, bool oldstyle=True) -> iir_filter_ccf_sptr

        IIR filter with complex input, complex output, and float taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccf self, pmt_vector_float fftaps, pmt_vector_float fbtaps)"""
        return _filter_swig.iir_filter_ccf_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccf
    __del__ = lambda self : None;
iir_filter_ccf_swigregister = _filter_swig.iir_filter_ccf_swigregister
iir_filter_ccf_swigregister(iir_filter_ccf)

def iir_filter_ccf_make(*args, **kwargs):
  """
    iir_filter_ccf_make(pmt_vector_float fftaps, pmt_vector_float fbtaps, bool oldstyle=True) -> iir_filter_ccf_sptr

    IIR filter with complex input, complex output, and float taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
  return _filter_swig.iir_filter_ccf_make(*args, **kwargs)

class iir_filter_ccd(object):
    """
    IIR filter with complex input, complex output, and double taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ccd_sptr

        IIR filter with complex input, complex output, and double taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccd_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccd self, pmt_vector_double fftaps, pmt_vector_double fbtaps)"""
        return _filter_swig.iir_filter_ccd_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccd
    __del__ = lambda self : None;
iir_filter_ccd_swigregister = _filter_swig.iir_filter_ccd_swigregister
iir_filter_ccd_swigregister(iir_filter_ccd)

def iir_filter_ccd_make(*args, **kwargs):
  """
    iir_filter_ccd_make(pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ccd_sptr

    IIR filter with complex input, complex output, and double taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
  return _filter_swig.iir_filter_ccd_make(*args, **kwargs)

class iir_filter_ccz(object):
    """
    IIR filter with complex input, complex output, and complex (double) taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cdouble fftaps, pmt_vector_cdouble fbtaps, bool oldstyle=True) -> iir_filter_ccz_sptr

        IIR filter with complex input, complex output, and complex (double) taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccz_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccz self, pmt_vector_cdouble fftaps, pmt_vector_cdouble fbtaps)"""
        return _filter_swig.iir_filter_ccz_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccz
    __del__ = lambda self : None;
iir_filter_ccz_swigregister = _filter_swig.iir_filter_ccz_swigregister
iir_filter_ccz_swigregister(iir_filter_ccz)

def iir_filter_ccz_make(*args, **kwargs):
  """
    iir_filter_ccz_make(pmt_vector_cdouble fftaps, pmt_vector_cdouble fbtaps, bool oldstyle=True) -> iir_filter_ccz_sptr

    IIR filter with complex input, complex output, and complex (double) taps.

    This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

     The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

    The input and output satisfy a difference equation of the form 

     
    y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


    with the corresponding rational system function 

     
    H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

    Constructor Specific Documentation:



    Args:
        fftaps : 
        fbtaps : 
        oldstyle : 
    """
  return _filter_swig.iir_filter_ccz_make(*args, **kwargs)

class interp_fir_filter_ccc(object):
    """
    Interpolating FIR filter with gr_complex input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_ccc_sptr

        Interpolating FIR filter with gr_complex input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_ccc self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_ccc self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_ccc_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_ccc
    __del__ = lambda self : None;
interp_fir_filter_ccc_swigregister = _filter_swig.interp_fir_filter_ccc_swigregister
interp_fir_filter_ccc_swigregister(interp_fir_filter_ccc)

def interp_fir_filter_ccc_make(*args, **kwargs):
  """
    interp_fir_filter_ccc_make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_ccc_sptr

    Interpolating FIR filter with gr_complex input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.interp_fir_filter_ccc_make(*args, **kwargs)

class interp_fir_filter_ccf(object):
    """
    Interpolating FIR filter with gr_complex input, gr_complex output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with gr_complex input, gr_complex output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_ccf_sptr

        Interpolating FIR filter with gr_complex input, gr_complex output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with gr_complex input, gr_complex output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_ccf self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_ccf self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_ccf_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_ccf
    __del__ = lambda self : None;
interp_fir_filter_ccf_swigregister = _filter_swig.interp_fir_filter_ccf_swigregister
interp_fir_filter_ccf_swigregister(interp_fir_filter_ccf)

def interp_fir_filter_ccf_make(*args, **kwargs):
  """
    interp_fir_filter_ccf_make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_ccf_sptr

    Interpolating FIR filter with gr_complex input, gr_complex output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with gr_complex input, gr_complex output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.interp_fir_filter_ccf_make(*args, **kwargs)

class interp_fir_filter_fcc(object):
    """
    Interpolating FIR filter with float input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_fcc_sptr

        Interpolating FIR filter with float input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_fcc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fcc self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_fcc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fcc self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_fcc_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fcc
    __del__ = lambda self : None;
interp_fir_filter_fcc_swigregister = _filter_swig.interp_fir_filter_fcc_swigregister
interp_fir_filter_fcc_swigregister(interp_fir_filter_fcc)

def interp_fir_filter_fcc_make(*args, **kwargs):
  """
    interp_fir_filter_fcc_make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_fcc_sptr

    Interpolating FIR filter with float input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.interp_fir_filter_fcc_make(*args, **kwargs)

class interp_fir_filter_fff(object):
    """
    Interpolating FIR filter with float input, float output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, float output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fff_sptr

        Interpolating FIR filter with float input, float output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, float output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fff self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fff self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_fff_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fff
    __del__ = lambda self : None;
interp_fir_filter_fff_swigregister = _filter_swig.interp_fir_filter_fff_swigregister
interp_fir_filter_fff_swigregister(interp_fir_filter_fff)

def interp_fir_filter_fff_make(*args, **kwargs):
  """
    interp_fir_filter_fff_make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fff_sptr

    Interpolating FIR filter with float input, float output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, float output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.interp_fir_filter_fff_make(*args, **kwargs)

class interp_fir_filter_fsf(object):
    """
    Interpolating FIR filter with float input, short output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, short output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fsf_sptr

        Interpolating FIR filter with float input, short output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, short output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_fsf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fsf self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_fsf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fsf self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_fsf_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fsf
    __del__ = lambda self : None;
interp_fir_filter_fsf_swigregister = _filter_swig.interp_fir_filter_fsf_swigregister
interp_fir_filter_fsf_swigregister(interp_fir_filter_fsf)

def interp_fir_filter_fsf_make(*args, **kwargs):
  """
    interp_fir_filter_fsf_make(unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fsf_sptr

    Interpolating FIR filter with float input, short output and float taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with float input, short output, and float taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type float
    """
  return _filter_swig.interp_fir_filter_fsf_make(*args, **kwargs)

class interp_fir_filter_scc(object):
    """
    Interpolating FIR filter with short input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with short input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_scc_sptr

        Interpolating FIR filter with short input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with short input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_scc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_scc self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_scc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_scc self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_scc_taps(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_scc
    __del__ = lambda self : None;
interp_fir_filter_scc_swigregister = _filter_swig.interp_fir_filter_scc_swigregister
interp_fir_filter_scc_swigregister(interp_fir_filter_scc)

def interp_fir_filter_scc_make(*args, **kwargs):
  """
    interp_fir_filter_scc_make(unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_scc_sptr

    Interpolating FIR filter with short input, gr_complex output and gr_complex taps.

    The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



    The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

    These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

    Constructor Specific Documentation:

    Interpolating FIR filter with short input, gr_complex output, and gr_complex taps.

    Args:
        interpolation : set the integer interpolation rate
        taps : a vector/list of taps of type gr_complex
    """
  return _filter_swig.interp_fir_filter_scc_make(*args, **kwargs)

class pfb_arb_resampler_ccf(object):
    """
    Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccf to perform arbitrary resampling on the stream.

    Output sampling rate is  * input rate.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccf_sptr

        Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccf to perform arbitrary resampling on the stream.

        Output sampling rate is  * input rate.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_ccf self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_ccf_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_ccf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_ccf_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_ccf self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_ccf_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_ccf self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccf_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_ccf self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccf_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_ccf self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_ccf self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_ccf self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_ccf self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_ccf self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_ccf self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_ccf_phase_offset(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_ccf
    __del__ = lambda self : None;
pfb_arb_resampler_ccf_swigregister = _filter_swig.pfb_arb_resampler_ccf_swigregister
pfb_arb_resampler_ccf_swigregister(pfb_arb_resampler_ccf)

def pfb_arb_resampler_ccf_make(*args, **kwargs):
  """
    pfb_arb_resampler_ccf_make(float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccf_sptr

    Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccf to perform arbitrary resampling on the stream.

    Output sampling rate is  * input rate.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
  return _filter_swig.pfb_arb_resampler_ccf_make(*args, **kwargs)

class pfb_arb_resampler_ccc(object):
    """
    Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and gr_complex taps.

    This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccc to perform arbitrary resampling on the stream.

    Output sampling rate is  * input rate.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of complex) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float rate, pmt_vector_cfloat taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccc_sptr

        Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and gr_complex taps.

        This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccc to perform arbitrary resampling on the stream.

        Output sampling rate is  * input rate.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of complex) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_ccc self, pmt_vector_cfloat taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_ccc self) -> gr_vector_vector_complexf

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_ccc_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_ccc self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_ccc_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_ccc self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_ccc_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_ccc self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccc_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_ccc self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccc_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_ccc self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_ccc self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_ccc self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_ccc self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_ccc self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_ccc self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_ccc_phase_offset(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_ccc
    __del__ = lambda self : None;
pfb_arb_resampler_ccc_swigregister = _filter_swig.pfb_arb_resampler_ccc_swigregister
pfb_arb_resampler_ccc_swigregister(pfb_arb_resampler_ccc)

def pfb_arb_resampler_ccc_make(*args, **kwargs):
  """
    pfb_arb_resampler_ccc_make(float rate, pmt_vector_cfloat taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccc_sptr

    Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and gr_complex taps.

    This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccc to perform arbitrary resampling on the stream.

    Output sampling rate is  * input rate.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of complex) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
  return _filter_swig.pfb_arb_resampler_ccc_make(*args, **kwargs)

class pfb_arb_resampler_fff(object):
    """
    Polyphase filterbank arbitrary resampler with float input, float output and float taps.

    This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

    Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

    To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

    The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

    The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

    For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



    The theory behind this block can be found in Chapter 7.5 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_fff_sptr

        Polyphase filterbank arbitrary resampler with float input, float output and float taps.

        This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

        Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

        To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

        The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

        The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

        For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



        The theory behind this block can be found in Chapter 7.5 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_fff self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_fff self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_fff_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_fff self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_fff_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_fff self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_fff_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_fff self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_fff_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_fff self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_fff_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_fff self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_fff self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_fff self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_fff self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_fff self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_fff self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_fff_phase_offset(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_fff
    __del__ = lambda self : None;
pfb_arb_resampler_fff_swigregister = _filter_swig.pfb_arb_resampler_fff_swigregister
pfb_arb_resampler_fff_swigregister(pfb_arb_resampler_fff)

def pfb_arb_resampler_fff_make(*args, **kwargs):
  """
    pfb_arb_resampler_fff_make(float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_fff_sptr

    Polyphase filterbank arbitrary resampler with float input, float output and float taps.

    This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

    Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

    To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

    The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

    The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

    For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



    The theory behind this block can be found in Chapter 7.5 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank arbitray resampler.

    Args:
        rate : (float) Specifies the resampling rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
        filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
    """
  return _filter_swig.pfb_arb_resampler_fff_make(*args, **kwargs)

class pfb_channelizer_ccf(object):
    """
    Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.

    This block takes in complex inputs and channelizes it to  channels of equal bandwidth. Each of the resulting channels is decimated to the new rate that is the input sampling rate  divided by the number of channels, .

    The PFB channelizer code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    Each filter operates using the gr::blocks::fir_filter_XXX classs of GNU Radio, which takes the input stream at  and performs the inner product calculation to  where  is the number of filter taps. To efficiently handle this in the GNU Radio structure, each filter input must come from its own input stream. So the channelizer must be provided with  streams where the input stream has been deinterleaved. This is most easily done using the gr::blocks::stream_to_streams block.

    The output is then produced as a vector, where index  in the vector is the next sample from the th channel. This is most easily handled by sending the output to a gr::blocks::vector_to_streams block to handle the conversion and passing  streams out.

    The input and output formatting is done using a hier_block2 called pfb_channelizer_ccf. This can take in a single stream and outputs  streams based on the behavior described above.

    The filter's taps should be based on the input sampling rate.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity. 

    The filter output can also be overs ampled. The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.

    For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz. A rate of 6/5 = 1.2, so the output rate would be 1200 Hz.

    The theory behind this block can be found in Chapter 6 of the following book.



    When dealing with oversampling, the above book is still a good reference along with this paper:

    Constructor Specific Documentation:

    Build the polyphase filterbank decimator. 
    For example, for 6 channels with fs = 6000 Hz, the normal rateis 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz.

    Args:
        numchans : (unsigned integer) Specifies the number of channels
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        oversample_rate : (float) The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int numchans, pmt_vector_float taps, float oversample_rate) -> pfb_channelizer_ccf_sptr

        Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.

        This block takes in complex inputs and channelizes it to  channels of equal bandwidth. Each of the resulting channels is decimated to the new rate that is the input sampling rate  divided by the number of channels, .

        The PFB channelizer code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        Each filter operates using the gr::blocks::fir_filter_XXX classs of GNU Radio, which takes the input stream at  and performs the inner product calculation to  where  is the number of filter taps. To efficiently handle this in the GNU Radio structure, each filter input must come from its own input stream. So the channelizer must be provided with  streams where the input stream has been deinterleaved. This is most easily done using the gr::blocks::stream_to_streams block.

        The output is then produced as a vector, where index  in the vector is the next sample from the th channel. This is most easily handled by sending the output to a gr::blocks::vector_to_streams block to handle the conversion and passing  streams out.

        The input and output formatting is done using a hier_block2 called pfb_channelizer_ccf. This can take in a single stream and outputs  streams based on the behavior described above.

        The filter's taps should be based on the input sampling rate.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity. 

        The filter output can also be overs ampled. The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.

        For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz. A rate of 6/5 = 1.2, so the output rate would be 1200 Hz.

        The theory behind this block can be found in Chapter 6 of the following book.



        When dealing with oversampling, the above book is still a good reference along with this paper:

        Constructor Specific Documentation:

        Build the polyphase filterbank decimator. 
        For example, for 6 channels with fs = 6000 Hz, the normal rateis 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz.

        Args:
            numchans : (unsigned integer) Specifies the number of channels
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            oversample_rate : (float) The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.
        """
        return _filter_swig.pfb_channelizer_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_channelizer_ccf self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_channelizer_ccf_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(pfb_channelizer_ccf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_channelizer_ccf_print_taps(self)

    def taps(self):
        """
        taps(pfb_channelizer_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_channelizer_ccf_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(pfb_channelizer_ccf self, std::vector< int,std::allocator< int > > const & map)

        Set the channel map. Channels are numbers as:  <---------------- 0 -----------------> freq

        So output stream 0 comes from channel 0, etc. Setting a new channel map allows the user to specify which channel in frequency he/she wants to got to which output stream.

        The map should have the same number of elements as the number of output connections from the block. The minimum value of the map is 0 (for the 0th channel) and the maximum number is N-1 where N is the number of channels.

        We specify M as the number of output connections made where M <= N, so only M out of N channels are driven to an output stream. The number of items in the channel map should be at least M long. If there are more channels specified, any value in the map over M-1 will be ignored. If the size of the map is less than M the behavior is unknown (we don't wish to check every entry into the work function).

        This means that if the channelizer is splitting the signal up into N channels but only M channels are specified in the map (where M <= N), then M output streams must be connected and the map and the channel numbers used must be less than N-1. Output channel number can be reused, too. By default, the map is [0...M-1] with M = N.
        """
        return _filter_swig.pfb_channelizer_ccf_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(pfb_channelizer_ccf self) -> std::vector< int,std::allocator< int > >

        Gets the current channel map.
        """
        return _filter_swig.pfb_channelizer_ccf_channel_map(self)

    __swig_destroy__ = _filter_swig.delete_pfb_channelizer_ccf
    __del__ = lambda self : None;
pfb_channelizer_ccf_swigregister = _filter_swig.pfb_channelizer_ccf_swigregister
pfb_channelizer_ccf_swigregister(pfb_channelizer_ccf)

def pfb_channelizer_ccf_make(*args, **kwargs):
  """
    pfb_channelizer_ccf_make(unsigned int numchans, pmt_vector_float taps, float oversample_rate) -> pfb_channelizer_ccf_sptr

    Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.

    This block takes in complex inputs and channelizes it to  channels of equal bandwidth. Each of the resulting channels is decimated to the new rate that is the input sampling rate  divided by the number of channels, .

    The PFB channelizer code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    Each filter operates using the gr::blocks::fir_filter_XXX classs of GNU Radio, which takes the input stream at  and performs the inner product calculation to  where  is the number of filter taps. To efficiently handle this in the GNU Radio structure, each filter input must come from its own input stream. So the channelizer must be provided with  streams where the input stream has been deinterleaved. This is most easily done using the gr::blocks::stream_to_streams block.

    The output is then produced as a vector, where index  in the vector is the next sample from the th channel. This is most easily handled by sending the output to a gr::blocks::vector_to_streams block to handle the conversion and passing  streams out.

    The input and output formatting is done using a hier_block2 called pfb_channelizer_ccf. This can take in a single stream and outputs  streams based on the behavior described above.

    The filter's taps should be based on the input sampling rate.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity. 

    The filter output can also be overs ampled. The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.

    For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz. A rate of 6/5 = 1.2, so the output rate would be 1200 Hz.

    The theory behind this block can be found in Chapter 6 of the following book.



    When dealing with oversampling, the above book is still a good reference along with this paper:

    Constructor Specific Documentation:

    Build the polyphase filterbank decimator. 
    For example, for 6 channels with fs = 6000 Hz, the normal rateis 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz.

    Args:
        numchans : (unsigned integer) Specifies the number of channels
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        oversample_rate : (float) The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.
    """
  return _filter_swig.pfb_channelizer_ccf_make(*args, **kwargs)

class pfb_decimator_ccf(object):
    """
    Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger down- sampling (decimation) with a polyphase filterbank. The first input is the integer specifying how much to decimate by. The second input is a vector (Python list) of floating-point taps of the prototype filter. The third input specifies the channel to extract. By default, the zeroth channel is used, which is the baseband channel (first Nyquist zone).

    The  parameter specifies which channel to use since this class is capable of bandpass decimation. Given a complex input stream at a sampling rate of  and a decimation rate of , the input frequency domain is split into  channels that represent the Nyquist zones. Using the polyphase filterbank, we can select any one of these channels to decimate.

    The output signal will be the basebanded and decimated signal from that channel. This concept is very similar to the PFB channelizer (see gr::filter::pfb_channelizer_ccf) where only a single channel is extracted at a time.

    The filter's taps should be based on the sampling rate before decimation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



    The PFB decimator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 6 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank decimator.

    Args:
        decim : (unsigned integer) Specifies the decimation rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        channel : (unsigned integer) Selects the channel to return [default=0].
        use_fft_rotator : (bool) Rotate channels using FFT method instead of exp(phi). For larger values of , the FFT method will perform better. Generally, this value of  is small (~5), but could be architecture-specific (Default: true).
        use_fft_filters : (bool) Use FFT filters (fast convolution) instead of FIR filters. FFT filters perform better for larger numbers of taps but is architecture-specific (Default: true).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int decim, pmt_vector_float taps, unsigned int channel, bool use_fft_rotator=True, 
            bool use_fft_filters=True) -> pfb_decimator_ccf_sptr

        Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and performs interger down- sampling (decimation) with a polyphase filterbank. The first input is the integer specifying how much to decimate by. The second input is a vector (Python list) of floating-point taps of the prototype filter. The third input specifies the channel to extract. By default, the zeroth channel is used, which is the baseband channel (first Nyquist zone).

        The  parameter specifies which channel to use since this class is capable of bandpass decimation. Given a complex input stream at a sampling rate of  and a decimation rate of , the input frequency domain is split into  channels that represent the Nyquist zones. Using the polyphase filterbank, we can select any one of these channels to decimate.

        The output signal will be the basebanded and decimated signal from that channel. This concept is very similar to the PFB channelizer (see gr::filter::pfb_channelizer_ccf) where only a single channel is extracted at a time.

        The filter's taps should be based on the sampling rate before decimation.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



        The PFB decimator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        The theory behind this block can be found in Chapter 6 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank decimator.

        Args:
            decim : (unsigned integer) Specifies the decimation rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            channel : (unsigned integer) Selects the channel to return [default=0].
            use_fft_rotator : (bool) Rotate channels using FFT method instead of exp(phi). For larger values of , the FFT method will perform better. Generally, this value of  is small (~5), but could be architecture-specific (Default: true).
            use_fft_filters : (bool) Use FFT filters (fast convolution) instead of FIR filters. FFT filters perform better for larger numbers of taps but is architecture-specific (Default: true).
        """
        return _filter_swig.pfb_decimator_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_decimator_ccf self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_decimator_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_decimator_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_decimator_ccf_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_decimator_ccf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_decimator_ccf_print_taps(self)

    def set_channel(self, *args, **kwargs):
        """set_channel(pfb_decimator_ccf self, unsigned int const channel)"""
        return _filter_swig.pfb_decimator_ccf_set_channel(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_pfb_decimator_ccf
    __del__ = lambda self : None;
pfb_decimator_ccf_swigregister = _filter_swig.pfb_decimator_ccf_swigregister
pfb_decimator_ccf_swigregister(pfb_decimator_ccf)

def pfb_decimator_ccf_make(*args, **kwargs):
  """
    pfb_decimator_ccf_make(unsigned int decim, pmt_vector_float taps, unsigned int channel, bool use_fft_rotator=True, 
        bool use_fft_filters=True) -> pfb_decimator_ccf_sptr

    Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger down- sampling (decimation) with a polyphase filterbank. The first input is the integer specifying how much to decimate by. The second input is a vector (Python list) of floating-point taps of the prototype filter. The third input specifies the channel to extract. By default, the zeroth channel is used, which is the baseband channel (first Nyquist zone).

    The  parameter specifies which channel to use since this class is capable of bandpass decimation. Given a complex input stream at a sampling rate of  and a decimation rate of , the input frequency domain is split into  channels that represent the Nyquist zones. Using the polyphase filterbank, we can select any one of these channels to decimate.

    The output signal will be the basebanded and decimated signal from that channel. This concept is very similar to the PFB channelizer (see gr::filter::pfb_channelizer_ccf) where only a single channel is extracted at a time.

    The filter's taps should be based on the sampling rate before decimation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



    The PFB decimator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 6 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank decimator.

    Args:
        decim : (unsigned integer) Specifies the decimation rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        channel : (unsigned integer) Selects the channel to return [default=0].
        use_fft_rotator : (bool) Rotate channels using FFT method instead of exp(phi). For larger values of , the FFT method will perform better. Generally, this value of  is small (~5), but could be architecture-specific (Default: true).
        use_fft_filters : (bool) Use FFT filters (fast convolution) instead of FIR filters. FFT filters perform better for larger numbers of taps but is architecture-specific (Default: true).
    """
  return _filter_swig.pfb_decimator_ccf_make(*args, **kwargs)

class pfb_interpolator_ccf(object):
    """
    Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger up- sampling (interpolation) with a polyphase filterbank. The first input is the integer specifying how much to interpolate by. The second input is a vector (Python list) of floating-point taps of the prototype filter.

    The filter's taps should be based on the interpolation rate specified. That is, the bandwidth specified is relative to the bandwidth after interpolation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, ATT, and the filter window function (a Blackman-harris window in this case). The first input is the gain, which is also specified as the interpolation rate so that the output levels are the same as the input (this creates an overall increase in power).



    The PFB interpolator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/interp) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 7.1 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank interpolator.

    Args:
        interp : (unsigned integer) Specifies the interpolation rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the interpolated sampling rate.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interp, pmt_vector_float taps) -> pfb_interpolator_ccf_sptr

        Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and performs interger up- sampling (interpolation) with a polyphase filterbank. The first input is the integer specifying how much to interpolate by. The second input is a vector (Python list) of floating-point taps of the prototype filter.

        The filter's taps should be based on the interpolation rate specified. That is, the bandwidth specified is relative to the bandwidth after interpolation.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, ATT, and the filter window function (a Blackman-harris window in this case). The first input is the gain, which is also specified as the interpolation rate so that the output levels are the same as the input (this creates an overall increase in power).



        The PFB interpolator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/interp) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        The theory behind this block can be found in Chapter 7.1 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank interpolator.

        Args:
            interp : (unsigned integer) Specifies the interpolation rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the interpolated sampling rate.
        """
        return _filter_swig.pfb_interpolator_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_interpolator_ccf self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_interpolator_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_interpolator_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_interpolator_ccf_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_interpolator_ccf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_interpolator_ccf_print_taps(self)

    __swig_destroy__ = _filter_swig.delete_pfb_interpolator_ccf
    __del__ = lambda self : None;
pfb_interpolator_ccf_swigregister = _filter_swig.pfb_interpolator_ccf_swigregister
pfb_interpolator_ccf_swigregister(pfb_interpolator_ccf)

def pfb_interpolator_ccf_make(*args, **kwargs):
  """
    pfb_interpolator_ccf_make(unsigned int interp, pmt_vector_float taps) -> pfb_interpolator_ccf_sptr

    Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.

    This block takes in a signal stream and performs interger up- sampling (interpolation) with a polyphase filterbank. The first input is the integer specifying how much to interpolate by. The second input is a vector (Python list) of floating-point taps of the prototype filter.

    The filter's taps should be based on the interpolation rate specified. That is, the bandwidth specified is relative to the bandwidth after interpolation.

    For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, ATT, and the filter window function (a Blackman-harris window in this case). The first input is the gain, which is also specified as the interpolation rate so that the output levels are the same as the input (this creates an overall increase in power).



    The PFB interpolator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/interp) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

    The theory behind this block can be found in Chapter 7.1 of the following book.

    Constructor Specific Documentation:

    Build the polyphase filterbank interpolator.

    Args:
        interp : (unsigned integer) Specifies the interpolation rate to use
        taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the interpolated sampling rate.
    """
  return _filter_swig.pfb_interpolator_ccf_make(*args, **kwargs)

class pfb_synthesizer_ccf(object):
    """
    Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.

    The PFB sythesis filterbank combines multiple baseband signals into a single channelized signal. Each input stream is, essentially, modulated onto an output channel according the the channel mapping (see set_channel_map for details).

    Setting this filterbank up means selecting the number of output channels, the prototype filter, and whether to handle channels at 2x the sample rate (this is generally used only for reconstruction filtering).

    The number of channels sets the maximum number of channels to use, but not all input streams must be connected. For M total channels, we can connect inputs 0 to N where N < M-1. Because of the way GNU Radio handles stream connections, we must connect the channels consecutively, and so we must use the set_channel_map if the desired output channels are not the same as the the default mapping. This features gives us the flexibility to output to any given channel. Generally, we try to not use the channels at the edge of the spectrum to avoid issues with filtering and roll-off of the transmitter or receiver.

    When using the 2x sample rate mode, we specify the number of channels that will be used. However, the actual output signal will be twice this number of channels. This is mainly important to know when setting the channel map. For M channels, the channel mapping can specy from 0 to 2M-1 channels to output onto.

    For more details about this and the concepts of reconstruction filtering, see:

    Constructor Specific Documentation:

    Build the polyphase synthesis filterbank.

    Args:
        numchans : (unsigned integer) Specifies the number of channels
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        twox : (bool) use 2x oversampling or not (default is no)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int numchans, pmt_vector_float taps, bool twox=False) -> pfb_synthesizer_ccf_sptr

        Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.

        The PFB sythesis filterbank combines multiple baseband signals into a single channelized signal. Each input stream is, essentially, modulated onto an output channel according the the channel mapping (see set_channel_map for details).

        Setting this filterbank up means selecting the number of output channels, the prototype filter, and whether to handle channels at 2x the sample rate (this is generally used only for reconstruction filtering).

        The number of channels sets the maximum number of channels to use, but not all input streams must be connected. For M total channels, we can connect inputs 0 to N where N < M-1. Because of the way GNU Radio handles stream connections, we must connect the channels consecutively, and so we must use the set_channel_map if the desired output channels are not the same as the the default mapping. This features gives us the flexibility to output to any given channel. Generally, we try to not use the channels at the edge of the spectrum to avoid issues with filtering and roll-off of the transmitter or receiver.

        When using the 2x sample rate mode, we specify the number of channels that will be used. However, the actual output signal will be twice this number of channels. This is mainly important to know when setting the channel map. For M channels, the channel mapping can specy from 0 to 2M-1 channels to output onto.

        For more details about this and the concepts of reconstruction filtering, see:

        Constructor Specific Documentation:

        Build the polyphase synthesis filterbank.

        Args:
            numchans : (unsigned integer) Specifies the number of channels
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            twox : (bool) use 2x oversampling or not (default is no)
        """
        return _filter_swig.pfb_synthesizer_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_synthesizer_ccf self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_synthesizer_ccf_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(pfb_synthesizer_ccf self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_synthesizer_ccf_print_taps(self)

    def taps(self):
        """
        taps(pfb_synthesizer_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_synthesizer_ccf_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(pfb_synthesizer_ccf self, std::vector< int,std::allocator< int > > const & map)

        Set the channel map. Channels are numbers as: N/2+1 | ... | N-1 | 0 | 1 | 2 | ... | N/2 <---------------- 0 -----------------> freq

        So input stream 0 goes to channel 0, etc. Setting a new channel map allows the user to specify where in frequency he/she wants the input stream to go. This is especially useful to avoid putting signals into the channels on the edge of the spectrum which can either wrap around (in the case of odd number of channels) and be affected by filter rolloff in the transmitter.

        The map must be at least the number of streams being sent to the block. Less and the algorithm will not have enough data to properly setup the buffers. Any more channels specified will be ignored.
        """
        return _filter_swig.pfb_synthesizer_ccf_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(pfb_synthesizer_ccf self) -> std::vector< int,std::allocator< int > >

        Gets the current channel map.
        """
        return _filter_swig.pfb_synthesizer_ccf_channel_map(self)

    __swig_destroy__ = _filter_swig.delete_pfb_synthesizer_ccf
    __del__ = lambda self : None;
pfb_synthesizer_ccf_swigregister = _filter_swig.pfb_synthesizer_ccf_swigregister
pfb_synthesizer_ccf_swigregister(pfb_synthesizer_ccf)

def pfb_synthesizer_ccf_make(*args, **kwargs):
  """
    pfb_synthesizer_ccf_make(unsigned int numchans, pmt_vector_float taps, bool twox=False) -> pfb_synthesizer_ccf_sptr

    Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.

    The PFB sythesis filterbank combines multiple baseband signals into a single channelized signal. Each input stream is, essentially, modulated onto an output channel according the the channel mapping (see set_channel_map for details).

    Setting this filterbank up means selecting the number of output channels, the prototype filter, and whether to handle channels at 2x the sample rate (this is generally used only for reconstruction filtering).

    The number of channels sets the maximum number of channels to use, but not all input streams must be connected. For M total channels, we can connect inputs 0 to N where N < M-1. Because of the way GNU Radio handles stream connections, we must connect the channels consecutively, and so we must use the set_channel_map if the desired output channels are not the same as the the default mapping. This features gives us the flexibility to output to any given channel. Generally, we try to not use the channels at the edge of the spectrum to avoid issues with filtering and roll-off of the transmitter or receiver.

    When using the 2x sample rate mode, we specify the number of channels that will be used. However, the actual output signal will be twice this number of channels. This is mainly important to know when setting the channel map. For M channels, the channel mapping can specy from 0 to 2M-1 channels to output onto.

    For more details about this and the concepts of reconstruction filtering, see:

    Constructor Specific Documentation:

    Build the polyphase synthesis filterbank.

    Args:
        numchans : (unsigned integer) Specifies the number of channels
        taps : (vector/list of floats) The prototype filter to populate the filterbank.
        twox : (bool) use 2x oversampling or not (default is no)
    """
  return _filter_swig.pfb_synthesizer_ccf_make(*args, **kwargs)

class rational_resampler_base_ccc(object):
    """
    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_ccc_sptr

        Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_ccc_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_ccc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_ccc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_ccc self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_ccc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_ccc self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_ccc_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_ccc
    __del__ = lambda self : None;
rational_resampler_base_ccc_swigregister = _filter_swig.rational_resampler_base_ccc_swigregister
rational_resampler_base_ccc_swigregister(rational_resampler_base_ccc)

def rational_resampler_base_ccc_make(*args, **kwargs):
  """
    rational_resampler_base_ccc_make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_ccc_sptr

    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_ccc_make(*args, **kwargs)

class rational_resampler_base_ccf(object):
    """
    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_ccf_sptr

        Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_ccf self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_ccf self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_ccf self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_ccf self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_ccf_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_ccf
    __del__ = lambda self : None;
rational_resampler_base_ccf_swigregister = _filter_swig.rational_resampler_base_ccf_swigregister
rational_resampler_base_ccf_swigregister(rational_resampler_base_ccf)

def rational_resampler_base_ccf_make(*args, **kwargs):
  """
    rational_resampler_base_ccf_make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_ccf_sptr

    Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_ccf_make(*args, **kwargs)

class rational_resampler_base_fcc(object):
    """
    Rational Resampling Polyphase FIR filter with float input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_fcc_sptr

        Rational Resampling Polyphase FIR filter with float input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fcc_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_fcc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fcc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fcc self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_fcc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fcc self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_fcc_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fcc
    __del__ = lambda self : None;
rational_resampler_base_fcc_swigregister = _filter_swig.rational_resampler_base_fcc_swigregister
rational_resampler_base_fcc_swigregister(rational_resampler_base_fcc)

def rational_resampler_base_fcc_make(*args, **kwargs):
  """
    rational_resampler_base_fcc_make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_fcc_sptr

    Rational Resampling Polyphase FIR filter with float input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_fcc_make(*args, **kwargs)

class rational_resampler_base_fff(object):
    """
    Rational Resampling Polyphase FIR filter with float input, float output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fff_sptr

        Rational Resampling Polyphase FIR filter with float input, float output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_fff self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fff self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fff self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fff self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_fff_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fff
    __del__ = lambda self : None;
rational_resampler_base_fff_swigregister = _filter_swig.rational_resampler_base_fff_swigregister
rational_resampler_base_fff_swigregister(rational_resampler_base_fff)

def rational_resampler_base_fff_make(*args, **kwargs):
  """
    rational_resampler_base_fff_make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fff_sptr

    Rational Resampling Polyphase FIR filter with float input, float output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_fff_make(*args, **kwargs)

class rational_resampler_base_fsf(object):
    """
    Rational Resampling Polyphase FIR filter with float input, short output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fsf_sptr

        Rational Resampling Polyphase FIR filter with float input, short output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fsf_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_fsf self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fsf self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fsf self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_fsf_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fsf self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_fsf_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fsf
    __del__ = lambda self : None;
rational_resampler_base_fsf_swigregister = _filter_swig.rational_resampler_base_fsf_swigregister
rational_resampler_base_fsf_swigregister(rational_resampler_base_fsf)

def rational_resampler_base_fsf_make(*args, **kwargs):
  """
    rational_resampler_base_fsf_make(unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fsf_sptr

    Rational Resampling Polyphase FIR filter with float input, short output and float taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_fsf_make(*args, **kwargs)

class rational_resampler_base_scc(object):
    """
    Rational Resampling Polyphase FIR filter with short input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_scc_sptr

        Rational Resampling Polyphase FIR filter with short input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_scc_make(*args, **kwargs)

    make = staticmethod(make)
    def interpolation(self):
        """interpolation(rational_resampler_base_scc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_scc self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_scc self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_scc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_scc self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_scc_taps(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_scc
    __del__ = lambda self : None;
rational_resampler_base_scc_swigregister = _filter_swig.rational_resampler_base_scc_swigregister
rational_resampler_base_scc_swigregister(rational_resampler_base_scc)

def rational_resampler_base_scc_make(*args, **kwargs):
  """
    rational_resampler_base_scc_make(unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_scc_sptr

    Rational Resampling Polyphase FIR filter with short input, gr_complex output and gr_complex taps.

    Constructor Specific Documentation:



    Args:
        interpolation : 
        decimation : 
        taps : 
    """
  return _filter_swig.rational_resampler_base_scc_make(*args, **kwargs)

class single_pole_iir_filter_cc(object):
    """
    single pole IIR filter with complex input, complex output

    The input and output satisfy a difference equation of the form 

     
    y[n] - (1-alpha) y[n-1] = alpha x[n]


    with the corresponding rational system function 

     
    H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

    Constructor Specific Documentation:



    Args:
        alpha : 
        vlen : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double alpha, unsigned int vlen=1) -> single_pole_iir_filter_cc_sptr

        single pole IIR filter with complex input, complex output

        The input and output satisfy a difference equation of the form 

         
        y[n] - (1-alpha) y[n-1] = alpha x[n]


        with the corresponding rational system function 

         
        H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


        Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

        Constructor Specific Documentation:



        Args:
            alpha : 
            vlen : 
        """
        return _filter_swig.single_pole_iir_filter_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(single_pole_iir_filter_cc self, double alpha)"""
        return _filter_swig.single_pole_iir_filter_cc_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_single_pole_iir_filter_cc
    __del__ = lambda self : None;
single_pole_iir_filter_cc_swigregister = _filter_swig.single_pole_iir_filter_cc_swigregister
single_pole_iir_filter_cc_swigregister(single_pole_iir_filter_cc)

def single_pole_iir_filter_cc_make(*args, **kwargs):
  """
    single_pole_iir_filter_cc_make(double alpha, unsigned int vlen=1) -> single_pole_iir_filter_cc_sptr

    single pole IIR filter with complex input, complex output

    The input and output satisfy a difference equation of the form 

     
    y[n] - (1-alpha) y[n-1] = alpha x[n]


    with the corresponding rational system function 

     
    H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

    Constructor Specific Documentation:



    Args:
        alpha : 
        vlen : 
    """
  return _filter_swig.single_pole_iir_filter_cc_make(*args, **kwargs)

class single_pole_iir_filter_ff(object):
    """
    single pole IIR filter with float input, float output

    The input and output satisfy a difference equation of the form 

     
    y[n] - (1-alpha) y[n-1] = alpha x[n]


    with the corresponding rational system function 

     
    H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

    Constructor Specific Documentation:



    Args:
        alpha : 
        vlen : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double alpha, unsigned int vlen=1) -> single_pole_iir_filter_ff_sptr

        single pole IIR filter with float input, float output

        The input and output satisfy a difference equation of the form 

         
        y[n] - (1-alpha) y[n-1] = alpha x[n]


        with the corresponding rational system function 

         
        H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


        Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

        Constructor Specific Documentation:



        Args:
            alpha : 
            vlen : 
        """
        return _filter_swig.single_pole_iir_filter_ff_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(single_pole_iir_filter_ff self, double alpha)"""
        return _filter_swig.single_pole_iir_filter_ff_set_taps(self, *args, **kwargs)

    __swig_destroy__ = _filter_swig.delete_single_pole_iir_filter_ff
    __del__ = lambda self : None;
single_pole_iir_filter_ff_swigregister = _filter_swig.single_pole_iir_filter_ff_swigregister
single_pole_iir_filter_ff_swigregister(single_pole_iir_filter_ff)

def single_pole_iir_filter_ff_make(*args, **kwargs):
  """
    single_pole_iir_filter_ff_make(double alpha, unsigned int vlen=1) -> single_pole_iir_filter_ff_sptr

    single pole IIR filter with float input, float output

    The input and output satisfy a difference equation of the form 

     
    y[n] - (1-alpha) y[n-1] = alpha x[n]


    with the corresponding rational system function 

     
    H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


    Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

    Constructor Specific Documentation:



    Args:
        alpha : 
        vlen : 
    """
  return _filter_swig.single_pole_iir_filter_ff_make(*args, **kwargs)

class dc_blocker_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::dc_blocker_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::dc_blocker_cc)> self) -> dc_blocker_cc_sptr
        __init__(boost::shared_ptr<(gr::filter::dc_blocker_cc)> self, dc_blocker_cc p) -> dc_blocker_cc_sptr
        """
        this = _filter_swig.new_dc_blocker_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(dc_blocker_cc_sptr self) -> dc_blocker_cc"""
        return _filter_swig.dc_blocker_cc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_dc_blocker_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(dc_blocker_cc_sptr self, int D, bool long_form) -> dc_blocker_cc_sptr

        a computationally efficient controllable DC blocker

        This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

        The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

        The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

        The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

        The theory behind this block can be found in the paper:

        Constructor Specific Documentation:

        Make a DC blocker block.

        Args:
            D : (int) the length of the delay line
            long_form : (bool) whether to use long (true, default) or short form
        """
        return _filter_swig.dc_blocker_cc_sptr_make(self, *args, **kwargs)

    def group_delay(self):
        """group_delay(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_group_delay(self)

    def history(self):
        """history(dc_blocker_cc_sptr self) -> unsigned int"""
        return _filter_swig.dc_blocker_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(dc_blocker_cc_sptr self, int which, int delay)
        declare_sample_delay(dc_blocker_cc_sptr self, unsigned int delay)
        """
        return _filter_swig.dc_blocker_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(dc_blocker_cc_sptr self, int which) -> unsigned int"""
        return _filter_swig.dc_blocker_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(dc_blocker_cc_sptr self) -> double"""
        return _filter_swig.dc_blocker_cc_sptr_relative_rate(self)

    def start(self):
        """start(dc_blocker_cc_sptr self) -> bool"""
        return _filter_swig.dc_blocker_cc_sptr_start(self)

    def stop(self):
        """stop(dc_blocker_cc_sptr self) -> bool"""
        return _filter_swig.dc_blocker_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(dc_blocker_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.dc_blocker_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(dc_blocker_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.dc_blocker_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(dc_blocker_cc_sptr self, int m)"""
        return _filter_swig.dc_blocker_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(dc_blocker_cc_sptr self)"""
        return _filter_swig.dc_blocker_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(dc_blocker_cc_sptr self) -> bool"""
        return _filter_swig.dc_blocker_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(dc_blocker_cc_sptr self, int m)"""
        return _filter_swig.dc_blocker_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(dc_blocker_cc_sptr self, int i) -> long"""
        return _filter_swig.dc_blocker_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(dc_blocker_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(dc_blocker_cc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.dc_blocker_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(dc_blocker_cc_sptr self, int i) -> long"""
        return _filter_swig.dc_blocker_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(dc_blocker_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(dc_blocker_cc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.dc_blocker_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(dc_blocker_cc_sptr self, int which) -> float
        pc_input_buffers_full(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(dc_blocker_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(dc_blocker_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(dc_blocker_cc_sptr self, int which) -> float
        pc_output_buffers_full(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(dc_blocker_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(dc_blocker_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(dc_blocker_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(dc_blocker_cc_sptr self) -> float"""
        return _filter_swig.dc_blocker_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(dc_blocker_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.dc_blocker_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(dc_blocker_cc_sptr self)"""
        return _filter_swig.dc_blocker_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(dc_blocker_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.dc_blocker_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(dc_blocker_cc_sptr self) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(dc_blocker_cc_sptr self, int priority) -> int"""
        return _filter_swig.dc_blocker_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(dc_blocker_cc_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(dc_blocker_cc_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(dc_blocker_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.dc_blocker_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(dc_blocker_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.dc_blocker_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(dc_blocker_cc_sptr self) -> long"""
        return _filter_swig.dc_blocker_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(dc_blocker_cc_sptr self) -> basic_block_sptr"""
        return _filter_swig.dc_blocker_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(dc_blocker_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.dc_blocker_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(dc_blocker_cc_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(dc_blocker_cc_sptr self, std::string name)"""
        return _filter_swig.dc_blocker_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(dc_blocker_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.dc_blocker_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(dc_blocker_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(dc_blocker_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(dc_blocker_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_cc_sptr_message_subscribers(self, *args, **kwargs)

dc_blocker_cc_sptr_swigregister = _filter_swig.dc_blocker_cc_sptr_swigregister
dc_blocker_cc_sptr_swigregister(dc_blocker_cc_sptr)

dc_blocker_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
dc_blocker_cc = dc_blocker_cc.make;

class dc_blocker_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::dc_blocker_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::dc_blocker_ff)> self) -> dc_blocker_ff_sptr
        __init__(boost::shared_ptr<(gr::filter::dc_blocker_ff)> self, dc_blocker_ff p) -> dc_blocker_ff_sptr
        """
        this = _filter_swig.new_dc_blocker_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(dc_blocker_ff_sptr self) -> dc_blocker_ff"""
        return _filter_swig.dc_blocker_ff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_dc_blocker_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(dc_blocker_ff_sptr self, int D, bool long_form=True) -> dc_blocker_ff_sptr

        a computationally efficient controllable DC blocker

        This block implements a computationally efficient DC blocker that produces a tighter notch filter around DC for a smaller group delay than an equivalent FIR filter or using a single pole IIR filter (though the IIR filter is computationally cheaper).

        The block defaults to using a delay line of length 32 and the long form of the filter. Optionally, the delay line length can be changed to alter the width of the DC notch (longer lines will decrease the width).

        The long form of the filter produces a nearly flat response outside of the notch but at the cost of a group delay of 2D-2.

        The short form of the filter does not have as flat a response in the passband but has a group delay of only D-1 and is cheaper to compute.

        The theory behind this block can be found in the paper:

        Constructor Specific Documentation:

        Make a DC blocker block.

        Args:
            D : (int) the length of the delay line
            long_form : (bool) whether to use long (true, default) or short form
        """
        return _filter_swig.dc_blocker_ff_sptr_make(self, *args, **kwargs)

    def group_delay(self):
        """group_delay(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_group_delay(self)

    def history(self):
        """history(dc_blocker_ff_sptr self) -> unsigned int"""
        return _filter_swig.dc_blocker_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(dc_blocker_ff_sptr self, int which, int delay)
        declare_sample_delay(dc_blocker_ff_sptr self, unsigned int delay)
        """
        return _filter_swig.dc_blocker_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(dc_blocker_ff_sptr self, int which) -> unsigned int"""
        return _filter_swig.dc_blocker_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(dc_blocker_ff_sptr self) -> double"""
        return _filter_swig.dc_blocker_ff_sptr_relative_rate(self)

    def start(self):
        """start(dc_blocker_ff_sptr self) -> bool"""
        return _filter_swig.dc_blocker_ff_sptr_start(self)

    def stop(self):
        """stop(dc_blocker_ff_sptr self) -> bool"""
        return _filter_swig.dc_blocker_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(dc_blocker_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.dc_blocker_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(dc_blocker_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.dc_blocker_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(dc_blocker_ff_sptr self, int m)"""
        return _filter_swig.dc_blocker_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(dc_blocker_ff_sptr self)"""
        return _filter_swig.dc_blocker_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(dc_blocker_ff_sptr self) -> bool"""
        return _filter_swig.dc_blocker_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(dc_blocker_ff_sptr self, int m)"""
        return _filter_swig.dc_blocker_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(dc_blocker_ff_sptr self, int i) -> long"""
        return _filter_swig.dc_blocker_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(dc_blocker_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(dc_blocker_ff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.dc_blocker_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(dc_blocker_ff_sptr self, int i) -> long"""
        return _filter_swig.dc_blocker_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(dc_blocker_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(dc_blocker_ff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.dc_blocker_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(dc_blocker_ff_sptr self, int which) -> float
        pc_input_buffers_full(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(dc_blocker_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(dc_blocker_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(dc_blocker_ff_sptr self, int which) -> float
        pc_output_buffers_full(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(dc_blocker_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(dc_blocker_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(dc_blocker_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.dc_blocker_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(dc_blocker_ff_sptr self) -> float"""
        return _filter_swig.dc_blocker_ff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(dc_blocker_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.dc_blocker_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(dc_blocker_ff_sptr self)"""
        return _filter_swig.dc_blocker_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(dc_blocker_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.dc_blocker_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(dc_blocker_ff_sptr self) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(dc_blocker_ff_sptr self, int priority) -> int"""
        return _filter_swig.dc_blocker_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(dc_blocker_ff_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(dc_blocker_ff_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(dc_blocker_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.dc_blocker_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(dc_blocker_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.dc_blocker_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(dc_blocker_ff_sptr self) -> long"""
        return _filter_swig.dc_blocker_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(dc_blocker_ff_sptr self) -> basic_block_sptr"""
        return _filter_swig.dc_blocker_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(dc_blocker_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.dc_blocker_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(dc_blocker_ff_sptr self) -> std::string"""
        return _filter_swig.dc_blocker_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(dc_blocker_ff_sptr self, std::string name)"""
        return _filter_swig.dc_blocker_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(dc_blocker_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.dc_blocker_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(dc_blocker_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(dc_blocker_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(dc_blocker_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.dc_blocker_ff_sptr_message_subscribers(self, *args, **kwargs)

dc_blocker_ff_sptr_swigregister = _filter_swig.dc_blocker_ff_sptr_swigregister
dc_blocker_ff_sptr_swigregister(dc_blocker_ff_sptr)

dc_blocker_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
dc_blocker_ff = dc_blocker_ff.make;

class filter_delay_fc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::filter_delay_fc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::filter_delay_fc)> self) -> filter_delay_fc_sptr
        __init__(boost::shared_ptr<(gr::filter::filter_delay_fc)> self, filter_delay_fc p) -> filter_delay_fc_sptr
        """
        this = _filter_swig.new_filter_delay_fc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(filter_delay_fc_sptr self) -> filter_delay_fc"""
        return _filter_swig.filter_delay_fc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_filter_delay_fc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(filter_delay_fc_sptr self, pmt_vector_float taps) -> filter_delay_fc_sptr

        Filter-Delay Combination Block.

        The block takes one or two float stream and outputs a complex stream.

        If only one float stream is input, the real output is a delayed version of this input and the imaginary output is the filtered output.

        If two floats are connected to the input, then the real output is the delayed version of the first input, and the imaginary output is the filtered output.

        The delay in the real path accounts for the group delay introduced by the filter in the imaginary path. The filter taps needs to be calculated before initializing this block.

        Constructor Specific Documentation:

        Build a filter with delay block.

        Args:
            taps : 
        """
        return _filter_swig.filter_delay_fc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(filter_delay_fc_sptr self) -> unsigned int"""
        return _filter_swig.filter_delay_fc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(filter_delay_fc_sptr self, int which, int delay)
        declare_sample_delay(filter_delay_fc_sptr self, unsigned int delay)
        """
        return _filter_swig.filter_delay_fc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(filter_delay_fc_sptr self, int which) -> unsigned int"""
        return _filter_swig.filter_delay_fc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(filter_delay_fc_sptr self) -> int"""
        return _filter_swig.filter_delay_fc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(filter_delay_fc_sptr self) -> double"""
        return _filter_swig.filter_delay_fc_sptr_relative_rate(self)

    def start(self):
        """start(filter_delay_fc_sptr self) -> bool"""
        return _filter_swig.filter_delay_fc_sptr_start(self)

    def stop(self):
        """stop(filter_delay_fc_sptr self) -> bool"""
        return _filter_swig.filter_delay_fc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(filter_delay_fc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.filter_delay_fc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(filter_delay_fc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.filter_delay_fc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(filter_delay_fc_sptr self) -> int"""
        return _filter_swig.filter_delay_fc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(filter_delay_fc_sptr self, int m)"""
        return _filter_swig.filter_delay_fc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(filter_delay_fc_sptr self)"""
        return _filter_swig.filter_delay_fc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(filter_delay_fc_sptr self) -> bool"""
        return _filter_swig.filter_delay_fc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(filter_delay_fc_sptr self, int m)"""
        return _filter_swig.filter_delay_fc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(filter_delay_fc_sptr self) -> int"""
        return _filter_swig.filter_delay_fc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(filter_delay_fc_sptr self, int i) -> long"""
        return _filter_swig.filter_delay_fc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(filter_delay_fc_sptr self, long max_output_buffer)
        set_max_output_buffer(filter_delay_fc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.filter_delay_fc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(filter_delay_fc_sptr self, int i) -> long"""
        return _filter_swig.filter_delay_fc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(filter_delay_fc_sptr self, long min_output_buffer)
        set_min_output_buffer(filter_delay_fc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.filter_delay_fc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(filter_delay_fc_sptr self, int which) -> float
        pc_input_buffers_full(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(filter_delay_fc_sptr self, int which) -> float
        pc_input_buffers_full_avg(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(filter_delay_fc_sptr self, int which) -> float
        pc_input_buffers_full_var(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(filter_delay_fc_sptr self, int which) -> float
        pc_output_buffers_full(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(filter_delay_fc_sptr self, int which) -> float
        pc_output_buffers_full_avg(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(filter_delay_fc_sptr self, int which) -> float
        pc_output_buffers_full_var(filter_delay_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filter_delay_fc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(filter_delay_fc_sptr self) -> float"""
        return _filter_swig.filter_delay_fc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(filter_delay_fc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.filter_delay_fc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(filter_delay_fc_sptr self)"""
        return _filter_swig.filter_delay_fc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(filter_delay_fc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.filter_delay_fc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(filter_delay_fc_sptr self) -> int"""
        return _filter_swig.filter_delay_fc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(filter_delay_fc_sptr self) -> int"""
        return _filter_swig.filter_delay_fc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(filter_delay_fc_sptr self, int priority) -> int"""
        return _filter_swig.filter_delay_fc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(filter_delay_fc_sptr self) -> std::string"""
        return _filter_swig.filter_delay_fc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(filter_delay_fc_sptr self) -> std::string"""
        return _filter_swig.filter_delay_fc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(filter_delay_fc_sptr self) -> io_signature_sptr"""
        return _filter_swig.filter_delay_fc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(filter_delay_fc_sptr self) -> io_signature_sptr"""
        return _filter_swig.filter_delay_fc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(filter_delay_fc_sptr self) -> long"""
        return _filter_swig.filter_delay_fc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(filter_delay_fc_sptr self) -> basic_block_sptr"""
        return _filter_swig.filter_delay_fc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(filter_delay_fc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.filter_delay_fc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(filter_delay_fc_sptr self) -> std::string"""
        return _filter_swig.filter_delay_fc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(filter_delay_fc_sptr self, std::string name)"""
        return _filter_swig.filter_delay_fc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(filter_delay_fc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.filter_delay_fc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(filter_delay_fc_sptr self) -> swig_int_ptr"""
        return _filter_swig.filter_delay_fc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(filter_delay_fc_sptr self) -> swig_int_ptr"""
        return _filter_swig.filter_delay_fc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(filter_delay_fc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.filter_delay_fc_sptr_message_subscribers(self, *args, **kwargs)

filter_delay_fc_sptr_swigregister = _filter_swig.filter_delay_fc_sptr_swigregister
filter_delay_fc_sptr_swigregister(filter_delay_fc_sptr)

filter_delay_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
filter_delay_fc = filter_delay_fc.make;

class filterbank_vcvcf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::filterbank_vcvcf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::filterbank_vcvcf)> self) -> filterbank_vcvcf_sptr
        __init__(boost::shared_ptr<(gr::filter::filterbank_vcvcf)> self, filterbank_vcvcf p) -> filterbank_vcvcf_sptr
        """
        this = _filter_swig.new_filterbank_vcvcf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(filterbank_vcvcf_sptr self) -> filterbank_vcvcf"""
        return _filter_swig.filterbank_vcvcf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_filterbank_vcvcf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(filterbank_vcvcf_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & taps) -> filterbank_vcvcf_sptr

        Filterbank with vector of gr_complex input, vector of gr_complex output and float taps.

        This block takes in complex vectors and outputs complex vectors of the same size. Vectors of length N, rather than N normal streams are used to reduce overhead.

        Constructor Specific Documentation:

        Build the filterbank.

        Args:
            taps : (vector of vector of floats/list of list of floats) Used to populate the filters.
        """
        return _filter_swig.filterbank_vcvcf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(filterbank_vcvcf_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.filterbank_vcvcf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(filterbank_vcvcf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.filterbank_vcvcf_sptr_print_taps(self)

    def taps(self):
        """
        taps(filterbank_vcvcf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.filterbank_vcvcf_sptr_taps(self)

    def history(self):
        """history(filterbank_vcvcf_sptr self) -> unsigned int"""
        return _filter_swig.filterbank_vcvcf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(filterbank_vcvcf_sptr self, int which, int delay)
        declare_sample_delay(filterbank_vcvcf_sptr self, unsigned int delay)
        """
        return _filter_swig.filterbank_vcvcf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(filterbank_vcvcf_sptr self, int which) -> unsigned int"""
        return _filter_swig.filterbank_vcvcf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(filterbank_vcvcf_sptr self) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(filterbank_vcvcf_sptr self) -> double"""
        return _filter_swig.filterbank_vcvcf_sptr_relative_rate(self)

    def start(self):
        """start(filterbank_vcvcf_sptr self) -> bool"""
        return _filter_swig.filterbank_vcvcf_sptr_start(self)

    def stop(self):
        """stop(filterbank_vcvcf_sptr self) -> bool"""
        return _filter_swig.filterbank_vcvcf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(filterbank_vcvcf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.filterbank_vcvcf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(filterbank_vcvcf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.filterbank_vcvcf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(filterbank_vcvcf_sptr self) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(filterbank_vcvcf_sptr self, int m)"""
        return _filter_swig.filterbank_vcvcf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(filterbank_vcvcf_sptr self)"""
        return _filter_swig.filterbank_vcvcf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(filterbank_vcvcf_sptr self) -> bool"""
        return _filter_swig.filterbank_vcvcf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(filterbank_vcvcf_sptr self, int m)"""
        return _filter_swig.filterbank_vcvcf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(filterbank_vcvcf_sptr self) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(filterbank_vcvcf_sptr self, int i) -> long"""
        return _filter_swig.filterbank_vcvcf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(filterbank_vcvcf_sptr self, long max_output_buffer)
        set_max_output_buffer(filterbank_vcvcf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.filterbank_vcvcf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(filterbank_vcvcf_sptr self, int i) -> long"""
        return _filter_swig.filterbank_vcvcf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(filterbank_vcvcf_sptr self, long min_output_buffer)
        set_min_output_buffer(filterbank_vcvcf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.filterbank_vcvcf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(filterbank_vcvcf_sptr self, int which) -> float
        pc_input_buffers_full(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(filterbank_vcvcf_sptr self, int which) -> float
        pc_input_buffers_full_avg(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(filterbank_vcvcf_sptr self, int which) -> float
        pc_input_buffers_full_var(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(filterbank_vcvcf_sptr self, int which) -> float
        pc_output_buffers_full(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(filterbank_vcvcf_sptr self, int which) -> float
        pc_output_buffers_full_avg(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(filterbank_vcvcf_sptr self, int which) -> float
        pc_output_buffers_full_var(filterbank_vcvcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.filterbank_vcvcf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(filterbank_vcvcf_sptr self) -> float"""
        return _filter_swig.filterbank_vcvcf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(filterbank_vcvcf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.filterbank_vcvcf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(filterbank_vcvcf_sptr self)"""
        return _filter_swig.filterbank_vcvcf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(filterbank_vcvcf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.filterbank_vcvcf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(filterbank_vcvcf_sptr self) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(filterbank_vcvcf_sptr self) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(filterbank_vcvcf_sptr self, int priority) -> int"""
        return _filter_swig.filterbank_vcvcf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(filterbank_vcvcf_sptr self) -> std::string"""
        return _filter_swig.filterbank_vcvcf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(filterbank_vcvcf_sptr self) -> std::string"""
        return _filter_swig.filterbank_vcvcf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(filterbank_vcvcf_sptr self) -> io_signature_sptr"""
        return _filter_swig.filterbank_vcvcf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(filterbank_vcvcf_sptr self) -> io_signature_sptr"""
        return _filter_swig.filterbank_vcvcf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(filterbank_vcvcf_sptr self) -> long"""
        return _filter_swig.filterbank_vcvcf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(filterbank_vcvcf_sptr self) -> basic_block_sptr"""
        return _filter_swig.filterbank_vcvcf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(filterbank_vcvcf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.filterbank_vcvcf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(filterbank_vcvcf_sptr self) -> std::string"""
        return _filter_swig.filterbank_vcvcf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(filterbank_vcvcf_sptr self, std::string name)"""
        return _filter_swig.filterbank_vcvcf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(filterbank_vcvcf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.filterbank_vcvcf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(filterbank_vcvcf_sptr self) -> swig_int_ptr"""
        return _filter_swig.filterbank_vcvcf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(filterbank_vcvcf_sptr self) -> swig_int_ptr"""
        return _filter_swig.filterbank_vcvcf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(filterbank_vcvcf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.filterbank_vcvcf_sptr_message_subscribers(self, *args, **kwargs)

filterbank_vcvcf_sptr_swigregister = _filter_swig.filterbank_vcvcf_sptr_swigregister
filterbank_vcvcf_sptr_swigregister(filterbank_vcvcf_sptr)

filterbank_vcvcf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
filterbank_vcvcf = filterbank_vcvcf.make;

class fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_ccc)> self) -> fir_filter_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_ccc)> self, fir_filter_ccc p) -> fir_filter_ccc_sptr
        """
        this = _filter_swig.new_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_ccc_sptr self) -> fir_filter_ccc"""
        return _filter_swig.fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_ccc_sptr self, int decimation, pmt_vector_cfloat taps) -> fir_filter_ccc_sptr

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_ccc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_ccc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_ccc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_ccc_sptr_taps(self)

    def history(self):
        """history(fir_filter_ccc_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_ccc_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_ccc_sptr self) -> double"""
        return _filter_swig.fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.fir_filter_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_ccc_sptr self)"""
        return _filter_swig.fir_filter_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.fir_filter_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.fir_filter_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_ccc_sptr self)"""
        return _filter_swig.fir_filter_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_ccc_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_ccc_sptr self) -> long"""
        return _filter_swig.fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_ccc_sptr self, std::string name)"""
        return _filter_swig.fir_filter_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccc_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_ccc_sptr_swigregister = _filter_swig.fir_filter_ccc_sptr_swigregister
fir_filter_ccc_sptr_swigregister(fir_filter_ccc_sptr)

fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_ccc = fir_filter_ccc.make;

class fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_ccf)> self) -> fir_filter_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_ccf)> self, fir_filter_ccf p) -> fir_filter_ccf_sptr
        """
        this = _filter_swig.new_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_ccf_sptr self) -> fir_filter_ccf"""
        return _filter_swig.fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_ccf_sptr self, int decimation, pmt_vector_float taps) -> fir_filter_ccf_sptr

        FIR filter with gr_complex input, gr_complex output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_ccf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_ccf_sptr self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_ccf_sptr_taps(self)

    def history(self):
        """history(fir_filter_ccf_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_ccf_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_ccf_sptr self) -> double"""
        return _filter_swig.fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.fir_filter_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_ccf_sptr self)"""
        return _filter_swig.fir_filter_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fir_filter_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.fir_filter_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.fir_filter_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_ccf_sptr self)"""
        return _filter_swig.fir_filter_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_ccf_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_ccf_sptr self) -> long"""
        return _filter_swig.fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_ccf_sptr self, std::string name)"""
        return _filter_swig.fir_filter_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_ccf_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_ccf_sptr_swigregister = _filter_swig.fir_filter_ccf_sptr_swigregister
fir_filter_ccf_sptr_swigregister(fir_filter_ccf_sptr)

fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_ccf = fir_filter_ccf.make;

class fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fcc)> self) -> fir_filter_fcc_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fcc)> self, fir_filter_fcc p) -> fir_filter_fcc_sptr
        """
        this = _filter_swig.new_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_fcc_sptr self) -> fir_filter_fcc"""
        return _filter_swig.fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_fcc_sptr self, int decimation, pmt_vector_cfloat taps) -> fir_filter_fcc_sptr

        FIR filter with float input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_fcc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fcc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fcc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_fcc_sptr_taps(self)

    def history(self):
        """history(fir_filter_fcc_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_fcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_fcc_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_fcc_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_fcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_fcc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_fcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_fcc_sptr self) -> double"""
        return _filter_swig.fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_fcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_fcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.fir_filter_fcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_fcc_sptr self)"""
        return _filter_swig.fir_filter_fcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.fir_filter_fcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.fir_filter_fcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_fcc_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_fcc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_fcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_fcc_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_fcc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_fcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.fir_filter_fcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_fcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_fcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_fcc_sptr self)"""
        return _filter_swig.fir_filter_fcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_fcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_fcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_fcc_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_fcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_fcc_sptr self) -> long"""
        return _filter_swig.fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_fcc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_fcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_fcc_sptr self, std::string name)"""
        return _filter_swig.fir_filter_fcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_fcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_fcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_fcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fcc_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_fcc_sptr_swigregister = _filter_swig.fir_filter_fcc_sptr_swigregister
fir_filter_fcc_sptr_swigregister(fir_filter_fcc_sptr)

fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_fcc = fir_filter_fcc.make;

class fir_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fff)> self) -> fir_filter_fff_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fff)> self, fir_filter_fff p) -> fir_filter_fff_sptr
        """
        this = _filter_swig.new_fir_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_fff_sptr self) -> fir_filter_fff"""
        return _filter_swig.fir_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_fff_sptr self, int decimation, pmt_vector_float taps) -> fir_filter_fff_sptr

        FIR filter with float input, float output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, float output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_fff_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fff_sptr self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fff_sptr self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_fff_sptr_taps(self)

    def history(self):
        """history(fir_filter_fff_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_fff_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_fff_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_fff_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_fff_sptr self) -> int"""
        return _filter_swig.fir_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_fff_sptr self) -> double"""
        return _filter_swig.fir_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.fir_filter_fff_sptr_start(self)

    def stop(self):
        """stop(fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.fir_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_fff_sptr self) -> int"""
        return _filter_swig.fir_filter_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_fff_sptr self, int m)"""
        return _filter_swig.fir_filter_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_fff_sptr self)"""
        return _filter_swig.fir_filter_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.fir_filter_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_fff_sptr self, int m)"""
        return _filter_swig.fir_filter_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_fff_sptr self) -> int"""
        return _filter_swig.fir_filter_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_fff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_fff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_fff_sptr self) -> float"""
        return _filter_swig.fir_filter_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_fff_sptr self)"""
        return _filter_swig.fir_filter_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_fff_sptr self) -> int"""
        return _filter_swig.fir_filter_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_fff_sptr self) -> int"""
        return _filter_swig.fir_filter_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_fff_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_fff_sptr self) -> long"""
        return _filter_swig.fir_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_fff_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_fff_sptr self, std::string name)"""
        return _filter_swig.fir_filter_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fff_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_fff_sptr_swigregister = _filter_swig.fir_filter_fff_sptr_swigregister
fir_filter_fff_sptr_swigregister(fir_filter_fff_sptr)

fir_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_fff = fir_filter_fff.make;

class fir_filter_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fsf)> self) -> fir_filter_fsf_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_fsf)> self, fir_filter_fsf p) -> fir_filter_fsf_sptr
        """
        this = _filter_swig.new_fir_filter_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_fsf_sptr self) -> fir_filter_fsf"""
        return _filter_swig.fir_filter_fsf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_fsf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_fsf_sptr self, int decimation, pmt_vector_float taps) -> fir_filter_fsf_sptr

        FIR filter with float input, short output, and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with float input, short output, and float taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.fir_filter_fsf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_fsf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.fir_filter_fsf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_fsf_sptr self) -> pmt_vector_float"""
        return _filter_swig.fir_filter_fsf_sptr_taps(self)

    def history(self):
        """history(fir_filter_fsf_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_fsf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_fsf_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_fsf_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_fsf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_fsf_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_fsf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_fsf_sptr self) -> double"""
        return _filter_swig.fir_filter_fsf_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.fir_filter_fsf_sptr_start(self)

    def stop(self):
        """stop(fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.fir_filter_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_fsf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_fsf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_fsf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_fsf_sptr self, int m)"""
        return _filter_swig.fir_filter_fsf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_fsf_sptr self)"""
        return _filter_swig.fir_filter_fsf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.fir_filter_fsf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_fsf_sptr self, int m)"""
        return _filter_swig.fir_filter_fsf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_fsf_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fsf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_fsf_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_fsf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_fsf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_fsf_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_fsf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_fsf_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_fsf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_fsf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_fsf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.fir_filter_fsf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_fsf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_fsf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_fsf_sptr self)"""
        return _filter_swig.fir_filter_fsf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_fsf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_fsf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_fsf_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_fsf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fsf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fsf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_fsf_sptr self) -> long"""
        return _filter_swig.fir_filter_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_fsf_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_fsf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_fsf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.fir_filter_fsf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_fsf_sptr self, std::string name)"""
        return _filter_swig.fir_filter_fsf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_fsf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_fsf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fsf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fsf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_fsf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_fsf_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_fsf_sptr_swigregister = _filter_swig.fir_filter_fsf_sptr_swigregister
fir_filter_fsf_sptr_swigregister(fir_filter_fsf_sptr)

fir_filter_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_fsf = fir_filter_fsf.make;

class fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fir_filter_scc)> self) -> fir_filter_scc_sptr
        __init__(boost::shared_ptr<(gr::filter::fir_filter_scc)> self, fir_filter_scc p) -> fir_filter_scc_sptr
        """
        this = _filter_swig.new_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fir_filter_scc_sptr self) -> fir_filter_scc"""
        return _filter_swig.fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fir_filter_scc_sptr self, int decimation, pmt_vector_cfloat taps) -> fir_filter_scc_sptr

        FIR filter with short input, gr_complex output, and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as down-samplers (or decimators) by specifying an integer value for .

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and gr_complex taps.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.fir_filter_scc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fir_filter_scc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fir_filter_scc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.fir_filter_scc_sptr_taps(self)

    def history(self):
        """history(fir_filter_scc_sptr self) -> unsigned int"""
        return _filter_swig.fir_filter_scc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fir_filter_scc_sptr self, int which, int delay)
        declare_sample_delay(fir_filter_scc_sptr self, unsigned int delay)
        """
        return _filter_swig.fir_filter_scc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fir_filter_scc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fir_filter_scc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fir_filter_scc_sptr self) -> int"""
        return _filter_swig.fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fir_filter_scc_sptr self) -> double"""
        return _filter_swig.fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fir_filter_scc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fir_filter_scc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fir_filter_scc_sptr self) -> int"""
        return _filter_swig.fir_filter_scc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fir_filter_scc_sptr self, int m)"""
        return _filter_swig.fir_filter_scc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fir_filter_scc_sptr self)"""
        return _filter_swig.fir_filter_scc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.fir_filter_scc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fir_filter_scc_sptr self, int m)"""
        return _filter_swig.fir_filter_scc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fir_filter_scc_sptr self) -> int"""
        return _filter_swig.fir_filter_scc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_scc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fir_filter_scc_sptr self, long max_output_buffer)
        set_max_output_buffer(fir_filter_scc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fir_filter_scc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.fir_filter_scc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fir_filter_scc_sptr self, long min_output_buffer)
        set_min_output_buffer(fir_filter_scc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fir_filter_scc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_var(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_var(fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fir_filter_scc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fir_filter_scc_sptr self) -> float"""
        return _filter_swig.fir_filter_scc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fir_filter_scc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fir_filter_scc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fir_filter_scc_sptr self)"""
        return _filter_swig.fir_filter_scc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fir_filter_scc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fir_filter_scc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fir_filter_scc_sptr self) -> int"""
        return _filter_swig.fir_filter_scc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fir_filter_scc_sptr self) -> int"""
        return _filter_swig.fir_filter_scc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fir_filter_scc_sptr self, int priority) -> int"""
        return _filter_swig.fir_filter_scc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_scc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_scc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fir_filter_scc_sptr self) -> long"""
        return _filter_swig.fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fir_filter_scc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fir_filter_scc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.fir_filter_scc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fir_filter_scc_sptr self, std::string name)"""
        return _filter_swig.fir_filter_scc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fir_filter_scc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fir_filter_scc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_scc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fir_filter_scc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fir_filter_scc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fir_filter_scc_sptr_message_subscribers(self, *args, **kwargs)

fir_filter_scc_sptr_swigregister = _filter_swig.fir_filter_scc_sptr_swigregister
fir_filter_scc_sptr_swigregister(fir_filter_scc_sptr)

fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fir_filter_scc = fir_filter_scc.make;

class fft_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fft_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fft_filter_ccc)> self) -> fft_filter_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::fft_filter_ccc)> self, fft_filter_ccc p) -> fft_filter_ccc_sptr
        """
        this = _filter_swig.new_fft_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fft_filter_ccc_sptr self) -> fft_filter_ccc"""
        return _filter_swig.fft_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fft_filter_ccc_sptr self, int decimation, pmt_vector_cfloat taps, int nthreads=1) -> fft_filter_ccc_sptr

        Fast FFT filter with gr_complex input, gr_complex output and gr_complex taps.

        This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter blocks.

        Args:
            decimation : >= 1
            taps : complex filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_ccc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_ccc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.fft_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_ccc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.fft_filter_ccc_sptr_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_ccc_sptr self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_ccc_sptr_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_ccc_sptr self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_ccc_sptr_nthreads(self)

    def history(self):
        """history(fft_filter_ccc_sptr self) -> unsigned int"""
        return _filter_swig.fft_filter_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fft_filter_ccc_sptr self, int which, int delay)
        declare_sample_delay(fft_filter_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.fft_filter_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fft_filter_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fft_filter_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fft_filter_ccc_sptr self) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fft_filter_ccc_sptr self) -> double"""
        return _filter_swig.fft_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(fft_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(fft_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fft_filter_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fft_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fft_filter_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fft_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fft_filter_ccc_sptr self) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fft_filter_ccc_sptr self, int m)"""
        return _filter_swig.fft_filter_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fft_filter_ccc_sptr self)"""
        return _filter_swig.fft_filter_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fft_filter_ccc_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fft_filter_ccc_sptr self, int m)"""
        return _filter_swig.fft_filter_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fft_filter_ccc_sptr self) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fft_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fft_filter_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(fft_filter_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fft_filter_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fft_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fft_filter_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(fft_filter_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fft_filter_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fft_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fft_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fft_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fft_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fft_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fft_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(fft_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fft_filter_ccc_sptr self) -> float"""
        return _filter_swig.fft_filter_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fft_filter_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fft_filter_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fft_filter_ccc_sptr self)"""
        return _filter_swig.fft_filter_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fft_filter_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fft_filter_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fft_filter_ccc_sptr self) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fft_filter_ccc_sptr self) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fft_filter_ccc_sptr self, int priority) -> int"""
        return _filter_swig.fft_filter_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fft_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fft_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fft_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fft_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fft_filter_ccc_sptr self) -> long"""
        return _filter_swig.fft_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fft_filter_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fft_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fft_filter_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fft_filter_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fft_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fft_filter_ccc_sptr self, std::string name)"""
        return _filter_swig.fft_filter_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fft_filter_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fft_filter_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fft_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fft_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fft_filter_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccc_sptr_message_subscribers(self, *args, **kwargs)

fft_filter_ccc_sptr_swigregister = _filter_swig.fft_filter_ccc_sptr_swigregister
fft_filter_ccc_sptr_swigregister(fft_filter_ccc_sptr)

fft_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fft_filter_ccc = fft_filter_ccc.make;

class fft_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fft_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fft_filter_ccf)> self) -> fft_filter_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::fft_filter_ccf)> self, fft_filter_ccf p) -> fft_filter_ccf_sptr
        """
        this = _filter_swig.new_fft_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fft_filter_ccf_sptr self) -> fft_filter_ccf"""
        return _filter_swig.fft_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fft_filter_ccf_sptr self, int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_ccf_sptr

        Fast FFT filter with gr_complex input, gr_complex output and float taps.

        This block implements a complex decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of complex (or real) taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter blocks.

        Args:
            decimation : >= 1
            taps : complex filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_ccf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.fft_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_ccf_sptr self) -> pmt_vector_float"""
        return _filter_swig.fft_filter_ccf_sptr_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_ccf_sptr self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_ccf_sptr_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_ccf_sptr self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_ccf_sptr_nthreads(self)

    def history(self):
        """history(fft_filter_ccf_sptr self) -> unsigned int"""
        return _filter_swig.fft_filter_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fft_filter_ccf_sptr self, int which, int delay)
        declare_sample_delay(fft_filter_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.fft_filter_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fft_filter_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.fft_filter_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fft_filter_ccf_sptr self) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fft_filter_ccf_sptr self) -> double"""
        return _filter_swig.fft_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(fft_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(fft_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fft_filter_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fft_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fft_filter_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fft_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fft_filter_ccf_sptr self) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fft_filter_ccf_sptr self, int m)"""
        return _filter_swig.fft_filter_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fft_filter_ccf_sptr self)"""
        return _filter_swig.fft_filter_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fft_filter_ccf_sptr self) -> bool"""
        return _filter_swig.fft_filter_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fft_filter_ccf_sptr self, int m)"""
        return _filter_swig.fft_filter_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fft_filter_ccf_sptr self) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fft_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fft_filter_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(fft_filter_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fft_filter_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fft_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fft_filter_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(fft_filter_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fft_filter_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fft_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fft_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fft_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fft_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fft_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fft_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(fft_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fft_filter_ccf_sptr self) -> float"""
        return _filter_swig.fft_filter_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fft_filter_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fft_filter_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fft_filter_ccf_sptr self)"""
        return _filter_swig.fft_filter_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fft_filter_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fft_filter_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fft_filter_ccf_sptr self) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fft_filter_ccf_sptr self) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fft_filter_ccf_sptr self, int priority) -> int"""
        return _filter_swig.fft_filter_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fft_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fft_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fft_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fft_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fft_filter_ccf_sptr self) -> long"""
        return _filter_swig.fft_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fft_filter_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.fft_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fft_filter_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fft_filter_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fft_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.fft_filter_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fft_filter_ccf_sptr self, std::string name)"""
        return _filter_swig.fft_filter_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fft_filter_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fft_filter_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fft_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fft_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fft_filter_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fft_filter_ccf_sptr_message_subscribers(self, *args, **kwargs)

fft_filter_ccf_sptr_swigregister = _filter_swig.fft_filter_ccf_sptr_swigregister
fft_filter_ccf_sptr_swigregister(fft_filter_ccf_sptr)

fft_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fft_filter_ccf = fft_filter_ccf.make;

class fft_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fft_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fft_filter_fff)> self) -> fft_filter_fff_sptr
        __init__(boost::shared_ptr<(gr::filter::fft_filter_fff)> self, fft_filter_fff p) -> fft_filter_fff_sptr
        """
        this = _filter_swig.new_fft_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fft_filter_fff_sptr self) -> fft_filter_fff"""
        return _filter_swig.fft_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fft_filter_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fft_filter_fff_sptr self, int decimation, pmt_vector_float taps, int nthreads=1) -> fft_filter_fff_sptr

        Fast FFT filter with float input, float output and float taps.

        This block implements a real-value decimating filter using the fast convolution method via an FFT. The decimation factor is an interger that is greater than or equal to 1.

        The filter takes a set of real-valued taps to use in the filtering operation. These taps can be defined as anything that satisfies the user's filtering needs. For standard filters such as lowpass, highpass, bandpass, etc., the filter.firdes and filter.optfir classes provide convenient generating methods.

        This filter is implemented by using the FFTW package to perform the required FFTs. An optional argument, nthreads, may be passed to the constructor (or set using the set_nthreads member function) to split the FFT among N number of threads. This can improve performance on very large FFTs (that is, if the number of taps used is very large) if you have enough threads/cores to support it.

        Constructor Specific Documentation:

        Build an FFT filter block.

        Args:
            decimation : >= 1
            taps : float filter taps
            nthreads : number of threads for the FFT to use
        """
        return _filter_swig.fft_filter_fff_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(fft_filter_fff_sptr self, pmt_vector_float taps)"""
        return _filter_swig.fft_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(fft_filter_fff_sptr self) -> pmt_vector_float"""
        return _filter_swig.fft_filter_fff_sptr_taps(self)

    def set_nthreads(self, *args, **kwargs):
        """
        set_nthreads(fft_filter_fff_sptr self, int n)

        Set number of threads to use.
        """
        return _filter_swig.fft_filter_fff_sptr_set_nthreads(self, *args, **kwargs)

    def nthreads(self):
        """
        nthreads(fft_filter_fff_sptr self) -> int

        Get number of threads being used.
        """
        return _filter_swig.fft_filter_fff_sptr_nthreads(self)

    def history(self):
        """history(fft_filter_fff_sptr self) -> unsigned int"""
        return _filter_swig.fft_filter_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fft_filter_fff_sptr self, int which, int delay)
        declare_sample_delay(fft_filter_fff_sptr self, unsigned int delay)
        """
        return _filter_swig.fft_filter_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fft_filter_fff_sptr self, int which) -> unsigned int"""
        return _filter_swig.fft_filter_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fft_filter_fff_sptr self) -> int"""
        return _filter_swig.fft_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fft_filter_fff_sptr self) -> double"""
        return _filter_swig.fft_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(fft_filter_fff_sptr self) -> bool"""
        return _filter_swig.fft_filter_fff_sptr_start(self)

    def stop(self):
        """stop(fft_filter_fff_sptr self) -> bool"""
        return _filter_swig.fft_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fft_filter_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fft_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fft_filter_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fft_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fft_filter_fff_sptr self) -> int"""
        return _filter_swig.fft_filter_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fft_filter_fff_sptr self, int m)"""
        return _filter_swig.fft_filter_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fft_filter_fff_sptr self)"""
        return _filter_swig.fft_filter_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fft_filter_fff_sptr self) -> bool"""
        return _filter_swig.fft_filter_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fft_filter_fff_sptr self, int m)"""
        return _filter_swig.fft_filter_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fft_filter_fff_sptr self) -> int"""
        return _filter_swig.fft_filter_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fft_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fft_filter_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(fft_filter_fff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fft_filter_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fft_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.fft_filter_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fft_filter_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(fft_filter_fff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fft_filter_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fft_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fft_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fft_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fft_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fft_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fft_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(fft_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fft_filter_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fft_filter_fff_sptr self) -> float"""
        return _filter_swig.fft_filter_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fft_filter_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fft_filter_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fft_filter_fff_sptr self)"""
        return _filter_swig.fft_filter_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fft_filter_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fft_filter_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fft_filter_fff_sptr self) -> int"""
        return _filter_swig.fft_filter_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fft_filter_fff_sptr self) -> int"""
        return _filter_swig.fft_filter_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fft_filter_fff_sptr self, int priority) -> int"""
        return _filter_swig.fft_filter_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fft_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fft_filter_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fft_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fft_filter_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fft_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fft_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fft_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fft_filter_fff_sptr self) -> long"""
        return _filter_swig.fft_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fft_filter_fff_sptr self) -> basic_block_sptr"""
        return _filter_swig.fft_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fft_filter_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fft_filter_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fft_filter_fff_sptr self) -> std::string"""
        return _filter_swig.fft_filter_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fft_filter_fff_sptr self, std::string name)"""
        return _filter_swig.fft_filter_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fft_filter_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fft_filter_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fft_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fft_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fft_filter_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fft_filter_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fft_filter_fff_sptr_message_subscribers(self, *args, **kwargs)

fft_filter_fff_sptr_swigregister = _filter_swig.fft_filter_fff_sptr_swigregister
fft_filter_fff_sptr_swigregister(fft_filter_fff_sptr)

fft_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fft_filter_fff = fft_filter_fff.make;

class fractional_interpolator_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fractional_interpolator_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fractional_interpolator_cc)> self) -> fractional_interpolator_cc_sptr
        __init__(boost::shared_ptr<(gr::filter::fractional_interpolator_cc)> self, fractional_interpolator_cc p) -> fractional_interpolator_cc_sptr
        """
        this = _filter_swig.new_fractional_interpolator_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fractional_interpolator_cc_sptr self) -> fractional_interpolator_cc"""
        return _filter_swig.fractional_interpolator_cc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fractional_interpolator_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fractional_interpolator_cc_sptr self, float phase_shift, float interp_ratio) -> fractional_interpolator_cc_sptr

        Interpolating MMSE filter with complex input, complex output.

        Constructor Specific Documentation:

        Build the interpolating MMSE filter (complex input, complex output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            interp_ratio : The interpolation ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_interpolator_cc_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_mu(self)

    def interp_ratio(self):
        """interp_ratio(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_interpolator_cc_sptr self, float mu)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(fractional_interpolator_cc_sptr self, float interp_ratio)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_interp_ratio(self, *args, **kwargs)

    def history(self):
        """history(fractional_interpolator_cc_sptr self) -> unsigned int"""
        return _filter_swig.fractional_interpolator_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fractional_interpolator_cc_sptr self, int which, int delay)
        declare_sample_delay(fractional_interpolator_cc_sptr self, unsigned int delay)
        """
        return _filter_swig.fractional_interpolator_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fractional_interpolator_cc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fractional_interpolator_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fractional_interpolator_cc_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fractional_interpolator_cc_sptr self) -> double"""
        return _filter_swig.fractional_interpolator_cc_sptr_relative_rate(self)

    def start(self):
        """start(fractional_interpolator_cc_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_cc_sptr_start(self)

    def stop(self):
        """stop(fractional_interpolator_cc_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fractional_interpolator_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fractional_interpolator_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fractional_interpolator_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fractional_interpolator_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fractional_interpolator_cc_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fractional_interpolator_cc_sptr self, int m)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fractional_interpolator_cc_sptr self)"""
        return _filter_swig.fractional_interpolator_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fractional_interpolator_cc_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fractional_interpolator_cc_sptr self, int m)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fractional_interpolator_cc_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fractional_interpolator_cc_sptr self, int i) -> long"""
        return _filter_swig.fractional_interpolator_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fractional_interpolator_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(fractional_interpolator_cc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fractional_interpolator_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fractional_interpolator_cc_sptr self, int i) -> long"""
        return _filter_swig.fractional_interpolator_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fractional_interpolator_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(fractional_interpolator_cc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fractional_interpolator_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fractional_interpolator_cc_sptr self, int which) -> float
        pc_input_buffers_full(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fractional_interpolator_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fractional_interpolator_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fractional_interpolator_cc_sptr self, int which) -> float
        pc_output_buffers_full(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fractional_interpolator_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fractional_interpolator_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(fractional_interpolator_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fractional_interpolator_cc_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fractional_interpolator_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fractional_interpolator_cc_sptr self)"""
        return _filter_swig.fractional_interpolator_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fractional_interpolator_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fractional_interpolator_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fractional_interpolator_cc_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fractional_interpolator_cc_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fractional_interpolator_cc_sptr self, int priority) -> int"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fractional_interpolator_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fractional_interpolator_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fractional_interpolator_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fractional_interpolator_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fractional_interpolator_cc_sptr self) -> long"""
        return _filter_swig.fractional_interpolator_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fractional_interpolator_cc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fractional_interpolator_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fractional_interpolator_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fractional_interpolator_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fractional_interpolator_cc_sptr self, std::string name)"""
        return _filter_swig.fractional_interpolator_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fractional_interpolator_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fractional_interpolator_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fractional_interpolator_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fractional_interpolator_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fractional_interpolator_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_cc_sptr_message_subscribers(self, *args, **kwargs)

fractional_interpolator_cc_sptr_swigregister = _filter_swig.fractional_interpolator_cc_sptr_swigregister
fractional_interpolator_cc_sptr_swigregister(fractional_interpolator_cc_sptr)

fractional_interpolator_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fractional_interpolator_cc = fractional_interpolator_cc.make;

class fractional_interpolator_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fractional_interpolator_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fractional_interpolator_ff)> self) -> fractional_interpolator_ff_sptr
        __init__(boost::shared_ptr<(gr::filter::fractional_interpolator_ff)> self, fractional_interpolator_ff p) -> fractional_interpolator_ff_sptr
        """
        this = _filter_swig.new_fractional_interpolator_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fractional_interpolator_ff_sptr self) -> fractional_interpolator_ff"""
        return _filter_swig.fractional_interpolator_ff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fractional_interpolator_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fractional_interpolator_ff_sptr self, float phase_shift, float interp_ratio) -> fractional_interpolator_ff_sptr

        Interpolating MMSE filter with float input, float output.

        Constructor Specific Documentation:

        Build the interpolating MMSE filter (float input, float output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            interp_ratio : The interpolation ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_interpolator_ff_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_mu(self)

    def interp_ratio(self):
        """interp_ratio(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_interp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_interpolator_ff_sptr self, float mu)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_mu(self, *args, **kwargs)

    def set_interp_ratio(self, *args, **kwargs):
        """set_interp_ratio(fractional_interpolator_ff_sptr self, float interp_ratio)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_interp_ratio(self, *args, **kwargs)

    def history(self):
        """history(fractional_interpolator_ff_sptr self) -> unsigned int"""
        return _filter_swig.fractional_interpolator_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fractional_interpolator_ff_sptr self, int which, int delay)
        declare_sample_delay(fractional_interpolator_ff_sptr self, unsigned int delay)
        """
        return _filter_swig.fractional_interpolator_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fractional_interpolator_ff_sptr self, int which) -> unsigned int"""
        return _filter_swig.fractional_interpolator_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fractional_interpolator_ff_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fractional_interpolator_ff_sptr self) -> double"""
        return _filter_swig.fractional_interpolator_ff_sptr_relative_rate(self)

    def start(self):
        """start(fractional_interpolator_ff_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_ff_sptr_start(self)

    def stop(self):
        """stop(fractional_interpolator_ff_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fractional_interpolator_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fractional_interpolator_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fractional_interpolator_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fractional_interpolator_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fractional_interpolator_ff_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fractional_interpolator_ff_sptr self, int m)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fractional_interpolator_ff_sptr self)"""
        return _filter_swig.fractional_interpolator_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fractional_interpolator_ff_sptr self) -> bool"""
        return _filter_swig.fractional_interpolator_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fractional_interpolator_ff_sptr self, int m)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fractional_interpolator_ff_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fractional_interpolator_ff_sptr self, int i) -> long"""
        return _filter_swig.fractional_interpolator_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fractional_interpolator_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(fractional_interpolator_ff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fractional_interpolator_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fractional_interpolator_ff_sptr self, int i) -> long"""
        return _filter_swig.fractional_interpolator_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fractional_interpolator_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(fractional_interpolator_ff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fractional_interpolator_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fractional_interpolator_ff_sptr self, int which) -> float
        pc_input_buffers_full(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fractional_interpolator_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fractional_interpolator_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fractional_interpolator_ff_sptr self, int which) -> float
        pc_output_buffers_full(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fractional_interpolator_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fractional_interpolator_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(fractional_interpolator_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_interpolator_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fractional_interpolator_ff_sptr self) -> float"""
        return _filter_swig.fractional_interpolator_ff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fractional_interpolator_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fractional_interpolator_ff_sptr self)"""
        return _filter_swig.fractional_interpolator_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fractional_interpolator_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fractional_interpolator_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fractional_interpolator_ff_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fractional_interpolator_ff_sptr self) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fractional_interpolator_ff_sptr self, int priority) -> int"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fractional_interpolator_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fractional_interpolator_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fractional_interpolator_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fractional_interpolator_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fractional_interpolator_ff_sptr self) -> long"""
        return _filter_swig.fractional_interpolator_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fractional_interpolator_ff_sptr self) -> basic_block_sptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fractional_interpolator_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fractional_interpolator_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fractional_interpolator_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_interpolator_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fractional_interpolator_ff_sptr self, std::string name)"""
        return _filter_swig.fractional_interpolator_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fractional_interpolator_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fractional_interpolator_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fractional_interpolator_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fractional_interpolator_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fractional_interpolator_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fractional_interpolator_ff_sptr_message_subscribers(self, *args, **kwargs)

fractional_interpolator_ff_sptr_swigregister = _filter_swig.fractional_interpolator_ff_sptr_swigregister
fractional_interpolator_ff_sptr_swigregister(fractional_interpolator_ff_sptr)

fractional_interpolator_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fractional_interpolator_ff = fractional_interpolator_ff.make;

class fractional_resampler_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fractional_resampler_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fractional_resampler_cc)> self) -> fractional_resampler_cc_sptr
        __init__(boost::shared_ptr<(gr::filter::fractional_resampler_cc)> self, fractional_resampler_cc p) -> fractional_resampler_cc_sptr
        """
        this = _filter_swig.new_fractional_resampler_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fractional_resampler_cc_sptr self) -> fractional_resampler_cc"""
        return _filter_swig.fractional_resampler_cc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fractional_resampler_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fractional_resampler_cc_sptr self, float phase_shift, float resamp_ratio) -> fractional_resampler_cc_sptr

        resampling MMSE filter with complex input, complex output

        Constructor Specific Documentation:

        Build the resampling MMSE filter (complex input, complex output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            resamp_ratio : The resampling ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_resampler_cc_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_mu(self)

    def resamp_ratio(self):
        """resamp_ratio(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_resamp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_resampler_cc_sptr self, float mu)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_mu(self, *args, **kwargs)

    def set_resamp_ratio(self, *args, **kwargs):
        """set_resamp_ratio(fractional_resampler_cc_sptr self, float resamp_ratio)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_resamp_ratio(self, *args, **kwargs)

    def history(self):
        """history(fractional_resampler_cc_sptr self) -> unsigned int"""
        return _filter_swig.fractional_resampler_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fractional_resampler_cc_sptr self, int which, int delay)
        declare_sample_delay(fractional_resampler_cc_sptr self, unsigned int delay)
        """
        return _filter_swig.fractional_resampler_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fractional_resampler_cc_sptr self, int which) -> unsigned int"""
        return _filter_swig.fractional_resampler_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fractional_resampler_cc_sptr self) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fractional_resampler_cc_sptr self) -> double"""
        return _filter_swig.fractional_resampler_cc_sptr_relative_rate(self)

    def start(self):
        """start(fractional_resampler_cc_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_cc_sptr_start(self)

    def stop(self):
        """stop(fractional_resampler_cc_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fractional_resampler_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fractional_resampler_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fractional_resampler_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fractional_resampler_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fractional_resampler_cc_sptr self) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fractional_resampler_cc_sptr self, int m)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fractional_resampler_cc_sptr self)"""
        return _filter_swig.fractional_resampler_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fractional_resampler_cc_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fractional_resampler_cc_sptr self, int m)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fractional_resampler_cc_sptr self) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fractional_resampler_cc_sptr self, int i) -> long"""
        return _filter_swig.fractional_resampler_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fractional_resampler_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(fractional_resampler_cc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fractional_resampler_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fractional_resampler_cc_sptr self, int i) -> long"""
        return _filter_swig.fractional_resampler_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fractional_resampler_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(fractional_resampler_cc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fractional_resampler_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fractional_resampler_cc_sptr self, int which) -> float
        pc_input_buffers_full(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fractional_resampler_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fractional_resampler_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fractional_resampler_cc_sptr self, int which) -> float
        pc_output_buffers_full(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fractional_resampler_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fractional_resampler_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(fractional_resampler_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fractional_resampler_cc_sptr self) -> float"""
        return _filter_swig.fractional_resampler_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fractional_resampler_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fractional_resampler_cc_sptr self)"""
        return _filter_swig.fractional_resampler_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fractional_resampler_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fractional_resampler_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fractional_resampler_cc_sptr self) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fractional_resampler_cc_sptr self) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fractional_resampler_cc_sptr self, int priority) -> int"""
        return _filter_swig.fractional_resampler_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fractional_resampler_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fractional_resampler_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fractional_resampler_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_resampler_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fractional_resampler_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_resampler_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fractional_resampler_cc_sptr self) -> long"""
        return _filter_swig.fractional_resampler_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fractional_resampler_cc_sptr self) -> basic_block_sptr"""
        return _filter_swig.fractional_resampler_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fractional_resampler_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fractional_resampler_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fractional_resampler_cc_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fractional_resampler_cc_sptr self, std::string name)"""
        return _filter_swig.fractional_resampler_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fractional_resampler_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fractional_resampler_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fractional_resampler_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fractional_resampler_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fractional_resampler_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_cc_sptr_message_subscribers(self, *args, **kwargs)

fractional_resampler_cc_sptr_swigregister = _filter_swig.fractional_resampler_cc_sptr_swigregister
fractional_resampler_cc_sptr_swigregister(fractional_resampler_cc_sptr)

fractional_resampler_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fractional_resampler_cc = fractional_resampler_cc.make;

class fractional_resampler_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::fractional_resampler_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::fractional_resampler_ff)> self) -> fractional_resampler_ff_sptr
        __init__(boost::shared_ptr<(gr::filter::fractional_resampler_ff)> self, fractional_resampler_ff p) -> fractional_resampler_ff_sptr
        """
        this = _filter_swig.new_fractional_resampler_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fractional_resampler_ff_sptr self) -> fractional_resampler_ff"""
        return _filter_swig.fractional_resampler_ff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_fractional_resampler_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fractional_resampler_ff_sptr self, float phase_shift, float resamp_ratio) -> fractional_resampler_ff_sptr

        Resampling MMSE filter with float input, float output.

        Constructor Specific Documentation:

        Build the resampling MMSE filter (float input, float output)

        Args:
            phase_shift : The phase shift of the output signal to the input
            resamp_ratio : The resampling ratio = input_rate / output_rate.
        """
        return _filter_swig.fractional_resampler_ff_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_mu(self)

    def resamp_ratio(self):
        """resamp_ratio(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_resamp_ratio(self)

    def set_mu(self, *args, **kwargs):
        """set_mu(fractional_resampler_ff_sptr self, float mu)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_mu(self, *args, **kwargs)

    def set_resamp_ratio(self, *args, **kwargs):
        """set_resamp_ratio(fractional_resampler_ff_sptr self, float resamp_ratio)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_resamp_ratio(self, *args, **kwargs)

    def history(self):
        """history(fractional_resampler_ff_sptr self) -> unsigned int"""
        return _filter_swig.fractional_resampler_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fractional_resampler_ff_sptr self, int which, int delay)
        declare_sample_delay(fractional_resampler_ff_sptr self, unsigned int delay)
        """
        return _filter_swig.fractional_resampler_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fractional_resampler_ff_sptr self, int which) -> unsigned int"""
        return _filter_swig.fractional_resampler_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fractional_resampler_ff_sptr self) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fractional_resampler_ff_sptr self) -> double"""
        return _filter_swig.fractional_resampler_ff_sptr_relative_rate(self)

    def start(self):
        """start(fractional_resampler_ff_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_ff_sptr_start(self)

    def stop(self):
        """stop(fractional_resampler_ff_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fractional_resampler_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.fractional_resampler_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fractional_resampler_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.fractional_resampler_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fractional_resampler_ff_sptr self) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fractional_resampler_ff_sptr self, int m)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fractional_resampler_ff_sptr self)"""
        return _filter_swig.fractional_resampler_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fractional_resampler_ff_sptr self) -> bool"""
        return _filter_swig.fractional_resampler_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fractional_resampler_ff_sptr self, int m)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fractional_resampler_ff_sptr self) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fractional_resampler_ff_sptr self, int i) -> long"""
        return _filter_swig.fractional_resampler_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fractional_resampler_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(fractional_resampler_ff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.fractional_resampler_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fractional_resampler_ff_sptr self, int i) -> long"""
        return _filter_swig.fractional_resampler_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fractional_resampler_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(fractional_resampler_ff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.fractional_resampler_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fractional_resampler_ff_sptr self, int which) -> float
        pc_input_buffers_full(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fractional_resampler_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fractional_resampler_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fractional_resampler_ff_sptr self, int which) -> float
        pc_output_buffers_full(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fractional_resampler_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fractional_resampler_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(fractional_resampler_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.fractional_resampler_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fractional_resampler_ff_sptr self) -> float"""
        return _filter_swig.fractional_resampler_ff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fractional_resampler_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fractional_resampler_ff_sptr self)"""
        return _filter_swig.fractional_resampler_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fractional_resampler_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.fractional_resampler_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fractional_resampler_ff_sptr self) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fractional_resampler_ff_sptr self) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fractional_resampler_ff_sptr self, int priority) -> int"""
        return _filter_swig.fractional_resampler_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fractional_resampler_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fractional_resampler_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fractional_resampler_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_resampler_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fractional_resampler_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.fractional_resampler_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fractional_resampler_ff_sptr self) -> long"""
        return _filter_swig.fractional_resampler_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fractional_resampler_ff_sptr self) -> basic_block_sptr"""
        return _filter_swig.fractional_resampler_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fractional_resampler_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.fractional_resampler_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fractional_resampler_ff_sptr self) -> std::string"""
        return _filter_swig.fractional_resampler_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fractional_resampler_ff_sptr self, std::string name)"""
        return _filter_swig.fractional_resampler_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fractional_resampler_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.fractional_resampler_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fractional_resampler_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fractional_resampler_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fractional_resampler_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.fractional_resampler_ff_sptr_message_subscribers(self, *args, **kwargs)

fractional_resampler_ff_sptr_swigregister = _filter_swig.fractional_resampler_ff_sptr_swigregister
fractional_resampler_ff_sptr_swigregister(fractional_resampler_ff_sptr)

fractional_resampler_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fractional_resampler_ff = fractional_resampler_ff.make;

class freq_xlating_fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccc)> self) -> freq_xlating_fir_filter_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccc)> self, freq_xlating_fir_filter_ccc p) -> freq_xlating_fir_filter_ccc_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_ccc_sptr self) -> freq_xlating_fir_filter_ccc"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_ccc_sptr self, int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccc_sptr

        FIR filter combined with frequency translation with gr_complex input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_ccc_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_ccc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_ccc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_ccc_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_ccc_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_ccc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_ccc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_ccc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_ccc_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_ccc_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_ccc_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccc_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_ccc_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_ccc_sptr_swigregister
freq_xlating_fir_filter_ccc_sptr_swigregister(freq_xlating_fir_filter_ccc_sptr)

freq_xlating_fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_ccc = freq_xlating_fir_filter_ccc.make;

class freq_xlating_fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccf)> self) -> freq_xlating_fir_filter_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_ccf)> self, freq_xlating_fir_filter_ccf p) -> freq_xlating_fir_filter_ccf_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_ccf_sptr self) -> freq_xlating_fir_filter_ccf"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_ccf_sptr self, int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_ccf_sptr

        FIR filter combined with frequency translation with gr_complex input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with gr_complex input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_ccf_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_ccf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_ccf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_ccf_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_ccf_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_ccf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_ccf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_ccf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_ccf_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_ccf_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_ccf_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_ccf_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_ccf_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_ccf_sptr_swigregister
freq_xlating_fir_filter_ccf_sptr_swigregister(freq_xlating_fir_filter_ccf_sptr)

freq_xlating_fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_ccf = freq_xlating_fir_filter_ccf.make;

class freq_xlating_fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcc)> self) -> freq_xlating_fir_filter_fcc_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcc)> self, freq_xlating_fir_filter_fcc p) -> freq_xlating_fir_filter_fcc_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_fcc_sptr self) -> freq_xlating_fir_filter_fcc"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_fcc_sptr self, int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcc_sptr

        FIR filter combined with frequency translation with float input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_fcc_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_fcc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_fcc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_fcc_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_fcc_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_fcc_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_fcc_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_fcc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_fcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_fcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_fcc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_fcc_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_fcc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_fcc_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_fcc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_fcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_fcc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_fcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_fcc_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_fcc_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_fcc_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_fcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_fcc_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_fcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_fcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcc_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_fcc_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_fcc_sptr_swigregister
freq_xlating_fir_filter_fcc_sptr_swigregister(freq_xlating_fir_filter_fcc_sptr)

freq_xlating_fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_fcc = freq_xlating_fir_filter_fcc.make;

class freq_xlating_fir_filter_fcf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcf)> self) -> freq_xlating_fir_filter_fcf_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_fcf)> self, freq_xlating_fir_filter_fcf p) -> freq_xlating_fir_filter_fcf_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_fcf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_fcf_sptr self) -> freq_xlating_fir_filter_fcf"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_fcf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_fcf_sptr self, int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_fcf_sptr

        FIR filter combined with frequency translation with float input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with float input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_fcf_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_fcf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_fcf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_fcf_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_fcf_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_fcf_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_fcf_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_fcf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_fcf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_fcf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_fcf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_fcf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_fcf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_fcf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_fcf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_fcf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_fcf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_fcf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_fcf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_fcf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_fcf_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_fcf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_fcf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_fcf_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_fcf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_fcf_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_fcf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_fcf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_fcf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_fcf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_fcf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_fcf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_fcf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_fcf_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_fcf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_fcf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_fcf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_fcf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_fcf_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_fcf_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_fcf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_fcf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_fcf_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_fcf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_fcf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_fcf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_fcf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_fcf_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_fcf_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_fcf_sptr_swigregister
freq_xlating_fir_filter_fcf_sptr_swigregister(freq_xlating_fir_filter_fcf_sptr)

freq_xlating_fir_filter_fcf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_fcf = freq_xlating_fir_filter_fcf.make;

class freq_xlating_fir_filter_scf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scf)> self) -> freq_xlating_fir_filter_scf_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scf)> self, freq_xlating_fir_filter_scf p) -> freq_xlating_fir_filter_scf_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_scf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_scf_sptr self) -> freq_xlating_fir_filter_scf"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_scf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_scf_sptr self, int decimation, pmt_vector_float taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scf_sptr

        FIR filter combined with frequency translation with short input, gr_complex output and float taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and float taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type float
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_scf_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_scf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_scf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_scf_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_scf_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_scf_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_scf_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_scf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_scf_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_scf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_scf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_scf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_scf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_scf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_scf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_scf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_scf_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_scf_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_scf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_scf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_scf_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_scf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_scf_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_scf_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_scf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_scf_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_scf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_scf_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_scf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_scf_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_scf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_scf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_scf_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_scf_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_scf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_scf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_scf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_scf_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_scf_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_scf_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_scf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_scf_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_scf_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_scf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_scf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_scf_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_scf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scf_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_scf_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_scf_sptr_swigregister
freq_xlating_fir_filter_scf_sptr_swigregister(freq_xlating_fir_filter_scf_sptr)

freq_xlating_fir_filter_scf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_scf = freq_xlating_fir_filter_scf.make;

class freq_xlating_fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scc)> self) -> freq_xlating_fir_filter_scc_sptr
        __init__(boost::shared_ptr<(gr::filter::freq_xlating_fir_filter_scc)> self, freq_xlating_fir_filter_scc p) -> freq_xlating_fir_filter_scc_sptr
        """
        this = _filter_swig.new_freq_xlating_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(freq_xlating_fir_filter_scc_sptr self) -> freq_xlating_fir_filter_scc"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_freq_xlating_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(freq_xlating_fir_filter_scc_sptr self, int decimation, pmt_vector_cfloat taps, double center_freq, double sampling_freq) -> freq_xlating_fir_filter_scc_sptr

        FIR filter combined with frequency translation with short input, gr_complex output and gr_complex taps.

        This class efficiently combines a frequency translation (typically "down conversion") with a FIR filter (typically low-pass) and decimation. It is ideally suited for a "channel
        selection filter" and can be efficiently used to select and decimate a narrow band signal out of wide bandwidth input.

        Uses a single input array to produce a single output array. Additional inputs and/or outputs are ignored.

        Constructor Specific Documentation:

        FIR filter with short input, gr_complex output, and gr_complex taps that also frequency translates a signal from .

        Construct a FIR filter with the given taps and a composite frequency translation that shifts center_freq down to zero Hz. The frequency translation logically comes before the filtering operation.

        Args:
            decimation : set the integer decimation rate
            taps : a vector/list of taps of type gr_complex
            center_freq : Center frequency of signal to down convert from (Hz)
            sampling_freq : Sampling rate of signal (in Hz)
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_make(self, *args, **kwargs)

    def set_center_freq(self, *args, **kwargs):
        """set_center_freq(freq_xlating_fir_filter_scc_sptr self, double center_freq)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_center_freq(self, *args, **kwargs)

    def center_freq(self):
        """center_freq(freq_xlating_fir_filter_scc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_center_freq(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(freq_xlating_fir_filter_scc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_taps(self)

    def history(self):
        """history(freq_xlating_fir_filter_scc_sptr self) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(freq_xlating_fir_filter_scc_sptr self, int which, int delay)
        declare_sample_delay(freq_xlating_fir_filter_scc_sptr self, unsigned int delay)
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(freq_xlating_fir_filter_scc_sptr self, int which) -> unsigned int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(freq_xlating_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(freq_xlating_fir_filter_scc_sptr self) -> double"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(freq_xlating_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(freq_xlating_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(freq_xlating_fir_filter_scc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(freq_xlating_fir_filter_scc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(freq_xlating_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(freq_xlating_fir_filter_scc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(freq_xlating_fir_filter_scc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(freq_xlating_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(freq_xlating_fir_filter_scc_sptr self, int m)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(freq_xlating_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(freq_xlating_fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(freq_xlating_fir_filter_scc_sptr self, long max_output_buffer)
        set_max_output_buffer(freq_xlating_fir_filter_scc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(freq_xlating_fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(freq_xlating_fir_filter_scc_sptr self, long min_output_buffer)
        set_min_output_buffer(freq_xlating_fir_filter_scc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_avg(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_var(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_avg(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(freq_xlating_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_var(freq_xlating_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(freq_xlating_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(freq_xlating_fir_filter_scc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(freq_xlating_fir_filter_scc_sptr self)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(freq_xlating_fir_filter_scc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(freq_xlating_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(freq_xlating_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(freq_xlating_fir_filter_scc_sptr self, int priority) -> int"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(freq_xlating_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(freq_xlating_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(freq_xlating_fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(freq_xlating_fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(freq_xlating_fir_filter_scc_sptr self) -> long"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(freq_xlating_fir_filter_scc_sptr self) -> basic_block_sptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(freq_xlating_fir_filter_scc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(freq_xlating_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(freq_xlating_fir_filter_scc_sptr self, std::string name)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(freq_xlating_fir_filter_scc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(freq_xlating_fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(freq_xlating_fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(freq_xlating_fir_filter_scc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.freq_xlating_fir_filter_scc_sptr_message_subscribers(self, *args, **kwargs)

freq_xlating_fir_filter_scc_sptr_swigregister = _filter_swig.freq_xlating_fir_filter_scc_sptr_swigregister
freq_xlating_fir_filter_scc_sptr_swigregister(freq_xlating_fir_filter_scc_sptr)

freq_xlating_fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
freq_xlating_fir_filter_scc = freq_xlating_fir_filter_scc.make;

class hilbert_fc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::hilbert_fc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::hilbert_fc)> self) -> hilbert_fc_sptr
        __init__(boost::shared_ptr<(gr::filter::hilbert_fc)> self, hilbert_fc p) -> hilbert_fc_sptr
        """
        this = _filter_swig.new_hilbert_fc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(hilbert_fc_sptr self) -> hilbert_fc"""
        return _filter_swig.hilbert_fc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_hilbert_fc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(hilbert_fc_sptr self, unsigned int ntaps, gr::filter::firdes::win_type window=WIN_HAMMING, double beta=6.76) -> hilbert_fc_sptr

        Hilbert transformer.

        real output is input appropriately delayed. imaginary output is hilbert filtered (90 degree phase shift) version of input.

        Constructor Specific Documentation:

        Build a Hilbert transformer filter block.

        Args:
            ntaps : The number of taps for the filter.
            window : Window type (see firdes::win_type) to use.
            beta : Beta value for a Kaiser window.
        """
        return _filter_swig.hilbert_fc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(hilbert_fc_sptr self) -> unsigned int"""
        return _filter_swig.hilbert_fc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(hilbert_fc_sptr self, int which, int delay)
        declare_sample_delay(hilbert_fc_sptr self, unsigned int delay)
        """
        return _filter_swig.hilbert_fc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(hilbert_fc_sptr self, int which) -> unsigned int"""
        return _filter_swig.hilbert_fc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(hilbert_fc_sptr self) -> int"""
        return _filter_swig.hilbert_fc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(hilbert_fc_sptr self) -> double"""
        return _filter_swig.hilbert_fc_sptr_relative_rate(self)

    def start(self):
        """start(hilbert_fc_sptr self) -> bool"""
        return _filter_swig.hilbert_fc_sptr_start(self)

    def stop(self):
        """stop(hilbert_fc_sptr self) -> bool"""
        return _filter_swig.hilbert_fc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(hilbert_fc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.hilbert_fc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(hilbert_fc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.hilbert_fc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(hilbert_fc_sptr self) -> int"""
        return _filter_swig.hilbert_fc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(hilbert_fc_sptr self, int m)"""
        return _filter_swig.hilbert_fc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(hilbert_fc_sptr self)"""
        return _filter_swig.hilbert_fc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(hilbert_fc_sptr self) -> bool"""
        return _filter_swig.hilbert_fc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(hilbert_fc_sptr self, int m)"""
        return _filter_swig.hilbert_fc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(hilbert_fc_sptr self) -> int"""
        return _filter_swig.hilbert_fc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(hilbert_fc_sptr self, int i) -> long"""
        return _filter_swig.hilbert_fc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(hilbert_fc_sptr self, long max_output_buffer)
        set_max_output_buffer(hilbert_fc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.hilbert_fc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(hilbert_fc_sptr self, int i) -> long"""
        return _filter_swig.hilbert_fc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(hilbert_fc_sptr self, long min_output_buffer)
        set_min_output_buffer(hilbert_fc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.hilbert_fc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(hilbert_fc_sptr self, int which) -> float
        pc_input_buffers_full(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(hilbert_fc_sptr self, int which) -> float
        pc_input_buffers_full_avg(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(hilbert_fc_sptr self, int which) -> float
        pc_input_buffers_full_var(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(hilbert_fc_sptr self, int which) -> float
        pc_output_buffers_full(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(hilbert_fc_sptr self, int which) -> float
        pc_output_buffers_full_avg(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(hilbert_fc_sptr self, int which) -> float
        pc_output_buffers_full_var(hilbert_fc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.hilbert_fc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(hilbert_fc_sptr self) -> float"""
        return _filter_swig.hilbert_fc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(hilbert_fc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.hilbert_fc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(hilbert_fc_sptr self)"""
        return _filter_swig.hilbert_fc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(hilbert_fc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.hilbert_fc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(hilbert_fc_sptr self) -> int"""
        return _filter_swig.hilbert_fc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(hilbert_fc_sptr self) -> int"""
        return _filter_swig.hilbert_fc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(hilbert_fc_sptr self, int priority) -> int"""
        return _filter_swig.hilbert_fc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(hilbert_fc_sptr self) -> std::string"""
        return _filter_swig.hilbert_fc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(hilbert_fc_sptr self) -> std::string"""
        return _filter_swig.hilbert_fc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(hilbert_fc_sptr self) -> io_signature_sptr"""
        return _filter_swig.hilbert_fc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(hilbert_fc_sptr self) -> io_signature_sptr"""
        return _filter_swig.hilbert_fc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(hilbert_fc_sptr self) -> long"""
        return _filter_swig.hilbert_fc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(hilbert_fc_sptr self) -> basic_block_sptr"""
        return _filter_swig.hilbert_fc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(hilbert_fc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.hilbert_fc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(hilbert_fc_sptr self) -> std::string"""
        return _filter_swig.hilbert_fc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(hilbert_fc_sptr self, std::string name)"""
        return _filter_swig.hilbert_fc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(hilbert_fc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.hilbert_fc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(hilbert_fc_sptr self) -> swig_int_ptr"""
        return _filter_swig.hilbert_fc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(hilbert_fc_sptr self) -> swig_int_ptr"""
        return _filter_swig.hilbert_fc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(hilbert_fc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.hilbert_fc_sptr_message_subscribers(self, *args, **kwargs)

hilbert_fc_sptr_swigregister = _filter_swig.hilbert_fc_sptr_swigregister
hilbert_fc_sptr_swigregister(hilbert_fc_sptr)

hilbert_fc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
hilbert_fc = hilbert_fc.make;

class iir_filter_ffd_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::iir_filter_ffd)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ffd)> self) -> iir_filter_ffd_sptr
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ffd)> self, iir_filter_ffd p) -> iir_filter_ffd_sptr
        """
        this = _filter_swig.new_iir_filter_ffd_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(iir_filter_ffd_sptr self) -> iir_filter_ffd"""
        return _filter_swig.iir_filter_ffd_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ffd_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(iir_filter_ffd_sptr self, pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ffd_sptr

        IIR filter with float input, float output and double taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ffd_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ffd_sptr self, pmt_vector_double fftaps, pmt_vector_double fbtaps)"""
        return _filter_swig.iir_filter_ffd_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(iir_filter_ffd_sptr self) -> unsigned int"""
        return _filter_swig.iir_filter_ffd_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(iir_filter_ffd_sptr self, int which, int delay)
        declare_sample_delay(iir_filter_ffd_sptr self, unsigned int delay)
        """
        return _filter_swig.iir_filter_ffd_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(iir_filter_ffd_sptr self, int which) -> unsigned int"""
        return _filter_swig.iir_filter_ffd_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(iir_filter_ffd_sptr self) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(iir_filter_ffd_sptr self) -> double"""
        return _filter_swig.iir_filter_ffd_sptr_relative_rate(self)

    def start(self):
        """start(iir_filter_ffd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ffd_sptr_start(self)

    def stop(self):
        """stop(iir_filter_ffd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ffd_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(iir_filter_ffd_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.iir_filter_ffd_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(iir_filter_ffd_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.iir_filter_ffd_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(iir_filter_ffd_sptr self) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(iir_filter_ffd_sptr self, int m)"""
        return _filter_swig.iir_filter_ffd_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(iir_filter_ffd_sptr self)"""
        return _filter_swig.iir_filter_ffd_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(iir_filter_ffd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ffd_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(iir_filter_ffd_sptr self, int m)"""
        return _filter_swig.iir_filter_ffd_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(iir_filter_ffd_sptr self) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(iir_filter_ffd_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ffd_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(iir_filter_ffd_sptr self, long max_output_buffer)
        set_max_output_buffer(iir_filter_ffd_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.iir_filter_ffd_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(iir_filter_ffd_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ffd_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(iir_filter_ffd_sptr self, long min_output_buffer)
        set_min_output_buffer(iir_filter_ffd_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.iir_filter_ffd_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(iir_filter_ffd_sptr self, int which) -> float
        pc_input_buffers_full(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(iir_filter_ffd_sptr self, int which) -> float
        pc_input_buffers_full_avg(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(iir_filter_ffd_sptr self, int which) -> float
        pc_input_buffers_full_var(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(iir_filter_ffd_sptr self, int which) -> float
        pc_output_buffers_full(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(iir_filter_ffd_sptr self, int which) -> float
        pc_output_buffers_full_avg(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(iir_filter_ffd_sptr self, int which) -> float
        pc_output_buffers_full_var(iir_filter_ffd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ffd_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(iir_filter_ffd_sptr self) -> float"""
        return _filter_swig.iir_filter_ffd_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(iir_filter_ffd_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.iir_filter_ffd_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(iir_filter_ffd_sptr self)"""
        return _filter_swig.iir_filter_ffd_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(iir_filter_ffd_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.iir_filter_ffd_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(iir_filter_ffd_sptr self) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(iir_filter_ffd_sptr self) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(iir_filter_ffd_sptr self, int priority) -> int"""
        return _filter_swig.iir_filter_ffd_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(iir_filter_ffd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ffd_sptr_name(self)

    def symbol_name(self):
        """symbol_name(iir_filter_ffd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ffd_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(iir_filter_ffd_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ffd_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(iir_filter_ffd_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ffd_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(iir_filter_ffd_sptr self) -> long"""
        return _filter_swig.iir_filter_ffd_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(iir_filter_ffd_sptr self) -> basic_block_sptr"""
        return _filter_swig.iir_filter_ffd_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(iir_filter_ffd_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.iir_filter_ffd_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(iir_filter_ffd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ffd_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(iir_filter_ffd_sptr self, std::string name)"""
        return _filter_swig.iir_filter_ffd_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(iir_filter_ffd_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.iir_filter_ffd_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(iir_filter_ffd_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ffd_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(iir_filter_ffd_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ffd_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(iir_filter_ffd_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ffd_sptr_message_subscribers(self, *args, **kwargs)

iir_filter_ffd_sptr_swigregister = _filter_swig.iir_filter_ffd_sptr_swigregister
iir_filter_ffd_sptr_swigregister(iir_filter_ffd_sptr)

iir_filter_ffd_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
iir_filter_ffd = iir_filter_ffd.make;

class iir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::iir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccc)> self) -> iir_filter_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccc)> self, iir_filter_ccc p) -> iir_filter_ccc_sptr
        """
        this = _filter_swig.new_iir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(iir_filter_ccc_sptr self) -> iir_filter_ccc"""
        return _filter_swig.iir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(iir_filter_ccc_sptr self, pmt_vector_cfloat fftaps, pmt_vector_cfloat fbtaps, bool oldstyle=True) -> iir_filter_ccc_sptr

        IIR filter with complex input, complex output, and complex taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccc_sptr self, pmt_vector_cfloat fftaps, pmt_vector_cfloat fbtaps)"""
        return _filter_swig.iir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(iir_filter_ccc_sptr self) -> unsigned int"""
        return _filter_swig.iir_filter_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(iir_filter_ccc_sptr self, int which, int delay)
        declare_sample_delay(iir_filter_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.iir_filter_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(iir_filter_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.iir_filter_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(iir_filter_ccc_sptr self) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(iir_filter_ccc_sptr self) -> double"""
        return _filter_swig.iir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(iir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(iir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(iir_filter_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.iir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(iir_filter_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.iir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(iir_filter_ccc_sptr self) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(iir_filter_ccc_sptr self, int m)"""
        return _filter_swig.iir_filter_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(iir_filter_ccc_sptr self)"""
        return _filter_swig.iir_filter_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(iir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(iir_filter_ccc_sptr self, int m)"""
        return _filter_swig.iir_filter_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(iir_filter_ccc_sptr self) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(iir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(iir_filter_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(iir_filter_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.iir_filter_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(iir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(iir_filter_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(iir_filter_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.iir_filter_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(iir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(iir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(iir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(iir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(iir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(iir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(iir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(iir_filter_ccc_sptr self) -> float"""
        return _filter_swig.iir_filter_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(iir_filter_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.iir_filter_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(iir_filter_ccc_sptr self)"""
        return _filter_swig.iir_filter_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(iir_filter_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.iir_filter_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(iir_filter_ccc_sptr self) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(iir_filter_ccc_sptr self) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(iir_filter_ccc_sptr self, int priority) -> int"""
        return _filter_swig.iir_filter_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(iir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(iir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(iir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(iir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(iir_filter_ccc_sptr self) -> long"""
        return _filter_swig.iir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(iir_filter_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.iir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(iir_filter_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.iir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(iir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(iir_filter_ccc_sptr self, std::string name)"""
        return _filter_swig.iir_filter_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(iir_filter_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.iir_filter_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(iir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(iir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(iir_filter_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccc_sptr_message_subscribers(self, *args, **kwargs)

iir_filter_ccc_sptr_swigregister = _filter_swig.iir_filter_ccc_sptr_swigregister
iir_filter_ccc_sptr_swigregister(iir_filter_ccc_sptr)

iir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
iir_filter_ccc = iir_filter_ccc.make;

class iir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::iir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccf)> self) -> iir_filter_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccf)> self, iir_filter_ccf p) -> iir_filter_ccf_sptr
        """
        this = _filter_swig.new_iir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(iir_filter_ccf_sptr self) -> iir_filter_ccf"""
        return _filter_swig.iir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(iir_filter_ccf_sptr self, pmt_vector_float fftaps, pmt_vector_float fbtaps, bool oldstyle=True) -> iir_filter_ccf_sptr

        IIR filter with complex input, complex output, and float taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccf_sptr self, pmt_vector_float fftaps, pmt_vector_float fbtaps)"""
        return _filter_swig.iir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(iir_filter_ccf_sptr self) -> unsigned int"""
        return _filter_swig.iir_filter_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(iir_filter_ccf_sptr self, int which, int delay)
        declare_sample_delay(iir_filter_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.iir_filter_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(iir_filter_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.iir_filter_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(iir_filter_ccf_sptr self) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(iir_filter_ccf_sptr self) -> double"""
        return _filter_swig.iir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(iir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(iir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(iir_filter_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.iir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(iir_filter_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.iir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(iir_filter_ccf_sptr self) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(iir_filter_ccf_sptr self, int m)"""
        return _filter_swig.iir_filter_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(iir_filter_ccf_sptr self)"""
        return _filter_swig.iir_filter_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(iir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(iir_filter_ccf_sptr self, int m)"""
        return _filter_swig.iir_filter_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(iir_filter_ccf_sptr self) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(iir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(iir_filter_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(iir_filter_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.iir_filter_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(iir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(iir_filter_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(iir_filter_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.iir_filter_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(iir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(iir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(iir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(iir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(iir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(iir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(iir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(iir_filter_ccf_sptr self) -> float"""
        return _filter_swig.iir_filter_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(iir_filter_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.iir_filter_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(iir_filter_ccf_sptr self)"""
        return _filter_swig.iir_filter_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(iir_filter_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.iir_filter_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(iir_filter_ccf_sptr self) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(iir_filter_ccf_sptr self) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(iir_filter_ccf_sptr self, int priority) -> int"""
        return _filter_swig.iir_filter_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(iir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(iir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(iir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(iir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(iir_filter_ccf_sptr self) -> long"""
        return _filter_swig.iir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(iir_filter_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.iir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(iir_filter_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.iir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(iir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(iir_filter_ccf_sptr self, std::string name)"""
        return _filter_swig.iir_filter_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(iir_filter_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.iir_filter_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(iir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(iir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(iir_filter_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccf_sptr_message_subscribers(self, *args, **kwargs)

iir_filter_ccf_sptr_swigregister = _filter_swig.iir_filter_ccf_sptr_swigregister
iir_filter_ccf_sptr_swigregister(iir_filter_ccf_sptr)

iir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
iir_filter_ccf = iir_filter_ccf.make;

class iir_filter_ccd_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::iir_filter_ccd)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccd)> self) -> iir_filter_ccd_sptr
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccd)> self, iir_filter_ccd p) -> iir_filter_ccd_sptr
        """
        this = _filter_swig.new_iir_filter_ccd_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(iir_filter_ccd_sptr self) -> iir_filter_ccd"""
        return _filter_swig.iir_filter_ccd_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccd_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(iir_filter_ccd_sptr self, pmt_vector_double fftaps, pmt_vector_double fbtaps, bool oldstyle=True) -> iir_filter_ccd_sptr

        IIR filter with complex input, complex output, and double taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccd_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccd_sptr self, pmt_vector_double fftaps, pmt_vector_double fbtaps)"""
        return _filter_swig.iir_filter_ccd_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(iir_filter_ccd_sptr self) -> unsigned int"""
        return _filter_swig.iir_filter_ccd_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(iir_filter_ccd_sptr self, int which, int delay)
        declare_sample_delay(iir_filter_ccd_sptr self, unsigned int delay)
        """
        return _filter_swig.iir_filter_ccd_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(iir_filter_ccd_sptr self, int which) -> unsigned int"""
        return _filter_swig.iir_filter_ccd_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(iir_filter_ccd_sptr self) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(iir_filter_ccd_sptr self) -> double"""
        return _filter_swig.iir_filter_ccd_sptr_relative_rate(self)

    def start(self):
        """start(iir_filter_ccd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccd_sptr_start(self)

    def stop(self):
        """stop(iir_filter_ccd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccd_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(iir_filter_ccd_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.iir_filter_ccd_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(iir_filter_ccd_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.iir_filter_ccd_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(iir_filter_ccd_sptr self) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(iir_filter_ccd_sptr self, int m)"""
        return _filter_swig.iir_filter_ccd_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(iir_filter_ccd_sptr self)"""
        return _filter_swig.iir_filter_ccd_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(iir_filter_ccd_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccd_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(iir_filter_ccd_sptr self, int m)"""
        return _filter_swig.iir_filter_ccd_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(iir_filter_ccd_sptr self) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(iir_filter_ccd_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccd_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(iir_filter_ccd_sptr self, long max_output_buffer)
        set_max_output_buffer(iir_filter_ccd_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.iir_filter_ccd_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(iir_filter_ccd_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccd_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(iir_filter_ccd_sptr self, long min_output_buffer)
        set_min_output_buffer(iir_filter_ccd_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.iir_filter_ccd_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(iir_filter_ccd_sptr self, int which) -> float
        pc_input_buffers_full(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(iir_filter_ccd_sptr self, int which) -> float
        pc_input_buffers_full_avg(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(iir_filter_ccd_sptr self, int which) -> float
        pc_input_buffers_full_var(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(iir_filter_ccd_sptr self, int which) -> float
        pc_output_buffers_full(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(iir_filter_ccd_sptr self, int which) -> float
        pc_output_buffers_full_avg(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(iir_filter_ccd_sptr self, int which) -> float
        pc_output_buffers_full_var(iir_filter_ccd_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccd_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(iir_filter_ccd_sptr self) -> float"""
        return _filter_swig.iir_filter_ccd_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(iir_filter_ccd_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.iir_filter_ccd_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(iir_filter_ccd_sptr self)"""
        return _filter_swig.iir_filter_ccd_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(iir_filter_ccd_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.iir_filter_ccd_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(iir_filter_ccd_sptr self) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(iir_filter_ccd_sptr self) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(iir_filter_ccd_sptr self, int priority) -> int"""
        return _filter_swig.iir_filter_ccd_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(iir_filter_ccd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccd_sptr_name(self)

    def symbol_name(self):
        """symbol_name(iir_filter_ccd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccd_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(iir_filter_ccd_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccd_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(iir_filter_ccd_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccd_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(iir_filter_ccd_sptr self) -> long"""
        return _filter_swig.iir_filter_ccd_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(iir_filter_ccd_sptr self) -> basic_block_sptr"""
        return _filter_swig.iir_filter_ccd_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(iir_filter_ccd_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.iir_filter_ccd_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(iir_filter_ccd_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccd_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(iir_filter_ccd_sptr self, std::string name)"""
        return _filter_swig.iir_filter_ccd_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(iir_filter_ccd_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.iir_filter_ccd_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(iir_filter_ccd_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccd_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(iir_filter_ccd_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccd_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(iir_filter_ccd_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccd_sptr_message_subscribers(self, *args, **kwargs)

iir_filter_ccd_sptr_swigregister = _filter_swig.iir_filter_ccd_sptr_swigregister
iir_filter_ccd_sptr_swigregister(iir_filter_ccd_sptr)

iir_filter_ccd_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
iir_filter_ccd = iir_filter_ccd.make;

class iir_filter_ccz_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::iir_filter_ccz)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccz)> self) -> iir_filter_ccz_sptr
        __init__(boost::shared_ptr<(gr::filter::iir_filter_ccz)> self, iir_filter_ccz p) -> iir_filter_ccz_sptr
        """
        this = _filter_swig.new_iir_filter_ccz_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(iir_filter_ccz_sptr self) -> iir_filter_ccz"""
        return _filter_swig.iir_filter_ccz_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_iir_filter_ccz_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(iir_filter_ccz_sptr self, pmt_vector_cdouble fftaps, pmt_vector_cdouble fbtaps, bool oldstyle=True) -> iir_filter_ccz_sptr

        IIR filter with complex input, complex output, and complex (double) taps.

        This filter uses the Direct Form I implementation, where  contains the feed-forward taps, and  the feedback ones.

         The old style of the IIR filter uses feedback taps that are negative of what most definitions use (scipy and Matlab among them). This parameter keeps using the old GNU Radio style and is set to TRUE by default. When taps generated from scipy, Matlab, or gr_filter_design, use the new style by setting this to FALSE.

        The input and output satisfy a difference equation of the form 

         
        y[n] - \sum_{k=1}^{M} a_k y[n-k] = \sum_{k=0}^{N} b_k x[n-k]


        with the corresponding rational system function 

         
        H(z) = \ frac{\sum_{k=0}^{M} b_k z^{-k}}{1 - \sum_{k=1}^{N} a_k z^{-k}}

        Constructor Specific Documentation:



        Args:
            fftaps : 
            fbtaps : 
            oldstyle : 
        """
        return _filter_swig.iir_filter_ccz_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(iir_filter_ccz_sptr self, pmt_vector_cdouble fftaps, pmt_vector_cdouble fbtaps)"""
        return _filter_swig.iir_filter_ccz_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(iir_filter_ccz_sptr self) -> unsigned int"""
        return _filter_swig.iir_filter_ccz_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(iir_filter_ccz_sptr self, int which, int delay)
        declare_sample_delay(iir_filter_ccz_sptr self, unsigned int delay)
        """
        return _filter_swig.iir_filter_ccz_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(iir_filter_ccz_sptr self, int which) -> unsigned int"""
        return _filter_swig.iir_filter_ccz_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(iir_filter_ccz_sptr self) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(iir_filter_ccz_sptr self) -> double"""
        return _filter_swig.iir_filter_ccz_sptr_relative_rate(self)

    def start(self):
        """start(iir_filter_ccz_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccz_sptr_start(self)

    def stop(self):
        """stop(iir_filter_ccz_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccz_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(iir_filter_ccz_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.iir_filter_ccz_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(iir_filter_ccz_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.iir_filter_ccz_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(iir_filter_ccz_sptr self) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(iir_filter_ccz_sptr self, int m)"""
        return _filter_swig.iir_filter_ccz_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(iir_filter_ccz_sptr self)"""
        return _filter_swig.iir_filter_ccz_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(iir_filter_ccz_sptr self) -> bool"""
        return _filter_swig.iir_filter_ccz_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(iir_filter_ccz_sptr self, int m)"""
        return _filter_swig.iir_filter_ccz_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(iir_filter_ccz_sptr self) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(iir_filter_ccz_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccz_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(iir_filter_ccz_sptr self, long max_output_buffer)
        set_max_output_buffer(iir_filter_ccz_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.iir_filter_ccz_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(iir_filter_ccz_sptr self, int i) -> long"""
        return _filter_swig.iir_filter_ccz_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(iir_filter_ccz_sptr self, long min_output_buffer)
        set_min_output_buffer(iir_filter_ccz_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.iir_filter_ccz_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(iir_filter_ccz_sptr self, int which) -> float
        pc_input_buffers_full(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(iir_filter_ccz_sptr self, int which) -> float
        pc_input_buffers_full_avg(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(iir_filter_ccz_sptr self, int which) -> float
        pc_input_buffers_full_var(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(iir_filter_ccz_sptr self, int which) -> float
        pc_output_buffers_full(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(iir_filter_ccz_sptr self, int which) -> float
        pc_output_buffers_full_avg(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(iir_filter_ccz_sptr self, int which) -> float
        pc_output_buffers_full_var(iir_filter_ccz_sptr self) -> pmt_vector_float
        """
        return _filter_swig.iir_filter_ccz_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(iir_filter_ccz_sptr self) -> float"""
        return _filter_swig.iir_filter_ccz_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(iir_filter_ccz_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.iir_filter_ccz_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(iir_filter_ccz_sptr self)"""
        return _filter_swig.iir_filter_ccz_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(iir_filter_ccz_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.iir_filter_ccz_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(iir_filter_ccz_sptr self) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(iir_filter_ccz_sptr self) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(iir_filter_ccz_sptr self, int priority) -> int"""
        return _filter_swig.iir_filter_ccz_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(iir_filter_ccz_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccz_sptr_name(self)

    def symbol_name(self):
        """symbol_name(iir_filter_ccz_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccz_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(iir_filter_ccz_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccz_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(iir_filter_ccz_sptr self) -> io_signature_sptr"""
        return _filter_swig.iir_filter_ccz_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(iir_filter_ccz_sptr self) -> long"""
        return _filter_swig.iir_filter_ccz_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(iir_filter_ccz_sptr self) -> basic_block_sptr"""
        return _filter_swig.iir_filter_ccz_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(iir_filter_ccz_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.iir_filter_ccz_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(iir_filter_ccz_sptr self) -> std::string"""
        return _filter_swig.iir_filter_ccz_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(iir_filter_ccz_sptr self, std::string name)"""
        return _filter_swig.iir_filter_ccz_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(iir_filter_ccz_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.iir_filter_ccz_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(iir_filter_ccz_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccz_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(iir_filter_ccz_sptr self) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccz_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(iir_filter_ccz_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.iir_filter_ccz_sptr_message_subscribers(self, *args, **kwargs)

iir_filter_ccz_sptr_swigregister = _filter_swig.iir_filter_ccz_sptr_swigregister
iir_filter_ccz_sptr_swigregister(iir_filter_ccz_sptr)

iir_filter_ccz_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
iir_filter_ccz = iir_filter_ccz.make;

class interp_fir_filter_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_ccc)> self) -> interp_fir_filter_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_ccc)> self, interp_fir_filter_ccc p) -> interp_fir_filter_ccc_sptr
        """
        this = _filter_swig.new_interp_fir_filter_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_ccc_sptr self) -> interp_fir_filter_ccc"""
        return _filter_swig.interp_fir_filter_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_ccc_sptr self, unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_ccc_sptr

        Interpolating FIR filter with gr_complex input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with gr_complex input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_ccc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_ccc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_ccc_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_ccc_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_ccc_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_ccc_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_ccc_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccc_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_ccc_sptr self)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_ccc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_ccc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_ccc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_ccc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_ccc_sptr self)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_ccc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_ccc_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_ccc_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_ccc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_ccc_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccc_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_ccc_sptr_swigregister = _filter_swig.interp_fir_filter_ccc_sptr_swigregister
interp_fir_filter_ccc_sptr_swigregister(interp_fir_filter_ccc_sptr)

interp_fir_filter_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_ccc = interp_fir_filter_ccc.make;

class interp_fir_filter_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_ccf)> self) -> interp_fir_filter_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_ccf)> self, interp_fir_filter_ccf p) -> interp_fir_filter_ccf_sptr
        """
        this = _filter_swig.new_interp_fir_filter_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_ccf_sptr self) -> interp_fir_filter_ccf"""
        return _filter_swig.interp_fir_filter_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_ccf_sptr self, unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_ccf_sptr

        Interpolating FIR filter with gr_complex input, gr_complex output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with gr_complex input, gr_complex output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_ccf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_ccf_sptr self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_ccf_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_ccf_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_ccf_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_ccf_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccf_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_ccf_sptr self)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_ccf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_ccf_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_ccf_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_ccf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_ccf_sptr self)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_ccf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_ccf_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_ccf_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_ccf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_ccf_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_ccf_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_ccf_sptr_swigregister = _filter_swig.interp_fir_filter_ccf_sptr_swigregister
interp_fir_filter_ccf_sptr_swigregister(interp_fir_filter_ccf_sptr)

interp_fir_filter_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_ccf = interp_fir_filter_ccf.make;

class interp_fir_filter_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fcc)> self) -> interp_fir_filter_fcc_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fcc)> self, interp_fir_filter_fcc p) -> interp_fir_filter_fcc_sptr
        """
        this = _filter_swig.new_interp_fir_filter_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_fcc_sptr self) -> interp_fir_filter_fcc"""
        return _filter_swig.interp_fir_filter_fcc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fcc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_fcc_sptr self, unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_fcc_sptr

        Interpolating FIR filter with float input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fcc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fcc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_fcc_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_fcc_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_fcc_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_fcc_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_fcc_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_fcc_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_fcc_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fcc_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_fcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_fcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_fcc_sptr self)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_fcc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_fcc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_fcc_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_fcc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_fcc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_fcc_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_fcc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_fcc_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_fcc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_fcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_fcc_sptr self)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_fcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_fcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_fcc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_fcc_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_fcc_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_fcc_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_fcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_fcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_fcc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_fcc_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_fcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_fcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_fcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_fcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fcc_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_fcc_sptr_swigregister = _filter_swig.interp_fir_filter_fcc_sptr_swigregister
interp_fir_filter_fcc_sptr_swigregister(interp_fir_filter_fcc_sptr)

interp_fir_filter_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_fcc = interp_fir_filter_fcc.make;

class interp_fir_filter_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fff)> self) -> interp_fir_filter_fff_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fff)> self, interp_fir_filter_fff p) -> interp_fir_filter_fff_sptr
        """
        this = _filter_swig.new_interp_fir_filter_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_fff_sptr self) -> interp_fir_filter_fff"""
        return _filter_swig.interp_fir_filter_fff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_fff_sptr self, unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fff_sptr

        Interpolating FIR filter with float input, float output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, float output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fff_sptr self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fff_sptr self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_fff_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_fff_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_fff_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_fff_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_fff_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_fff_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_fff_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_fff_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fff_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_fff_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_fff_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_fff_sptr self)"""
        return _filter_swig.interp_fir_filter_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_fff_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_fff_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_fff_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_fff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_fff_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_fff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_fff_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_fff_sptr self)"""
        return _filter_swig.interp_fir_filter_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_fff_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_fff_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_fff_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_fff_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_fff_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_fff_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_fff_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fff_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_fff_sptr_swigregister = _filter_swig.interp_fir_filter_fff_sptr_swigregister
interp_fir_filter_fff_sptr_swigregister(interp_fir_filter_fff_sptr)

interp_fir_filter_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_fff = interp_fir_filter_fff.make;

class interp_fir_filter_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fsf)> self) -> interp_fir_filter_fsf_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_fsf)> self, interp_fir_filter_fsf p) -> interp_fir_filter_fsf_sptr
        """
        this = _filter_swig.new_interp_fir_filter_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_fsf_sptr self) -> interp_fir_filter_fsf"""
        return _filter_swig.interp_fir_filter_fsf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_fsf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_fsf_sptr self, unsigned int interpolation, pmt_vector_float taps) -> interp_fir_filter_fsf_sptr

        Interpolating FIR filter with float input, short output and float taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type float. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with float input, short output, and float taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_fsf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_fsf_sptr self) -> pmt_vector_float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_fsf_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_fsf_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_fsf_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_fsf_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_fsf_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_fsf_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fsf_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_fsf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_fsf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_fsf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_fsf_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_fsf_sptr self)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_fsf_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_fsf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_fsf_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_fsf_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fsf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_fsf_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_fsf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_fsf_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_fsf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_fsf_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_fsf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_fsf_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_fsf_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_fsf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_fsf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_fsf_sptr self)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_fsf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_fsf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_fsf_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_fsf_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fsf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fsf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_fsf_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_fsf_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_fsf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_fsf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_fsf_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_fsf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_fsf_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_fsf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_fsf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_fsf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_fsf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_fsf_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_fsf_sptr_swigregister = _filter_swig.interp_fir_filter_fsf_sptr_swigregister
interp_fir_filter_fsf_sptr_swigregister(interp_fir_filter_fsf_sptr)

interp_fir_filter_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_fsf = interp_fir_filter_fsf.make;

class interp_fir_filter_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::interp_fir_filter_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_scc)> self) -> interp_fir_filter_scc_sptr
        __init__(boost::shared_ptr<(gr::filter::interp_fir_filter_scc)> self, interp_fir_filter_scc p) -> interp_fir_filter_scc_sptr
        """
        this = _filter_swig.new_interp_fir_filter_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(interp_fir_filter_scc_sptr self) -> interp_fir_filter_scc"""
        return _filter_swig.interp_fir_filter_scc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_interp_fir_filter_scc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(interp_fir_filter_scc_sptr self, unsigned int interpolation, pmt_vector_cfloat taps) -> interp_fir_filter_scc_sptr

        Interpolating FIR filter with short input, gr_complex output and gr_complex taps.

        The fir_filter_XXX blocks create finite impulse response (FIR) filters that perform the convolution in the time domain:



        The taps are a C++ vector (or Python list) of values of the type specified by the third letter in the block's suffix. For this block, the value is of type gr_complex. Taps can be created using the firdes or optfir tools.

        These versions of the filter can also act as up-samplers (or interpolators) by specifying an integer value for .

        Constructor Specific Documentation:

        Interpolating FIR filter with short input, gr_complex output, and gr_complex taps.

        Args:
            interpolation : set the integer interpolation rate
            taps : a vector/list of taps of type gr_complex
        """
        return _filter_swig.interp_fir_filter_scc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(interp_fir_filter_scc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(interp_fir_filter_scc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.interp_fir_filter_scc_sptr_taps(self)

    def history(self):
        """history(interp_fir_filter_scc_sptr self) -> unsigned int"""
        return _filter_swig.interp_fir_filter_scc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(interp_fir_filter_scc_sptr self, int which, int delay)
        declare_sample_delay(interp_fir_filter_scc_sptr self, unsigned int delay)
        """
        return _filter_swig.interp_fir_filter_scc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(interp_fir_filter_scc_sptr self, int which) -> unsigned int"""
        return _filter_swig.interp_fir_filter_scc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(interp_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(interp_fir_filter_scc_sptr self) -> double"""
        return _filter_swig.interp_fir_filter_scc_sptr_relative_rate(self)

    def start(self):
        """start(interp_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_scc_sptr_start(self)

    def stop(self):
        """stop(interp_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(interp_fir_filter_scc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.interp_fir_filter_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(interp_fir_filter_scc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.interp_fir_filter_scc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(interp_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(interp_fir_filter_scc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(interp_fir_filter_scc_sptr self)"""
        return _filter_swig.interp_fir_filter_scc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(interp_fir_filter_scc_sptr self) -> bool"""
        return _filter_swig.interp_fir_filter_scc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(interp_fir_filter_scc_sptr self, int m)"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(interp_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(interp_fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_scc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(interp_fir_filter_scc_sptr self, long max_output_buffer)
        set_max_output_buffer(interp_fir_filter_scc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.interp_fir_filter_scc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(interp_fir_filter_scc_sptr self, int i) -> long"""
        return _filter_swig.interp_fir_filter_scc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(interp_fir_filter_scc_sptr self, long min_output_buffer)
        set_min_output_buffer(interp_fir_filter_scc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.interp_fir_filter_scc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(interp_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(interp_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_avg(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(interp_fir_filter_scc_sptr self, int which) -> float
        pc_input_buffers_full_var(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(interp_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(interp_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_avg(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(interp_fir_filter_scc_sptr self, int which) -> float
        pc_output_buffers_full_var(interp_fir_filter_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.interp_fir_filter_scc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(interp_fir_filter_scc_sptr self) -> float"""
        return _filter_swig.interp_fir_filter_scc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(interp_fir_filter_scc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(interp_fir_filter_scc_sptr self)"""
        return _filter_swig.interp_fir_filter_scc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(interp_fir_filter_scc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.interp_fir_filter_scc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(interp_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(interp_fir_filter_scc_sptr self) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(interp_fir_filter_scc_sptr self, int priority) -> int"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(interp_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_scc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(interp_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_scc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(interp_fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(interp_fir_filter_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(interp_fir_filter_scc_sptr self) -> long"""
        return _filter_swig.interp_fir_filter_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(interp_fir_filter_scc_sptr self) -> basic_block_sptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(interp_fir_filter_scc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.interp_fir_filter_scc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(interp_fir_filter_scc_sptr self) -> std::string"""
        return _filter_swig.interp_fir_filter_scc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(interp_fir_filter_scc_sptr self, std::string name)"""
        return _filter_swig.interp_fir_filter_scc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(interp_fir_filter_scc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.interp_fir_filter_scc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(interp_fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(interp_fir_filter_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(interp_fir_filter_scc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.interp_fir_filter_scc_sptr_message_subscribers(self, *args, **kwargs)

interp_fir_filter_scc_sptr_swigregister = _filter_swig.interp_fir_filter_scc_sptr_swigregister
interp_fir_filter_scc_sptr_swigregister(interp_fir_filter_scc_sptr)

interp_fir_filter_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
interp_fir_filter_scc = interp_fir_filter_scc.make;

class pfb_arb_resampler_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccf)> self) -> pfb_arb_resampler_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccf)> self, pfb_arb_resampler_ccf p) -> pfb_arb_resampler_ccf_sptr
        """
        this = _filter_swig.new_pfb_arb_resampler_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_arb_resampler_ccf_sptr self) -> pfb_arb_resampler_ccf"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_arb_resampler_ccf_sptr self, float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccf_sptr

        Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccf to perform arbitrary resampling on the stream.

        Output sampling rate is  * input rate.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_ccf_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_ccf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_ccf_sptr self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_ccf_sptr self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_ccf_sptr self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_ccf_sptr self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_ccf_sptr self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_ccf_sptr self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_ccf_sptr self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_ccf_sptr self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_ccf_sptr self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_phase_offset(self, *args, **kwargs)

    def history(self):
        """history(pfb_arb_resampler_ccf_sptr self) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_arb_resampler_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_arb_resampler_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_arb_resampler_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_arb_resampler_ccf_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_arb_resampler_ccf_sptr self) -> double"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_arb_resampler_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_arb_resampler_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_arb_resampler_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_arb_resampler_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_arb_resampler_ccf_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_arb_resampler_ccf_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_arb_resampler_ccf_sptr self)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_arb_resampler_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_arb_resampler_ccf_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_arb_resampler_ccf_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_arb_resampler_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_arb_resampler_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_arb_resampler_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_arb_resampler_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_arb_resampler_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_arb_resampler_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_arb_resampler_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_arb_resampler_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_arb_resampler_ccf_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_arb_resampler_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_arb_resampler_ccf_sptr self)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_arb_resampler_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_arb_resampler_ccf_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_arb_resampler_ccf_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_arb_resampler_ccf_sptr self, int priority) -> int"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_arb_resampler_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_arb_resampler_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_arb_resampler_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_arb_resampler_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_arb_resampler_ccf_sptr self) -> long"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_arb_resampler_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_arb_resampler_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_arb_resampler_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_arb_resampler_ccf_sptr self, std::string name)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_arb_resampler_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_arb_resampler_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_arb_resampler_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_arb_resampler_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_arb_resampler_ccf_sptr_swigregister = _filter_swig.pfb_arb_resampler_ccf_sptr_swigregister
pfb_arb_resampler_ccf_sptr_swigregister(pfb_arb_resampler_ccf_sptr)

pfb_arb_resampler_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_arb_resampler_ccf = pfb_arb_resampler_ccf.make;

class pfb_arb_resampler_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccc)> self) -> pfb_arb_resampler_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_ccc)> self, pfb_arb_resampler_ccc p) -> pfb_arb_resampler_ccc_sptr
        """
        this = _filter_swig.new_pfb_arb_resampler_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_arb_resampler_ccc_sptr self) -> pfb_arb_resampler_ccc"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_arb_resampler_ccc_sptr self, float rate, pmt_vector_cfloat taps, unsigned int filter_size=32) -> pfb_arb_resampler_ccc_sptr

        Polyphase filterbank arbitrary resampler with gr_complex input, gr_complex output and gr_complex taps.

        This block takes in a signal stream and calls gr::filter::kernel::pfb_arb_resampler_ccc to perform arbitrary resampling on the stream.

        Output sampling rate is  * input rate.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of complex) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_ccc_sptr self, pmt_vector_cfloat taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_ccc_sptr self) -> gr_vector_vector_complexf

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_ccc_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_ccc_sptr self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_ccc_sptr self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_ccc_sptr self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_ccc_sptr self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_ccc_sptr self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_ccc_sptr self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_ccc_sptr self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_ccc_sptr self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_ccc_sptr self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_phase_offset(self, *args, **kwargs)

    def history(self):
        """history(pfb_arb_resampler_ccc_sptr self) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_arb_resampler_ccc_sptr self, int which, int delay)
        declare_sample_delay(pfb_arb_resampler_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_arb_resampler_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_arb_resampler_ccc_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_arb_resampler_ccc_sptr self) -> double"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_relative_rate(self)

    def start(self):
        """start(pfb_arb_resampler_ccc_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_start(self)

    def stop(self):
        """stop(pfb_arb_resampler_ccc_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_arb_resampler_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_arb_resampler_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_arb_resampler_ccc_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_arb_resampler_ccc_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_arb_resampler_ccc_sptr self)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_arb_resampler_ccc_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_arb_resampler_ccc_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_arb_resampler_ccc_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_arb_resampler_ccc_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_arb_resampler_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_arb_resampler_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_arb_resampler_ccc_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_arb_resampler_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_arb_resampler_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_input_buffers_full(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_output_buffers_full(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_arb_resampler_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_arb_resampler_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_arb_resampler_ccc_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_arb_resampler_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_arb_resampler_ccc_sptr self)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_arb_resampler_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_arb_resampler_ccc_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_arb_resampler_ccc_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_arb_resampler_ccc_sptr self, int priority) -> int"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_arb_resampler_ccc_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_arb_resampler_ccc_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_arb_resampler_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_arb_resampler_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_arb_resampler_ccc_sptr self) -> long"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_arb_resampler_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_arb_resampler_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_arb_resampler_ccc_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_arb_resampler_ccc_sptr self, std::string name)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_arb_resampler_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_arb_resampler_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_arb_resampler_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_arb_resampler_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_ccc_sptr_message_subscribers(self, *args, **kwargs)

pfb_arb_resampler_ccc_sptr_swigregister = _filter_swig.pfb_arb_resampler_ccc_sptr_swigregister
pfb_arb_resampler_ccc_sptr_swigregister(pfb_arb_resampler_ccc_sptr)

pfb_arb_resampler_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_arb_resampler_ccc = pfb_arb_resampler_ccc.make;

class pfb_arb_resampler_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_arb_resampler_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_fff)> self) -> pfb_arb_resampler_fff_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_arb_resampler_fff)> self, pfb_arb_resampler_fff p) -> pfb_arb_resampler_fff_sptr
        """
        this = _filter_swig.new_pfb_arb_resampler_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_arb_resampler_fff_sptr self) -> pfb_arb_resampler_fff"""
        return _filter_swig.pfb_arb_resampler_fff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_arb_resampler_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_arb_resampler_fff_sptr self, float rate, pmt_vector_float taps, unsigned int filter_size=32) -> pfb_arb_resampler_fff_sptr

        Polyphase filterbank arbitrary resampler with float input, float output and float taps.

        This block takes in a signal stream and performs arbitrary resampling. The resampling rate can be any real number . The resampling is done by constructing  filters where  is the interpolation rate. We then calculate  where .

        Using  and , we can perform rational resampling where  is a rational number close to the input rate  where we have  filters and we cycle through them as a polyphase filterbank with a stride of  so that .

        To get the arbitrary rate, we want to interpolate between two points. For each value out, we take an output from the current filter, , and the next filter  and then linearly interpolate between the two based on the real resampling rate we want.

        The linear interpolation only provides us with an approximation to the real sampling rate specified. The error is a quantization error between the two filters we used as our interpolation points. To this end, the number of filters, , used determines the quantization error; the larger , the smaller the noise. You can design for a specified noise floor by setting the filter size (parameters ). The size defaults to 32 filters, which is about as good as most implementations need.

        The trick with designing this filter is in how to specify the taps of the prototype filter. Like the PFB interpolator, the taps are specified using the interpolated filter rate. In this case, that rate is the input sample rate multiplied by the number of filters in the filterbank, which is also the interpolation rate. All other values should be relative to this rate.

        For example, for a 32-filter arbitrary resampler and using the GNU Radio's firdes utility to build the filter, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as the interpolation rate ().



        The theory behind this block can be found in Chapter 7.5 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank arbitray resampler.

        Args:
            rate : (float) Specifies the resampling rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the filter_size sampling rate.
            filter_size : (unsigned int) The number of filters in the filter bank. This is directly related to quantization noise introduced during the resampling. Defaults to 32 filters.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_arb_resampler_fff_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_arb_resampler_fff_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_arb_resampler_fff_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_print_taps(self)

    def set_rate(self, *args, **kwargs):
        """
        set_rate(pfb_arb_resampler_fff_sptr self, float rate)

        Sets the resampling rate of the block.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_rate(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """
        set_phase(pfb_arb_resampler_fff_sptr self, float ph)

        Sets the current phase offset in radians (0 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_phase(self, *args, **kwargs)

    def phase(self):
        """
        phase(pfb_arb_resampler_fff_sptr self) -> float

        Gets the current phase of the resampler in radians (2 to 2pi).
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_phase(self)

    def taps_per_filter(self):
        """
        taps_per_filter(pfb_arb_resampler_fff_sptr self) -> unsigned int

        Gets the number of taps per filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_taps_per_filter(self)

    def interpolation_rate(self):
        """
        interpolation_rate(pfb_arb_resampler_fff_sptr self) -> unsigned int

        Gets the interpolation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_interpolation_rate(self)

    def decimation_rate(self):
        """
        decimation_rate(pfb_arb_resampler_fff_sptr self) -> unsigned int

        Gets the decimation rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_decimation_rate(self)

    def fractional_rate(self):
        """
        fractional_rate(pfb_arb_resampler_fff_sptr self) -> float

        Gets the fractional rate of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_fractional_rate(self)

    def group_delay(self):
        """
        group_delay(pfb_arb_resampler_fff_sptr self) -> int

        Get the group delay of the filter.
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_group_delay(self)

    def phase_offset(self, *args, **kwargs):
        """
        phase_offset(pfb_arb_resampler_fff_sptr self, float freq, float fs) -> float

        Calculates the phase offset expected by a sine wave of frequency  and sampling rate  (assuming input sine wave has 0 degree phase).
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_phase_offset(self, *args, **kwargs)

    def history(self):
        """history(pfb_arb_resampler_fff_sptr self) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_arb_resampler_fff_sptr self, int which, int delay)
        declare_sample_delay(pfb_arb_resampler_fff_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_arb_resampler_fff_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_arb_resampler_fff_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_arb_resampler_fff_sptr self) -> double"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_relative_rate(self)

    def start(self):
        """start(pfb_arb_resampler_fff_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_start(self)

    def stop(self):
        """stop(pfb_arb_resampler_fff_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_arb_resampler_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_arb_resampler_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_arb_resampler_fff_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_arb_resampler_fff_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_arb_resampler_fff_sptr self)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_arb_resampler_fff_sptr self) -> bool"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_arb_resampler_fff_sptr self, int m)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_arb_resampler_fff_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_arb_resampler_fff_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_arb_resampler_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_arb_resampler_fff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_arb_resampler_fff_sptr self, int i) -> long"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_arb_resampler_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_arb_resampler_fff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_input_buffers_full(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_output_buffers_full(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_arb_resampler_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_arb_resampler_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_arb_resampler_fff_sptr self) -> float"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_arb_resampler_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_arb_resampler_fff_sptr self)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_arb_resampler_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_arb_resampler_fff_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_arb_resampler_fff_sptr self) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_arb_resampler_fff_sptr self, int priority) -> int"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_arb_resampler_fff_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_arb_resampler_fff_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_arb_resampler_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_arb_resampler_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_arb_resampler_fff_sptr self) -> long"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_arb_resampler_fff_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_arb_resampler_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_arb_resampler_fff_sptr self) -> std::string"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_arb_resampler_fff_sptr self, std::string name)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_arb_resampler_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_arb_resampler_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_arb_resampler_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_arb_resampler_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_arb_resampler_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_arb_resampler_fff_sptr_message_subscribers(self, *args, **kwargs)

pfb_arb_resampler_fff_sptr_swigregister = _filter_swig.pfb_arb_resampler_fff_sptr_swigregister
pfb_arb_resampler_fff_sptr_swigregister(pfb_arb_resampler_fff_sptr)

pfb_arb_resampler_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_arb_resampler_fff = pfb_arb_resampler_fff.make;

class pfb_channelizer_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_channelizer_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_channelizer_ccf)> self) -> pfb_channelizer_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_channelizer_ccf)> self, pfb_channelizer_ccf p) -> pfb_channelizer_ccf_sptr
        """
        this = _filter_swig.new_pfb_channelizer_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_channelizer_ccf_sptr self) -> pfb_channelizer_ccf"""
        return _filter_swig.pfb_channelizer_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_channelizer_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_channelizer_ccf_sptr self, unsigned int numchans, pmt_vector_float taps, float oversample_rate) -> pfb_channelizer_ccf_sptr

        Polyphase filterbank channelizer with gr_complex input, gr_complex output and float taps.

        This block takes in complex inputs and channelizes it to  channels of equal bandwidth. Each of the resulting channels is decimated to the new rate that is the input sampling rate  divided by the number of channels, .

        The PFB channelizer code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        Each filter operates using the gr::blocks::fir_filter_XXX classs of GNU Radio, which takes the input stream at  and performs the inner product calculation to  where  is the number of filter taps. To efficiently handle this in the GNU Radio structure, each filter input must come from its own input stream. So the channelizer must be provided with  streams where the input stream has been deinterleaved. This is most easily done using the gr::blocks::stream_to_streams block.

        The output is then produced as a vector, where index  in the vector is the next sample from the th channel. This is most easily handled by sending the output to a gr::blocks::vector_to_streams block to handle the conversion and passing  streams out.

        The input and output formatting is done using a hier_block2 called pfb_channelizer_ccf. This can take in a single stream and outputs  streams based on the behavior described above.

        The filter's taps should be based on the input sampling rate.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity. 

        The filter output can also be overs ampled. The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.

        For example, for 6 channels with fs = 6000 Hz, the normal rate is 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz. A rate of 6/5 = 1.2, so the output rate would be 1200 Hz.

        The theory behind this block can be found in Chapter 6 of the following book.



        When dealing with oversampling, the above book is still a good reference along with this paper:

        Constructor Specific Documentation:

        Build the polyphase filterbank decimator. 
        For example, for 6 channels with fs = 6000 Hz, the normal rateis 6000/6 = 1000 Hz. Allowable oversampling rates are 6/6, 6/5, 6/4, 6/3, 6/2, and 6/1 where the output sample rate of a 6/1 oversample ratio is 6000 Hz, or 6 times the normal 1000 Hz.

        Args:
            numchans : (unsigned integer) Specifies the number of channels
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            oversample_rate : (float) The over sampling rate is the ratio of the the actual output sampling rate to the normal output sampling rate. It must be rationally related to the number of channels as N/i for i in [1,N], which gives an outputsample rate of [fs/N, fs] where fs is the input sample rate and N is the number of channels.
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_channelizer_ccf_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(pfb_channelizer_ccf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_print_taps(self)

    def taps(self):
        """
        taps(pfb_channelizer_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(pfb_channelizer_ccf_sptr self, std::vector< int,std::allocator< int > > const & map)

        Set the channel map. Channels are numbers as:  <---------------- 0 -----------------> freq

        So output stream 0 comes from channel 0, etc. Setting a new channel map allows the user to specify which channel in frequency he/she wants to got to which output stream.

        The map should have the same number of elements as the number of output connections from the block. The minimum value of the map is 0 (for the 0th channel) and the maximum number is N-1 where N is the number of channels.

        We specify M as the number of output connections made where M <= N, so only M out of N channels are driven to an output stream. The number of items in the channel map should be at least M long. If there are more channels specified, any value in the map over M-1 will be ignored. If the size of the map is less than M the behavior is unknown (we don't wish to check every entry into the work function).

        This means that if the channelizer is splitting the signal up into N channels but only M channels are specified in the map (where M <= N), then M output streams must be connected and the map and the channel numbers used must be less than N-1. Output channel number can be reused, too. By default, the map is [0...M-1] with M = N.
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(pfb_channelizer_ccf_sptr self) -> std::vector< int,std::allocator< int > >

        Gets the current channel map.
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_channel_map(self)

    def history(self):
        """history(pfb_channelizer_ccf_sptr self) -> unsigned int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_channelizer_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_channelizer_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_channelizer_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_channelizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_channelizer_ccf_sptr self) -> double"""
        return _filter_swig.pfb_channelizer_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_channelizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_channelizer_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_channelizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_channelizer_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_channelizer_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_channelizer_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_channelizer_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_channelizer_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_channelizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_channelizer_ccf_sptr self, int m)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_channelizer_ccf_sptr self)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_channelizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_channelizer_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_channelizer_ccf_sptr self, int m)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_channelizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_channelizer_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_channelizer_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_channelizer_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_channelizer_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_channelizer_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_channelizer_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_channelizer_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_channelizer_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_channelizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_channelizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_channelizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_channelizer_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_channelizer_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_channelizer_ccf_sptr self)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_channelizer_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_channelizer_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_channelizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_channelizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_channelizer_ccf_sptr self, int priority) -> int"""
        return _filter_swig.pfb_channelizer_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_channelizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_channelizer_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_channelizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_channelizer_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_channelizer_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_channelizer_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_channelizer_ccf_sptr self) -> long"""
        return _filter_swig.pfb_channelizer_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_channelizer_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_channelizer_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_channelizer_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_channelizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_channelizer_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_channelizer_ccf_sptr self, std::string name)"""
        return _filter_swig.pfb_channelizer_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_channelizer_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_channelizer_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_channelizer_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_channelizer_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_channelizer_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_channelizer_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_channelizer_ccf_sptr_swigregister = _filter_swig.pfb_channelizer_ccf_sptr_swigregister
pfb_channelizer_ccf_sptr_swigregister(pfb_channelizer_ccf_sptr)

pfb_channelizer_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_channelizer_ccf = pfb_channelizer_ccf.make;

class pfb_decimator_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_decimator_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_decimator_ccf)> self) -> pfb_decimator_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_decimator_ccf)> self, pfb_decimator_ccf p) -> pfb_decimator_ccf_sptr
        """
        this = _filter_swig.new_pfb_decimator_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_decimator_ccf_sptr self) -> pfb_decimator_ccf"""
        return _filter_swig.pfb_decimator_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_decimator_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_decimator_ccf_sptr self, unsigned int decim, pmt_vector_float taps, unsigned int channel, bool use_fft_rotator=True, 
            bool use_fft_filters=True) -> pfb_decimator_ccf_sptr

        Polyphase filterbank bandpass decimator with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and performs interger down- sampling (decimation) with a polyphase filterbank. The first input is the integer specifying how much to decimate by. The second input is a vector (Python list) of floating-point taps of the prototype filter. The third input specifies the channel to extract. By default, the zeroth channel is used, which is the baseband channel (first Nyquist zone).

        The  parameter specifies which channel to use since this class is capable of bandpass decimation. Given a complex input stream at a sampling rate of  and a decimation rate of , the input frequency domain is split into  channels that represent the Nyquist zones. Using the polyphase filterbank, we can select any one of these channels to decimate.

        The output signal will be the basebanded and decimated signal from that channel. This concept is very similar to the PFB channelizer (see gr::filter::pfb_channelizer_ccf) where only a single channel is extracted at a time.

        The filter's taps should be based on the sampling rate before decimation.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, , and the filter window function (a Blackman-harris window in this case). The first input is the gain of the filter, which we specify here as unity.



        The PFB decimator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/decim) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        The theory behind this block can be found in Chapter 6 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank decimator.

        Args:
            decim : (unsigned integer) Specifies the decimation rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            channel : (unsigned integer) Selects the channel to return [default=0].
            use_fft_rotator : (bool) Rotate channels using FFT method instead of exp(phi). For larger values of , the FFT method will perform better. Generally, this value of  is small (~5), but could be architecture-specific (Default: true).
            use_fft_filters : (bool) Use FFT filters (fast convolution) instead of FIR filters. FFT filters perform better for larger numbers of taps but is architecture-specific (Default: true).
        """
        return _filter_swig.pfb_decimator_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_decimator_ccf_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_decimator_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_decimator_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_decimator_ccf_sptr_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_decimator_ccf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_decimator_ccf_sptr_print_taps(self)

    def set_channel(self, *args, **kwargs):
        """set_channel(pfb_decimator_ccf_sptr self, unsigned int const channel)"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_channel(self, *args, **kwargs)

    def history(self):
        """history(pfb_decimator_ccf_sptr self) -> unsigned int"""
        return _filter_swig.pfb_decimator_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_decimator_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_decimator_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_decimator_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_decimator_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_decimator_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_decimator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_decimator_ccf_sptr self) -> double"""
        return _filter_swig.pfb_decimator_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_decimator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_decimator_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_decimator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_decimator_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_decimator_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_decimator_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_decimator_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_decimator_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_decimator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_decimator_ccf_sptr self, int m)"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_decimator_ccf_sptr self)"""
        return _filter_swig.pfb_decimator_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_decimator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_decimator_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_decimator_ccf_sptr self, int m)"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_decimator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_decimator_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_decimator_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_decimator_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_decimator_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_decimator_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_decimator_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_decimator_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_decimator_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_decimator_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_decimator_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_decimator_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_decimator_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_decimator_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_decimator_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_decimator_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_decimator_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_decimator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_decimator_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_decimator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_decimator_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_decimator_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_decimator_ccf_sptr self)"""
        return _filter_swig.pfb_decimator_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_decimator_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_decimator_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_decimator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_decimator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_decimator_ccf_sptr self, int priority) -> int"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_decimator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_decimator_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_decimator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_decimator_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_decimator_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_decimator_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_decimator_ccf_sptr self) -> long"""
        return _filter_swig.pfb_decimator_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_decimator_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_decimator_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_decimator_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_decimator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_decimator_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_decimator_ccf_sptr self, std::string name)"""
        return _filter_swig.pfb_decimator_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_decimator_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_decimator_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_decimator_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_decimator_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_decimator_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_decimator_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_decimator_ccf_sptr_swigregister = _filter_swig.pfb_decimator_ccf_sptr_swigregister
pfb_decimator_ccf_sptr_swigregister(pfb_decimator_ccf_sptr)

pfb_decimator_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_decimator_ccf = pfb_decimator_ccf.make;

class pfb_interpolator_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_interpolator_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_interpolator_ccf)> self) -> pfb_interpolator_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_interpolator_ccf)> self, pfb_interpolator_ccf p) -> pfb_interpolator_ccf_sptr
        """
        this = _filter_swig.new_pfb_interpolator_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_interpolator_ccf_sptr self) -> pfb_interpolator_ccf"""
        return _filter_swig.pfb_interpolator_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_interpolator_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_interpolator_ccf_sptr self, unsigned int interp, pmt_vector_float taps) -> pfb_interpolator_ccf_sptr

        Polyphase filterbank interpolator with gr_complex input, gr_complex output and float taps.

        This block takes in a signal stream and performs interger up- sampling (interpolation) with a polyphase filterbank. The first input is the integer specifying how much to interpolate by. The second input is a vector (Python list) of floating-point taps of the prototype filter.

        The filter's taps should be based on the interpolation rate specified. That is, the bandwidth specified is relative to the bandwidth after interpolation.

        For example, using the GNU Radio's firdes utility to building filters, we build a low-pass filter with a sampling rate of , a 3-dB bandwidth of  and a transition bandwidth of . We can also specify the out-of-band attenuation to use, ATT, and the filter window function (a Blackman-harris window in this case). The first input is the gain, which is also specified as the interpolation rate so that the output levels are the same as the input (this creates an overall increase in power).



        The PFB interpolator code takes the taps generated above and builds a set of filters. The set contains  number of filters and each filter contains ceil(taps.size()/interp) number of taps. Each tap from the filter prototype is sequentially inserted into the next filter. When all of the input taps are used, the remaining filters in the filterbank are filled out with 0's to make sure each filter has the same number of taps.

        The theory behind this block can be found in Chapter 7.1 of the following book.

        Constructor Specific Documentation:

        Build the polyphase filterbank interpolator.

        Args:
            interp : (unsigned integer) Specifies the interpolation rate to use
            taps : (vector/list of floats) The prototype filter to populate the filterbank. The taps should be generated at the interpolated sampling rate.
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_interpolator_ccf_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_interpolator_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_taps(self)

    def print_taps(self):
        """
        print_taps(pfb_interpolator_ccf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_print_taps(self)

    def history(self):
        """history(pfb_interpolator_ccf_sptr self) -> unsigned int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_interpolator_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_interpolator_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_interpolator_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_interpolator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_interpolator_ccf_sptr self) -> double"""
        return _filter_swig.pfb_interpolator_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_interpolator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_interpolator_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_interpolator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_interpolator_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_interpolator_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_interpolator_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_interpolator_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_interpolator_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_interpolator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_interpolator_ccf_sptr self, int m)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_interpolator_ccf_sptr self)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_interpolator_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_interpolator_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_interpolator_ccf_sptr self, int m)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_interpolator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_interpolator_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_interpolator_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_interpolator_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_interpolator_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_interpolator_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_interpolator_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_interpolator_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_interpolator_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_interpolator_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_interpolator_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_interpolator_ccf_sptr self) -> float"""
        return _filter_swig.pfb_interpolator_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_interpolator_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_interpolator_ccf_sptr self)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_interpolator_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_interpolator_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_interpolator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_interpolator_ccf_sptr self) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_interpolator_ccf_sptr self, int priority) -> int"""
        return _filter_swig.pfb_interpolator_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_interpolator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_interpolator_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_interpolator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_interpolator_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_interpolator_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_interpolator_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_interpolator_ccf_sptr self) -> long"""
        return _filter_swig.pfb_interpolator_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_interpolator_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_interpolator_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_interpolator_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_interpolator_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_interpolator_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_interpolator_ccf_sptr self, std::string name)"""
        return _filter_swig.pfb_interpolator_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_interpolator_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_interpolator_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_interpolator_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_interpolator_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_interpolator_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_interpolator_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_interpolator_ccf_sptr_swigregister = _filter_swig.pfb_interpolator_ccf_sptr_swigregister
pfb_interpolator_ccf_sptr_swigregister(pfb_interpolator_ccf_sptr)

pfb_interpolator_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_interpolator_ccf = pfb_interpolator_ccf.make;

class pfb_synthesizer_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::pfb_synthesizer_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::pfb_synthesizer_ccf)> self) -> pfb_synthesizer_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::pfb_synthesizer_ccf)> self, pfb_synthesizer_ccf p) -> pfb_synthesizer_ccf_sptr
        """
        this = _filter_swig.new_pfb_synthesizer_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_synthesizer_ccf_sptr self) -> pfb_synthesizer_ccf"""
        return _filter_swig.pfb_synthesizer_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_pfb_synthesizer_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_synthesizer_ccf_sptr self, unsigned int numchans, pmt_vector_float taps, bool twox=False) -> pfb_synthesizer_ccf_sptr

        Polyphase synthesis filterbank with gr_complex input, gr_complex output and float taps.

        The PFB sythesis filterbank combines multiple baseband signals into a single channelized signal. Each input stream is, essentially, modulated onto an output channel according the the channel mapping (see set_channel_map for details).

        Setting this filterbank up means selecting the number of output channels, the prototype filter, and whether to handle channels at 2x the sample rate (this is generally used only for reconstruction filtering).

        The number of channels sets the maximum number of channels to use, but not all input streams must be connected. For M total channels, we can connect inputs 0 to N where N < M-1. Because of the way GNU Radio handles stream connections, we must connect the channels consecutively, and so we must use the set_channel_map if the desired output channels are not the same as the the default mapping. This features gives us the flexibility to output to any given channel. Generally, we try to not use the channels at the edge of the spectrum to avoid issues with filtering and roll-off of the transmitter or receiver.

        When using the 2x sample rate mode, we specify the number of channels that will be used. However, the actual output signal will be twice this number of channels. This is mainly important to know when setting the channel map. For M channels, the channel mapping can specy from 0 to 2M-1 channels to output onto.

        For more details about this and the concepts of reconstruction filtering, see:

        Constructor Specific Documentation:

        Build the polyphase synthesis filterbank.

        Args:
            numchans : (unsigned integer) Specifies the number of channels
            taps : (vector/list of floats) The prototype filter to populate the filterbank.
            twox : (bool) use 2x oversampling or not (default is no)
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_synthesizer_ccf_sptr self, pmt_vector_float taps)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_taps(self, *args, **kwargs)

    def print_taps(self):
        """
        print_taps(pfb_synthesizer_ccf_sptr self)

        Print all of the filterbank taps to screen.
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_print_taps(self)

    def taps(self):
        """
        taps(pfb_synthesizer_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Return a vector<vector<>> of the filterbank taps
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_taps(self)

    def set_channel_map(self, *args, **kwargs):
        """
        set_channel_map(pfb_synthesizer_ccf_sptr self, std::vector< int,std::allocator< int > > const & map)

        Set the channel map. Channels are numbers as: N/2+1 | ... | N-1 | 0 | 1 | 2 | ... | N/2 <---------------- 0 -----------------> freq

        So input stream 0 goes to channel 0, etc. Setting a new channel map allows the user to specify where in frequency he/she wants the input stream to go. This is especially useful to avoid putting signals into the channels on the edge of the spectrum which can either wrap around (in the case of odd number of channels) and be affected by filter rolloff in the transmitter.

        The map must be at least the number of streams being sent to the block. Less and the algorithm will not have enough data to properly setup the buffers. Any more channels specified will be ignored.
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_channel_map(self, *args, **kwargs)

    def channel_map(self):
        """
        channel_map(pfb_synthesizer_ccf_sptr self) -> std::vector< int,std::allocator< int > >

        Gets the current channel map.
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_channel_map(self)

    def history(self):
        """history(pfb_synthesizer_ccf_sptr self) -> unsigned int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_synthesizer_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_synthesizer_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_synthesizer_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_synthesizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_synthesizer_ccf_sptr self) -> double"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_synthesizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_synthesizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_synthesizer_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_synthesizer_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_synthesizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_synthesizer_ccf_sptr self, int m)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_synthesizer_ccf_sptr self)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_synthesizer_ccf_sptr self) -> bool"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_synthesizer_ccf_sptr self, int m)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_synthesizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_synthesizer_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_synthesizer_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_synthesizer_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_synthesizer_ccf_sptr self, int i) -> long"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_synthesizer_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_synthesizer_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_synthesizer_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_synthesizer_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_synthesizer_ccf_sptr self) -> float"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_synthesizer_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_synthesizer_ccf_sptr self)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_synthesizer_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_synthesizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_synthesizer_ccf_sptr self) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_synthesizer_ccf_sptr self, int priority) -> int"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_synthesizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_synthesizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_synthesizer_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_synthesizer_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_synthesizer_ccf_sptr self) -> long"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_synthesizer_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_synthesizer_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_synthesizer_ccf_sptr self) -> std::string"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_synthesizer_ccf_sptr self, std::string name)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_synthesizer_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.pfb_synthesizer_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_synthesizer_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_synthesizer_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_synthesizer_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.pfb_synthesizer_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_synthesizer_ccf_sptr_swigregister = _filter_swig.pfb_synthesizer_ccf_sptr_swigregister
pfb_synthesizer_ccf_sptr_swigregister(pfb_synthesizer_ccf_sptr)

pfb_synthesizer_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_synthesizer_ccf = pfb_synthesizer_ccf.make;

class rational_resampler_base_ccc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_ccc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_ccc)> self) -> rational_resampler_base_ccc_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_ccc)> self, rational_resampler_base_ccc p) -> rational_resampler_base_ccc_sptr
        """
        this = _filter_swig.new_rational_resampler_base_ccc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_ccc_sptr self) -> rational_resampler_base_ccc"""
        return _filter_swig.rational_resampler_base_ccc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_ccc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_ccc_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_ccc_sptr

        Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_ccc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_ccc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_ccc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_ccc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_ccc_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_ccc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_ccc_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_ccc_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_ccc_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_ccc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_ccc_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_ccc_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_ccc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccc_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_ccc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_ccc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_ccc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_ccc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_ccc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_ccc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_ccc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_ccc_sptr self)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_ccc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_ccc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_ccc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_ccc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_ccc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_ccc_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_ccc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_ccc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_ccc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_ccc_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_ccc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_ccc_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_ccc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_ccc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_ccc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_ccc_sptr self)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_ccc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_ccc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_ccc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_ccc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_ccc_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_ccc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_ccc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_ccc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_ccc_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_ccc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_ccc_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_ccc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_ccc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_ccc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_ccc_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_ccc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_ccc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_ccc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_ccc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_ccc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccc_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_ccc_sptr_swigregister = _filter_swig.rational_resampler_base_ccc_sptr_swigregister
rational_resampler_base_ccc_sptr_swigregister(rational_resampler_base_ccc_sptr)

rational_resampler_base_ccc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_ccc = rational_resampler_base_ccc.make;

class rational_resampler_base_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_ccf)> self) -> rational_resampler_base_ccf_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_ccf)> self, rational_resampler_base_ccf p) -> rational_resampler_base_ccf_sptr
        """
        this = _filter_swig.new_rational_resampler_base_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_ccf_sptr self) -> rational_resampler_base_ccf"""
        return _filter_swig.rational_resampler_base_ccf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_ccf_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_ccf_sptr

        Rational Resampling Polyphase FIR filter with gr_complex input, gr_complex output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_ccf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_ccf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_ccf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_ccf_sptr self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_ccf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_ccf_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_ccf_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_ccf_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_ccf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_ccf_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_ccf_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_ccf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccf_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_ccf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_ccf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_ccf_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_ccf_sptr self)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_ccf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_ccf_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_ccf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_ccf_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_ccf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_ccf_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_ccf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_ccf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_ccf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_ccf_sptr self)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_ccf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_ccf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_ccf_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_ccf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_ccf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_ccf_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_ccf_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_ccf_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_ccf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_ccf_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_ccf_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_ccf_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_ccf_sptr_swigregister = _filter_swig.rational_resampler_base_ccf_sptr_swigregister
rational_resampler_base_ccf_sptr_swigregister(rational_resampler_base_ccf_sptr)

rational_resampler_base_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_ccf = rational_resampler_base_ccf.make;

class rational_resampler_base_fcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_fcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fcc)> self) -> rational_resampler_base_fcc_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fcc)> self, rational_resampler_base_fcc p) -> rational_resampler_base_fcc_sptr
        """
        this = _filter_swig.new_rational_resampler_base_fcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_fcc_sptr self) -> rational_resampler_base_fcc"""
        return _filter_swig.rational_resampler_base_fcc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fcc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_fcc_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_fcc_sptr

        Rational Resampling Polyphase FIR filter with float input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_fcc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fcc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fcc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fcc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_fcc_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_fcc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_fcc_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_fcc_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_fcc_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_fcc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_fcc_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_fcc_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_fcc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fcc_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_fcc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_fcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_fcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_fcc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_fcc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_fcc_sptr self)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_fcc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_fcc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_fcc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_fcc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_fcc_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_fcc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_fcc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_fcc_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_fcc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_fcc_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_fcc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_fcc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_fcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_fcc_sptr self)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_fcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_fcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_fcc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_fcc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_fcc_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_fcc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_fcc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_fcc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_fcc_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_fcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_fcc_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_fcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_fcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_fcc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_fcc_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_fcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_fcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_fcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_fcc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_fcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fcc_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_fcc_sptr_swigregister = _filter_swig.rational_resampler_base_fcc_sptr_swigregister
rational_resampler_base_fcc_sptr_swigregister(rational_resampler_base_fcc_sptr)

rational_resampler_base_fcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_fcc = rational_resampler_base_fcc.make;

class rational_resampler_base_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fff)> self) -> rational_resampler_base_fff_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fff)> self, rational_resampler_base_fff p) -> rational_resampler_base_fff_sptr
        """
        this = _filter_swig.new_rational_resampler_base_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_fff_sptr self) -> rational_resampler_base_fff"""
        return _filter_swig.rational_resampler_base_fff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_fff_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fff_sptr

        Rational Resampling Polyphase FIR filter with float input, float output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fff_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_fff_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fff_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fff_sptr self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fff_sptr self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_fff_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_fff_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_fff_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_fff_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_fff_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_fff_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_fff_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_fff_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_fff_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fff_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_fff_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_fff_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_fff_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_fff_sptr self)"""
        return _filter_swig.rational_resampler_base_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_fff_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_fff_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_fff_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_fff_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_fff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_fff_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_fff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_fff_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_fff_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_fff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_fff_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_fff_sptr self)"""
        return _filter_swig.rational_resampler_base_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_fff_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_fff_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_fff_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_fff_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_fff_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_fff_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_fff_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_fff_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_fff_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_fff_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_fff_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fff_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_fff_sptr_swigregister = _filter_swig.rational_resampler_base_fff_sptr_swigregister
rational_resampler_base_fff_sptr_swigregister(rational_resampler_base_fff_sptr)

rational_resampler_base_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_fff = rational_resampler_base_fff.make;

class rational_resampler_base_fsf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_fsf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fsf)> self) -> rational_resampler_base_fsf_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_fsf)> self, rational_resampler_base_fsf p) -> rational_resampler_base_fsf_sptr
        """
        this = _filter_swig.new_rational_resampler_base_fsf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_fsf_sptr self) -> rational_resampler_base_fsf"""
        return _filter_swig.rational_resampler_base_fsf_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_fsf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_fsf_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_float taps) -> rational_resampler_base_fsf_sptr

        Rational Resampling Polyphase FIR filter with float input, short output and float taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_fsf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_fsf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_fsf_sptr self, pmt_vector_float taps)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_fsf_sptr self) -> pmt_vector_float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_fsf_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_fsf_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_fsf_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_fsf_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_fsf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_fsf_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_fsf_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_fsf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fsf_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_fsf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fsf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_fsf_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fsf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_fsf_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_fsf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_fsf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_fsf_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_fsf_sptr self)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_fsf_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_fsf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_fsf_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_fsf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_fsf_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fsf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_fsf_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_fsf_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_fsf_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_fsf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_fsf_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_fsf_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_fsf_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_fsf_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_fsf_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_fsf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_fsf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_fsf_sptr self)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_fsf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_fsf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_fsf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_fsf_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_fsf_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_fsf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fsf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_fsf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fsf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_fsf_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_fsf_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_fsf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_fsf_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_fsf_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_fsf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_fsf_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_fsf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_fsf_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_fsf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_fsf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_fsf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_fsf_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_fsf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_fsf_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_fsf_sptr_swigregister = _filter_swig.rational_resampler_base_fsf_sptr_swigregister
rational_resampler_base_fsf_sptr_swigregister(rational_resampler_base_fsf_sptr)

rational_resampler_base_fsf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_fsf = rational_resampler_base_fsf.make;

class rational_resampler_base_scc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::rational_resampler_base_scc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_scc)> self) -> rational_resampler_base_scc_sptr
        __init__(boost::shared_ptr<(gr::filter::rational_resampler_base_scc)> self, rational_resampler_base_scc p) -> rational_resampler_base_scc_sptr
        """
        this = _filter_swig.new_rational_resampler_base_scc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(rational_resampler_base_scc_sptr self) -> rational_resampler_base_scc"""
        return _filter_swig.rational_resampler_base_scc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_rational_resampler_base_scc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(rational_resampler_base_scc_sptr self, unsigned int interpolation, unsigned int decimation, pmt_vector_cfloat taps) -> rational_resampler_base_scc_sptr

        Rational Resampling Polyphase FIR filter with short input, gr_complex output and gr_complex taps.

        Constructor Specific Documentation:



        Args:
            interpolation : 
            decimation : 
            taps : 
        """
        return _filter_swig.rational_resampler_base_scc_sptr_make(self, *args, **kwargs)

    def interpolation(self):
        """interpolation(rational_resampler_base_scc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_sptr_interpolation(self)

    def decimation(self):
        """decimation(rational_resampler_base_scc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_sptr_decimation(self)

    def set_taps(self, *args, **kwargs):
        """set_taps(rational_resampler_base_scc_sptr self, pmt_vector_cfloat taps)"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(rational_resampler_base_scc_sptr self) -> pmt_vector_cfloat"""
        return _filter_swig.rational_resampler_base_scc_sptr_taps(self)

    def history(self):
        """history(rational_resampler_base_scc_sptr self) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(rational_resampler_base_scc_sptr self, int which, int delay)
        declare_sample_delay(rational_resampler_base_scc_sptr self, unsigned int delay)
        """
        return _filter_swig.rational_resampler_base_scc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(rational_resampler_base_scc_sptr self, int which) -> unsigned int"""
        return _filter_swig.rational_resampler_base_scc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(rational_resampler_base_scc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(rational_resampler_base_scc_sptr self) -> double"""
        return _filter_swig.rational_resampler_base_scc_sptr_relative_rate(self)

    def start(self):
        """start(rational_resampler_base_scc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_scc_sptr_start(self)

    def stop(self):
        """stop(rational_resampler_base_scc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_scc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(rational_resampler_base_scc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.rational_resampler_base_scc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(rational_resampler_base_scc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.rational_resampler_base_scc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(rational_resampler_base_scc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(rational_resampler_base_scc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(rational_resampler_base_scc_sptr self)"""
        return _filter_swig.rational_resampler_base_scc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(rational_resampler_base_scc_sptr self) -> bool"""
        return _filter_swig.rational_resampler_base_scc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(rational_resampler_base_scc_sptr self, int m)"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(rational_resampler_base_scc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(rational_resampler_base_scc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_scc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(rational_resampler_base_scc_sptr self, long max_output_buffer)
        set_max_output_buffer(rational_resampler_base_scc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.rational_resampler_base_scc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(rational_resampler_base_scc_sptr self, int i) -> long"""
        return _filter_swig.rational_resampler_base_scc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(rational_resampler_base_scc_sptr self, long min_output_buffer)
        set_min_output_buffer(rational_resampler_base_scc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.rational_resampler_base_scc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(rational_resampler_base_scc_sptr self, int which) -> float
        pc_input_buffers_full(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(rational_resampler_base_scc_sptr self, int which) -> float
        pc_input_buffers_full_avg(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(rational_resampler_base_scc_sptr self, int which) -> float
        pc_input_buffers_full_var(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(rational_resampler_base_scc_sptr self, int which) -> float
        pc_output_buffers_full(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(rational_resampler_base_scc_sptr self, int which) -> float
        pc_output_buffers_full_avg(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(rational_resampler_base_scc_sptr self, int which) -> float
        pc_output_buffers_full_var(rational_resampler_base_scc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.rational_resampler_base_scc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(rational_resampler_base_scc_sptr self) -> float"""
        return _filter_swig.rational_resampler_base_scc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(rational_resampler_base_scc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(rational_resampler_base_scc_sptr self)"""
        return _filter_swig.rational_resampler_base_scc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(rational_resampler_base_scc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.rational_resampler_base_scc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(rational_resampler_base_scc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(rational_resampler_base_scc_sptr self) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(rational_resampler_base_scc_sptr self, int priority) -> int"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(rational_resampler_base_scc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_scc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(rational_resampler_base_scc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_scc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(rational_resampler_base_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(rational_resampler_base_scc_sptr self) -> io_signature_sptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(rational_resampler_base_scc_sptr self) -> long"""
        return _filter_swig.rational_resampler_base_scc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(rational_resampler_base_scc_sptr self) -> basic_block_sptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(rational_resampler_base_scc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.rational_resampler_base_scc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(rational_resampler_base_scc_sptr self) -> std::string"""
        return _filter_swig.rational_resampler_base_scc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(rational_resampler_base_scc_sptr self, std::string name)"""
        return _filter_swig.rational_resampler_base_scc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(rational_resampler_base_scc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.rational_resampler_base_scc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(rational_resampler_base_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(rational_resampler_base_scc_sptr self) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(rational_resampler_base_scc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.rational_resampler_base_scc_sptr_message_subscribers(self, *args, **kwargs)

rational_resampler_base_scc_sptr_swigregister = _filter_swig.rational_resampler_base_scc_sptr_swigregister
rational_resampler_base_scc_sptr_swigregister(rational_resampler_base_scc_sptr)

rational_resampler_base_scc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
rational_resampler_base_scc = rational_resampler_base_scc.make;

class single_pole_iir_filter_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::single_pole_iir_filter_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::single_pole_iir_filter_cc)> self) -> single_pole_iir_filter_cc_sptr
        __init__(boost::shared_ptr<(gr::filter::single_pole_iir_filter_cc)> self, single_pole_iir_filter_cc p) -> single_pole_iir_filter_cc_sptr
        """
        this = _filter_swig.new_single_pole_iir_filter_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(single_pole_iir_filter_cc_sptr self) -> single_pole_iir_filter_cc"""
        return _filter_swig.single_pole_iir_filter_cc_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_single_pole_iir_filter_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(single_pole_iir_filter_cc_sptr self, double alpha, unsigned int vlen=1) -> single_pole_iir_filter_cc_sptr

        single pole IIR filter with complex input, complex output

        The input and output satisfy a difference equation of the form 

         
        y[n] - (1-alpha) y[n-1] = alpha x[n]


        with the corresponding rational system function 

         
        H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


        Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

        Constructor Specific Documentation:



        Args:
            alpha : 
            vlen : 
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(single_pole_iir_filter_cc_sptr self, double alpha)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(single_pole_iir_filter_cc_sptr self) -> unsigned int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(single_pole_iir_filter_cc_sptr self, int which, int delay)
        declare_sample_delay(single_pole_iir_filter_cc_sptr self, unsigned int delay)
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(single_pole_iir_filter_cc_sptr self, int which) -> unsigned int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(single_pole_iir_filter_cc_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(single_pole_iir_filter_cc_sptr self) -> double"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_relative_rate(self)

    def start(self):
        """start(single_pole_iir_filter_cc_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_start(self)

    def stop(self):
        """stop(single_pole_iir_filter_cc_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(single_pole_iir_filter_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(single_pole_iir_filter_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(single_pole_iir_filter_cc_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(single_pole_iir_filter_cc_sptr self, int m)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(single_pole_iir_filter_cc_sptr self)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(single_pole_iir_filter_cc_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(single_pole_iir_filter_cc_sptr self, int m)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(single_pole_iir_filter_cc_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(single_pole_iir_filter_cc_sptr self, int i) -> long"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(single_pole_iir_filter_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(single_pole_iir_filter_cc_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(single_pole_iir_filter_cc_sptr self, int i) -> long"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(single_pole_iir_filter_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(single_pole_iir_filter_cc_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_input_buffers_full(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_output_buffers_full(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(single_pole_iir_filter_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(single_pole_iir_filter_cc_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(single_pole_iir_filter_cc_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(single_pole_iir_filter_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(single_pole_iir_filter_cc_sptr self)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(single_pole_iir_filter_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(single_pole_iir_filter_cc_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(single_pole_iir_filter_cc_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(single_pole_iir_filter_cc_sptr self, int priority) -> int"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(single_pole_iir_filter_cc_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(single_pole_iir_filter_cc_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(single_pole_iir_filter_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(single_pole_iir_filter_cc_sptr self) -> io_signature_sptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(single_pole_iir_filter_cc_sptr self) -> long"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(single_pole_iir_filter_cc_sptr self) -> basic_block_sptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(single_pole_iir_filter_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(single_pole_iir_filter_cc_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(single_pole_iir_filter_cc_sptr self, std::string name)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(single_pole_iir_filter_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.single_pole_iir_filter_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(single_pole_iir_filter_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(single_pole_iir_filter_cc_sptr self) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(single_pole_iir_filter_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_cc_sptr_message_subscribers(self, *args, **kwargs)

single_pole_iir_filter_cc_sptr_swigregister = _filter_swig.single_pole_iir_filter_cc_sptr_swigregister
single_pole_iir_filter_cc_sptr_swigregister(single_pole_iir_filter_cc_sptr)

single_pole_iir_filter_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
single_pole_iir_filter_cc = single_pole_iir_filter_cc.make;

class single_pole_iir_filter_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::filter::single_pole_iir_filter_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::filter::single_pole_iir_filter_ff)> self) -> single_pole_iir_filter_ff_sptr
        __init__(boost::shared_ptr<(gr::filter::single_pole_iir_filter_ff)> self, single_pole_iir_filter_ff p) -> single_pole_iir_filter_ff_sptr
        """
        this = _filter_swig.new_single_pole_iir_filter_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(single_pole_iir_filter_ff_sptr self) -> single_pole_iir_filter_ff"""
        return _filter_swig.single_pole_iir_filter_ff_sptr___deref__(self)

    __swig_destroy__ = _filter_swig.delete_single_pole_iir_filter_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(single_pole_iir_filter_ff_sptr self, double alpha, unsigned int vlen=1) -> single_pole_iir_filter_ff_sptr

        single pole IIR filter with float input, float output

        The input and output satisfy a difference equation of the form 

         
        y[n] - (1-alpha) y[n-1] = alpha x[n]


        with the corresponding rational system function 

         
        H(z) = \ frac{alpha}{1 - (1-alpha) z^{-1}}


        Note that some texts define the system function with a + in the denominator. If you're using that convention, you'll need to negate the feedback tap.

        Constructor Specific Documentation:



        Args:
            alpha : 
            vlen : 
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(single_pole_iir_filter_ff_sptr self, double alpha)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_taps(self, *args, **kwargs)

    def history(self):
        """history(single_pole_iir_filter_ff_sptr self) -> unsigned int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(single_pole_iir_filter_ff_sptr self, int which, int delay)
        declare_sample_delay(single_pole_iir_filter_ff_sptr self, unsigned int delay)
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(single_pole_iir_filter_ff_sptr self, int which) -> unsigned int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(single_pole_iir_filter_ff_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(single_pole_iir_filter_ff_sptr self) -> double"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_relative_rate(self)

    def start(self):
        """start(single_pole_iir_filter_ff_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_start(self)

    def stop(self):
        """stop(single_pole_iir_filter_ff_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(single_pole_iir_filter_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(single_pole_iir_filter_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(single_pole_iir_filter_ff_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(single_pole_iir_filter_ff_sptr self, int m)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(single_pole_iir_filter_ff_sptr self)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(single_pole_iir_filter_ff_sptr self) -> bool"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(single_pole_iir_filter_ff_sptr self, int m)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(single_pole_iir_filter_ff_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(single_pole_iir_filter_ff_sptr self, int i) -> long"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(single_pole_iir_filter_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(single_pole_iir_filter_ff_sptr self, int port, long max_output_buffer)
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(single_pole_iir_filter_ff_sptr self, int i) -> long"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(single_pole_iir_filter_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(single_pole_iir_filter_ff_sptr self, int port, long min_output_buffer)
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_input_buffers_full(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_output_buffers_full(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(single_pole_iir_filter_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(single_pole_iir_filter_ff_sptr self) -> pmt_vector_float
        """
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(single_pole_iir_filter_ff_sptr self) -> float"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(single_pole_iir_filter_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(single_pole_iir_filter_ff_sptr self)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(single_pole_iir_filter_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(single_pole_iir_filter_ff_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(single_pole_iir_filter_ff_sptr self) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(single_pole_iir_filter_ff_sptr self, int priority) -> int"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(single_pole_iir_filter_ff_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(single_pole_iir_filter_ff_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(single_pole_iir_filter_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(single_pole_iir_filter_ff_sptr self) -> io_signature_sptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(single_pole_iir_filter_ff_sptr self) -> long"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(single_pole_iir_filter_ff_sptr self) -> basic_block_sptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(single_pole_iir_filter_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(single_pole_iir_filter_ff_sptr self) -> std::string"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(single_pole_iir_filter_ff_sptr self, std::string name)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(single_pole_iir_filter_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _filter_swig.single_pole_iir_filter_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(single_pole_iir_filter_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(single_pole_iir_filter_ff_sptr self) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(single_pole_iir_filter_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _filter_swig.single_pole_iir_filter_ff_sptr_message_subscribers(self, *args, **kwargs)

single_pole_iir_filter_ff_sptr_swigregister = _filter_swig.single_pole_iir_filter_ff_sptr_swigregister
single_pole_iir_filter_ff_sptr_swigregister(single_pole_iir_filter_ff_sptr)

single_pole_iir_filter_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
single_pole_iir_filter_ff = single_pole_iir_filter_ff.make;



