# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_digital_swig', [dirname(__file__)])
        except ImportError:
            import _digital_swig
            return _digital_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_digital_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _digital_swig = swig_import_helper()
    del swig_import_helper
else:
    import _digital_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _digital_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _digital_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _digital_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _digital_swig.high_res_timer_epoch()
class cpm(object):
    """Proxy of C++ gr::analog::cpm class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    LRC = _digital_swig.cpm_LRC
    LSRC = _digital_swig.cpm_LSRC
    LREC = _digital_swig.cpm_LREC
    TFM = _digital_swig.cpm_TFM
    GAUSSIAN = _digital_swig.cpm_GAUSSIAN
    GENERIC = _digital_swig.cpm_GENERIC
    def phase_response(*args, **kwargs):
        """phase_response(gr::analog::cpm::cpm_type type, unsigned int samples_per_sym, unsigned int L, double beta=0.3) -> pmt_vector_float"""
        return _digital_swig.cpm_phase_response(*args, **kwargs)

    phase_response = staticmethod(phase_response)
    def __init__(self): 
        """__init__(gr::analog::cpm self) -> cpm"""
        this = _digital_swig.new_cpm()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_cpm
    __del__ = lambda self : None;
cpm_swigregister = _digital_swig.cpm_swigregister
cpm_swigregister(cpm)

def cpm_phase_response(*args, **kwargs):
  """cpm_phase_response(gr::analog::cpm::cpm_type type, unsigned int samples_per_sym, unsigned int L, double beta=0.3) -> pmt_vector_float"""
  return _digital_swig.cpm_phase_response(*args, **kwargs)

class control_loop(object):
    """Proxy of C++ gr::blocks::control_loop class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(gr::blocks::control_loop self) -> control_loop
        __init__(gr::blocks::control_loop self, float loop_bw, float max_freq, float min_freq) -> control_loop
        """
        this = _digital_swig.new_control_loop(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_control_loop
    __del__ = lambda self : None;
    def update_gains(self):
        """update_gains(control_loop self)"""
        return _digital_swig.control_loop_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(control_loop self, float error)"""
        return _digital_swig.control_loop_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(control_loop self)"""
        return _digital_swig.control_loop_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(control_loop self)"""
        return _digital_swig.control_loop_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(control_loop self, float bw)"""
        return _digital_swig.control_loop_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(control_loop self, float df)"""
        return _digital_swig.control_loop_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(control_loop self, float alpha)"""
        return _digital_swig.control_loop_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(control_loop self, float beta)"""
        return _digital_swig.control_loop_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(control_loop self, float freq)"""
        return _digital_swig.control_loop_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(control_loop self, float phase)"""
        return _digital_swig.control_loop_set_phase(self, *args, **kwargs)

    def set_max_freq(self, *args, **kwargs):
        """set_max_freq(control_loop self, float freq)"""
        return _digital_swig.control_loop_set_max_freq(self, *args, **kwargs)

    def set_min_freq(self, *args, **kwargs):
        """set_min_freq(control_loop self, float freq)"""
        return _digital_swig.control_loop_set_min_freq(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(control_loop self) -> float"""
        return _digital_swig.control_loop_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(control_loop self) -> float"""
        return _digital_swig.control_loop_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(control_loop self) -> float"""
        return _digital_swig.control_loop_get_alpha(self)

    def get_beta(self):
        """get_beta(control_loop self) -> float"""
        return _digital_swig.control_loop_get_beta(self)

    def get_frequency(self):
        """get_frequency(control_loop self) -> float"""
        return _digital_swig.control_loop_get_frequency(self)

    def get_phase(self):
        """get_phase(control_loop self) -> float"""
        return _digital_swig.control_loop_get_phase(self)

    def get_max_freq(self):
        """get_max_freq(control_loop self) -> float"""
        return _digital_swig.control_loop_get_max_freq(self)

    def get_min_freq(self):
        """get_min_freq(control_loop self) -> float"""
        return _digital_swig.control_loop_get_min_freq(self)

control_loop_swigregister = _digital_swig.control_loop_swigregister
control_loop_swigregister(control_loop)

class additive_scrambler_bb(object):
    """
    Scramble an input stream using an LFSR.

    This block scrambles up to 8 bits per byte of the input data stream, starting at the LSB.

    The scrambler works by XORing the incoming bit stream by the output of the LFSR. Optionally, after  bits have been processed, the shift register is reset to the  value. This allows processing fixed length vectors of samples.

    Alternatively, the LFSR can be reset using a reset tag to scramble variable length vectors. However, it cannot be reset between bytes.

    For details on configuring the LFSR, see gr::digital::lfsr.

    Constructor Specific Documentation:

    Create additive scrambler.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
        count : Number of bytes after which shift register is reset, 0=never
        bits_per_byte : Number of bits per byte
        reset_tag_key : When a tag with this key is detected, the shift register is reset (when this is set, count is ignored!)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int mask, int seed, int len, int count=0, int bits_per_byte=1, std::string const & reset_tag_key="") -> additive_scrambler_bb_sptr

        Scramble an input stream using an LFSR.

        This block scrambles up to 8 bits per byte of the input data stream, starting at the LSB.

        The scrambler works by XORing the incoming bit stream by the output of the LFSR. Optionally, after  bits have been processed, the shift register is reset to the  value. This allows processing fixed length vectors of samples.

        Alternatively, the LFSR can be reset using a reset tag to scramble variable length vectors. However, it cannot be reset between bytes.

        For details on configuring the LFSR, see gr::digital::lfsr.

        Constructor Specific Documentation:

        Create additive scrambler.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
            count : Number of bytes after which shift register is reset, 0=never
            bits_per_byte : Number of bits per byte
            reset_tag_key : When a tag with this key is detected, the shift register is reset (when this is set, count is ignored!)
        """
        return _digital_swig.additive_scrambler_bb_make(*args, **kwargs)

    make = staticmethod(make)
    def mask(self):
        """mask(additive_scrambler_bb self) -> int"""
        return _digital_swig.additive_scrambler_bb_mask(self)

    def seed(self):
        """seed(additive_scrambler_bb self) -> int"""
        return _digital_swig.additive_scrambler_bb_seed(self)

    def len(self):
        """len(additive_scrambler_bb self) -> int"""
        return _digital_swig.additive_scrambler_bb_len(self)

    def count(self):
        """count(additive_scrambler_bb self) -> int"""
        return _digital_swig.additive_scrambler_bb_count(self)

    def bits_per_byte(self):
        """bits_per_byte(additive_scrambler_bb self) -> int"""
        return _digital_swig.additive_scrambler_bb_bits_per_byte(self)

    __swig_destroy__ = _digital_swig.delete_additive_scrambler_bb
    __del__ = lambda self : None;
additive_scrambler_bb_swigregister = _digital_swig.additive_scrambler_bb_swigregister
additive_scrambler_bb_swigregister(additive_scrambler_bb)

def additive_scrambler_bb_make(*args, **kwargs):
  """
    additive_scrambler_bb_make(int mask, int seed, int len, int count=0, int bits_per_byte=1, std::string const & reset_tag_key="") -> additive_scrambler_bb_sptr

    Scramble an input stream using an LFSR.

    This block scrambles up to 8 bits per byte of the input data stream, starting at the LSB.

    The scrambler works by XORing the incoming bit stream by the output of the LFSR. Optionally, after  bits have been processed, the shift register is reset to the  value. This allows processing fixed length vectors of samples.

    Alternatively, the LFSR can be reset using a reset tag to scramble variable length vectors. However, it cannot be reset between bytes.

    For details on configuring the LFSR, see gr::digital::lfsr.

    Constructor Specific Documentation:

    Create additive scrambler.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
        count : Number of bytes after which shift register is reset, 0=never
        bits_per_byte : Number of bits per byte
        reset_tag_key : When a tag with this key is detected, the shift register is reset (when this is set, count is ignored!)
    """
  return _digital_swig.additive_scrambler_bb_make(*args, **kwargs)

class binary_slicer_fb(object):
    """
    Slice float binary symbol producing 1 bit output.

    Constructor Specific Documentation:

    Make binary symbol slicer block.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> binary_slicer_fb_sptr

        Slice float binary symbol producing 1 bit output.

        Constructor Specific Documentation:

        Make binary symbol slicer block.
        """
        return _digital_swig.binary_slicer_fb_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_binary_slicer_fb
    __del__ = lambda self : None;
binary_slicer_fb_swigregister = _digital_swig.binary_slicer_fb_swigregister
binary_slicer_fb_swigregister(binary_slicer_fb)

def binary_slicer_fb_make():
  """
    binary_slicer_fb_make() -> binary_slicer_fb_sptr

    Slice float binary symbol producing 1 bit output.

    Constructor Specific Documentation:

    Make binary symbol slicer block.
    """
  return _digital_swig.binary_slicer_fb_make()

class chunks_to_symbols_bc(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_bc_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_bc_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_bc self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_bc self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_bc_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_bc
    __del__ = lambda self : None;
chunks_to_symbols_bc_swigregister = _digital_swig.chunks_to_symbols_bc_swigregister
chunks_to_symbols_bc_swigregister(chunks_to_symbols_bc)

def chunks_to_symbols_bc_make(*args, **kwargs):
  """
    chunks_to_symbols_bc_make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_bc_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_bc_make(*args, **kwargs)

class chunks_to_symbols_bf(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_bf_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_bf_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_bf self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_bf self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_bf_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_bf
    __del__ = lambda self : None;
chunks_to_symbols_bf_swigregister = _digital_swig.chunks_to_symbols_bf_swigregister
chunks_to_symbols_bf_swigregister(chunks_to_symbols_bf)

def chunks_to_symbols_bf_make(*args, **kwargs):
  """
    chunks_to_symbols_bf_make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_bf_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_bf_make(*args, **kwargs)

class chunks_to_symbols_ic(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_ic_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_ic_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_ic self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_ic self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_ic_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_ic
    __del__ = lambda self : None;
chunks_to_symbols_ic_swigregister = _digital_swig.chunks_to_symbols_ic_swigregister
chunks_to_symbols_ic_swigregister(chunks_to_symbols_ic)

def chunks_to_symbols_ic_make(*args, **kwargs):
  """
    chunks_to_symbols_ic_make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_ic_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_ic_make(*args, **kwargs)

class chunks_to_symbols_if(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_if_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_if_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_if self) -> int"""
        return _digital_swig.chunks_to_symbols_if_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_if self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_if_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_if
    __del__ = lambda self : None;
chunks_to_symbols_if_swigregister = _digital_swig.chunks_to_symbols_if_swigregister
chunks_to_symbols_if_swigregister(chunks_to_symbols_if)

def chunks_to_symbols_if_make(*args, **kwargs):
  """
    chunks_to_symbols_if_make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_if_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_if_make(*args, **kwargs)

class chunks_to_symbols_sc(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_sc_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_sc_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_sc self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_sc self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_sc_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_sc
    __del__ = lambda self : None;
chunks_to_symbols_sc_swigregister = _digital_swig.chunks_to_symbols_sc_swigregister
chunks_to_symbols_sc_swigregister(chunks_to_symbols_sc)

def chunks_to_symbols_sc_make(*args, **kwargs):
  """
    chunks_to_symbols_sc_make(pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_sc_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_sc_make(*args, **kwargs)

class chunks_to_symbols_sf(object):
    """
    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_sf_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_sf_make(*args, **kwargs)

    make = staticmethod(make)
    def D(self):
        """D(chunks_to_symbols_sf self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_sf self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_sf_symbol_table(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_sf
    __del__ = lambda self : None;
chunks_to_symbols_sf_swigregister = _digital_swig.chunks_to_symbols_sf_swigregister
chunks_to_symbols_sf_swigregister(chunks_to_symbols_sf)

def chunks_to_symbols_sf_make(*args, **kwargs):
  """
    chunks_to_symbols_sf_make(pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_sf_sptr

    Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

    The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

    Constructor Specific Documentation:

    Make a chunks-to-symbols block.

    Args:
        symbol_table : list that maps chunks to symbols.
        D : dimension of table.
    """
  return _digital_swig.chunks_to_symbols_sf_make(*args, **kwargs)

class clock_recovery_mm_cc(object):
    """
    Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    The complex version here is based on: Modified Mueller and Muller clock recovery circuit:

    G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
       and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

    Constructor Specific Documentation:

    Make a M&M clock recovery block.

    Args:
        omega : Initial estimate of samples per symbol
        gain_omega : Gain setting for omega update loop
        mu : Initial estimate of phase of sample
        gain_mu : Gain setting for mu update loop
        omega_relative_limit : limit on omega
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_cc_sptr

        Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

        This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

        The complex version here is based on: Modified Mueller and Muller clock recovery circuit:

        G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
           and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

        Constructor Specific Documentation:

        Make a M&M clock recovery block.

        Args:
            omega : Initial estimate of samples per symbol
            gain_omega : Gain setting for omega update loop
            mu : Initial estimate of phase of sample
            gain_mu : Gain setting for mu update loop
            omega_relative_limit : limit on omega
        """
        return _digital_swig.clock_recovery_mm_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(clock_recovery_mm_cc self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_mu(self)

    def omega(self):
        """omega(clock_recovery_mm_cc self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_omega(self)

    def gain_mu(self):
        """gain_mu(clock_recovery_mm_cc self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_gain_mu(self)

    def gain_omega(self):
        """gain_omega(clock_recovery_mm_cc self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_gain_omega(self)

    def set_verbose(self, *args, **kwargs):
        """set_verbose(clock_recovery_mm_cc self, bool verbose)"""
        return _digital_swig.clock_recovery_mm_cc_set_verbose(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(clock_recovery_mm_cc self, float gain_mu)"""
        return _digital_swig.clock_recovery_mm_cc_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(clock_recovery_mm_cc self, float gain_omega)"""
        return _digital_swig.clock_recovery_mm_cc_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(clock_recovery_mm_cc self, float mu)"""
        return _digital_swig.clock_recovery_mm_cc_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(clock_recovery_mm_cc self, float omega)"""
        return _digital_swig.clock_recovery_mm_cc_set_omega(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_clock_recovery_mm_cc
    __del__ = lambda self : None;
clock_recovery_mm_cc_swigregister = _digital_swig.clock_recovery_mm_cc_swigregister
clock_recovery_mm_cc_swigregister(clock_recovery_mm_cc)

def clock_recovery_mm_cc_make(*args, **kwargs):
  """
    clock_recovery_mm_cc_make(float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_cc_sptr

    Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    The complex version here is based on: Modified Mueller and Muller clock recovery circuit:

    G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
       and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

    Constructor Specific Documentation:

    Make a M&M clock recovery block.

    Args:
        omega : Initial estimate of samples per symbol
        gain_omega : Gain setting for omega update loop
        mu : Initial estimate of phase of sample
        gain_mu : Gain setting for mu update loop
        omega_relative_limit : limit on omega
    """
  return _digital_swig.clock_recovery_mm_cc_make(*args, **kwargs)

class clock_recovery_mm_ff(object):
    """
    Mueller and M?ller (M&M) based clock recovery block with float input, float output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    See "Digital Communication Receivers: Synchronization, Channel
    Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.

    Constructor Specific Documentation:

    Make a M&M clock recovery block.

    Args:
        omega : Initial estimate of samples per symbol
        gain_omega : Gain setting for omega update loop
        mu : Initial estimate of phase of sample
        gain_mu : Gain setting for mu update loop
        omega_relative_limit : limit on omega
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_ff_sptr

        Mueller and M?ller (M&M) based clock recovery block with float input, float output.

        This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

        See "Digital Communication Receivers: Synchronization, Channel
        Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.

        Constructor Specific Documentation:

        Make a M&M clock recovery block.

        Args:
            omega : Initial estimate of samples per symbol
            gain_omega : Gain setting for omega update loop
            mu : Initial estimate of phase of sample
            gain_mu : Gain setting for mu update loop
            omega_relative_limit : limit on omega
        """
        return _digital_swig.clock_recovery_mm_ff_make(*args, **kwargs)

    make = staticmethod(make)
    def mu(self):
        """mu(clock_recovery_mm_ff self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_mu(self)

    def omega(self):
        """omega(clock_recovery_mm_ff self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_omega(self)

    def gain_mu(self):
        """gain_mu(clock_recovery_mm_ff self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_gain_mu(self)

    def gain_omega(self):
        """gain_omega(clock_recovery_mm_ff self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_gain_omega(self)

    def set_verbose(self, *args, **kwargs):
        """set_verbose(clock_recovery_mm_ff self, bool verbose)"""
        return _digital_swig.clock_recovery_mm_ff_set_verbose(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(clock_recovery_mm_ff self, float gain_mu)"""
        return _digital_swig.clock_recovery_mm_ff_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(clock_recovery_mm_ff self, float gain_omega)"""
        return _digital_swig.clock_recovery_mm_ff_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(clock_recovery_mm_ff self, float mu)"""
        return _digital_swig.clock_recovery_mm_ff_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(clock_recovery_mm_ff self, float omega)"""
        return _digital_swig.clock_recovery_mm_ff_set_omega(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_clock_recovery_mm_ff
    __del__ = lambda self : None;
clock_recovery_mm_ff_swigregister = _digital_swig.clock_recovery_mm_ff_swigregister
clock_recovery_mm_ff_swigregister(clock_recovery_mm_ff)

def clock_recovery_mm_ff_make(*args, **kwargs):
  """
    clock_recovery_mm_ff_make(float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_ff_sptr

    Mueller and M?ller (M&M) based clock recovery block with float input, float output.

    This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

    See "Digital Communication Receivers: Synchronization, Channel
    Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.

    Constructor Specific Documentation:

    Make a M&M clock recovery block.

    Args:
        omega : Initial estimate of samples per symbol
        gain_omega : Gain setting for omega update loop
        mu : Initial estimate of phase of sample
        gain_mu : Gain setting for mu update loop
        omega_relative_limit : limit on omega
    """
  return _digital_swig.clock_recovery_mm_ff_make(*args, **kwargs)

class cma_equalizer_cc(object):
    """
    Implements constant modulus adaptive filter on complex stream.

    The error value and tap update equations (for p=2) can be found in:

    D. Godard, "Self-Recovering Equalization and Carrier Tracking
    in Two-Dimensional Data Communication Systems," IEEE Transactions on Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980.

    Constructor Specific Documentation:

    Make a CMA Equalizer block

    Args:
        num_taps : Numer of taps in the equalizer (channel size)
        modulus : Modulus of the modulated signals
        mu : Gain of the update loop
        sps : Number of samples per symbol of the input signal
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int num_taps, float modulus, float mu, int sps) -> cma_equalizer_cc_sptr

        Implements constant modulus adaptive filter on complex stream.

        The error value and tap update equations (for p=2) can be found in:

        D. Godard, "Self-Recovering Equalization and Carrier Tracking
        in Two-Dimensional Data Communication Systems," IEEE Transactions on Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980.

        Constructor Specific Documentation:

        Make a CMA Equalizer block

        Args:
            num_taps : Numer of taps in the equalizer (channel size)
            modulus : Modulus of the modulated signals
            mu : Gain of the update loop
            sps : Number of samples per symbol of the input signal
        """
        return _digital_swig.cma_equalizer_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(cma_equalizer_cc self, pmt_vector_cfloat taps)"""
        return _digital_swig.cma_equalizer_cc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(cma_equalizer_cc self) -> pmt_vector_cfloat"""
        return _digital_swig.cma_equalizer_cc_taps(self)

    def gain(self):
        """gain(cma_equalizer_cc self) -> float"""
        return _digital_swig.cma_equalizer_cc_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(cma_equalizer_cc self, float mu)"""
        return _digital_swig.cma_equalizer_cc_set_gain(self, *args, **kwargs)

    def modulus(self):
        """modulus(cma_equalizer_cc self) -> float"""
        return _digital_swig.cma_equalizer_cc_modulus(self)

    def set_modulus(self, *args, **kwargs):
        """set_modulus(cma_equalizer_cc self, float mod)"""
        return _digital_swig.cma_equalizer_cc_set_modulus(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_cma_equalizer_cc
    __del__ = lambda self : None;
cma_equalizer_cc_swigregister = _digital_swig.cma_equalizer_cc_swigregister
cma_equalizer_cc_swigregister(cma_equalizer_cc)

def cma_equalizer_cc_make(*args, **kwargs):
  """
    cma_equalizer_cc_make(int num_taps, float modulus, float mu, int sps) -> cma_equalizer_cc_sptr

    Implements constant modulus adaptive filter on complex stream.

    The error value and tap update equations (for p=2) can be found in:

    D. Godard, "Self-Recovering Equalization and Carrier Tracking
    in Two-Dimensional Data Communication Systems," IEEE Transactions on Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980.

    Constructor Specific Documentation:

    Make a CMA Equalizer block

    Args:
        num_taps : Numer of taps in the equalizer (channel size)
        modulus : Modulus of the modulated signals
        mu : Gain of the update loop
        sps : Number of samples per symbol of the input signal
    """
  return _digital_swig.cma_equalizer_cc_make(*args, **kwargs)

class constellation(object):
    """
    An abstracted constellation object.

    The constellation objects hold the necessary information to pass around constellation information for modulators and demodulators. These objects contain the mapping between the bits and the constellation points used to represent them as well as methods for slicing the symbol space. Various implementations are possible for efficiency and ease of use.

    Standard constellations (BPSK, QPSK, QAM, etc) can be inherited from this class and overloaded to perform optimized slicing and constellation mappings.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_constellation
    __del__ = lambda self : None;
    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_points(self)

    def s_points(self):
        """
        s_points(constellation self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_s_points(self)

    def v_points(self):
        """
        v_points(constellation self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation self) -> unsigned int"""
        return _digital_swig.constellation_bits_per_symbol(self)

    def arity(self):
        """arity(constellation self) -> unsigned int"""
        return _digital_swig.constellation_arity(self)

    def base(self):
        """base(constellation self) -> constellation_sptr"""
        return _digital_swig.constellation_base(self)

    def as_pmt(self):
        """as_pmt(constellation self) -> swig_int_ptr"""
        return _digital_swig.constellation_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_soft_decision_maker(self, *args, **kwargs)

constellation_swigregister = _digital_swig.constellation_swigregister
constellation_swigregister(constellation)

class constellation_calcdist(constellation):
    """
    Calculate Euclidian distance for any constellation.

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.

    Constructor Specific Documentation:

    Make a general constellation object that calculates the Euclidean distance for hard decisions.

    Args:
        constell : List of constellation points (order of list matches pre_diff_code)
        pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
        rotational_symmetry : Number of rotations around unit circle that have the same representation.
        dimensionality : Number of dimensions to the constellation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Calculate Euclidian distance for any constellation.

        Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.

        Constructor Specific Documentation:

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Args:
            constell : List of constellation points (order of list matches pre_diff_code)
            pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
            rotational_symmetry : Number of rotations around unit circle that have the same representation.
            dimensionality : Number of dimensions to the constellation.
        """
        return _digital_swig.constellation_calcdist_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_calcdist
    __del__ = lambda self : None;
constellation_calcdist_swigregister = _digital_swig.constellation_calcdist_swigregister
constellation_calcdist_swigregister(constellation_calcdist)

def constellation_calcdist_make(*args, **kwargs):
  """
    constellation_calcdist_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

    Calculate Euclidian distance for any constellation.

    Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.

    Constructor Specific Documentation:

    Make a general constellation object that calculates the Euclidean distance for hard decisions.

    Args:
        constell : List of constellation points (order of list matches pre_diff_code)
        pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
        rotational_symmetry : Number of rotations around unit circle that have the same representation.
        dimensionality : Number of dimensions to the constellation.
    """
  return _digital_swig.constellation_calcdist_make(*args, **kwargs)

class constellation_sector(constellation):
    """
    Sectorized digital constellation.

    constellation_sector

    Constellation space is divided into sectors. Each sector is associated with the nearest constellation point.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_constellation_sector
    __del__ = lambda self : None;
constellation_sector_swigregister = _digital_swig.constellation_sector_swigregister
constellation_sector_swigregister(constellation_sector)

class constellation_rect(constellation_sector):
    """
    Rectangular digital constellation

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    Works well for square QAM.

    Works for any generic constellation provided sectors are not too large.

    Constructor Specific Documentation:

    Make a rectangular constellation object.

    Args:
        constell : List of constellation points (order of list matches pre_diff_code)
        pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
        rotational_symmetry : Number of rotations around unit circle that have the same representation.
        real_sectors : Number of sectors the real axis is split in to.
        imag_sectors : Number of sectors the imag axis is split in to.
        width_real_sectors : width of each real sector to calculate decision boundaries.
        width_imag_sectors : width of each imag sector to calculate decision boundaries.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Rectangular digital constellation

        Only implemented for 1-(complex)dimensional constellation.

        Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

        Works well for square QAM.

        Works for any generic constellation provided sectors are not too large.

        Constructor Specific Documentation:

        Make a rectangular constellation object.

        Args:
            constell : List of constellation points (order of list matches pre_diff_code)
            pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
            rotational_symmetry : Number of rotations around unit circle that have the same representation.
            real_sectors : Number of sectors the real axis is split in to.
            imag_sectors : Number of sectors the imag axis is split in to.
            width_real_sectors : width of each real sector to calculate decision boundaries.
            width_imag_sectors : width of each imag sector to calculate decision boundaries.
        """
        return _digital_swig.constellation_rect_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_rect
    __del__ = lambda self : None;
constellation_rect_swigregister = _digital_swig.constellation_rect_swigregister
constellation_rect_swigregister(constellation_rect)

def constellation_rect_make(*args, **kwargs):
  """
    constellation_rect_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

    Rectangular digital constellation

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    Works well for square QAM.

    Works for any generic constellation provided sectors are not too large.

    Constructor Specific Documentation:

    Make a rectangular constellation object.

    Args:
        constell : List of constellation points (order of list matches pre_diff_code)
        pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
        rotational_symmetry : Number of rotations around unit circle that have the same representation.
        real_sectors : Number of sectors the real axis is split in to.
        imag_sectors : Number of sectors the imag axis is split in to.
        width_real_sectors : width of each real sector to calculate decision boundaries.
        width_imag_sectors : width of each imag sector to calculate decision boundaries.
    """
  return _digital_swig.constellation_rect_make(*args, **kwargs)

class constellation_expl_rect(constellation_rect):
    """
    Rectangular digital constellation.

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.

    Constructor Specific Documentation:



    Args:
        constellation : 
        pre_diff_code : 
        rotational_symmetry : 
        real_sectors : 
        imag_sectors : 
        width_real_sectors : 
        width_imag_sectors : 
        sector_values : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

        Rectangular digital constellation.

        Only implemented for 1-(complex)dimensional constellation.

        Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

        This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.

        Constructor Specific Documentation:



        Args:
            constellation : 
            pre_diff_code : 
            rotational_symmetry : 
            real_sectors : 
            imag_sectors : 
            width_real_sectors : 
            width_imag_sectors : 
            sector_values : 
        """
        return _digital_swig.constellation_expl_rect_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_expl_rect
    __del__ = lambda self : None;
constellation_expl_rect_swigregister = _digital_swig.constellation_expl_rect_swigregister
constellation_expl_rect_swigregister(constellation_expl_rect)

def constellation_expl_rect_make(*args, **kwargs):
  """
    constellation_expl_rect_make(pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
        float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

    Rectangular digital constellation.

    Only implemented for 1-(complex)dimensional constellation.

    Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

    This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.

    Constructor Specific Documentation:



    Args:
        constellation : 
        pre_diff_code : 
        rotational_symmetry : 
        real_sectors : 
        imag_sectors : 
        width_real_sectors : 
        width_imag_sectors : 
        sector_values : 
    """
  return _digital_swig.constellation_expl_rect_make(*args, **kwargs)

class constellation_psk(constellation_sector):
    """
    constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x

    Constructor Specific Documentation:



    Args:
        constell : 
        pre_diff_code : 
        n_sectors : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int n_sectors) -> constellation_psk_sptr

        constellation_psk

        Constellation space is divided into pie slices sectors.

        Each slice is associated with the nearest constellation point.

        Works well for PSK but nothing else.

        Assumes that there is a constellation point at 1.x

        Constructor Specific Documentation:



        Args:
            constell : 
            pre_diff_code : 
            n_sectors : 
        """
        return _digital_swig.constellation_psk_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_psk
    __del__ = lambda self : None;
constellation_psk_swigregister = _digital_swig.constellation_psk_swigregister
constellation_psk_swigregister(constellation_psk)

def constellation_psk_make(*args, **kwargs):
  """
    constellation_psk_make(pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
        unsigned int n_sectors) -> constellation_psk_sptr

    constellation_psk

    Constellation space is divided into pie slices sectors.

    Each slice is associated with the nearest constellation point.

    Works well for PSK but nothing else.

    Assumes that there is a constellation point at 1.x

    Constructor Specific Documentation:



    Args:
        constell : 
        pre_diff_code : 
        n_sectors : 
    """
  return _digital_swig.constellation_psk_make(*args, **kwargs)

class constellation_bpsk(constellation):
    """
    Digital constellation for BPSK .

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_bpsk_sptr

        Digital constellation for BPSK .

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_bpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_bpsk
    __del__ = lambda self : None;
constellation_bpsk_swigregister = _digital_swig.constellation_bpsk_swigregister
constellation_bpsk_swigregister(constellation_bpsk)

def constellation_bpsk_make():
  """
    constellation_bpsk_make() -> constellation_bpsk_sptr

    Digital constellation for BPSK .

    Constructor Specific Documentation:


    """
  return _digital_swig.constellation_bpsk_make()

class constellation_qpsk(constellation):
    """
    Digital constellation for QPSK.

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_qpsk_sptr

        Digital constellation for QPSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_qpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_qpsk
    __del__ = lambda self : None;
constellation_qpsk_swigregister = _digital_swig.constellation_qpsk_swigregister
constellation_qpsk_swigregister(constellation_qpsk)

def constellation_qpsk_make():
  """
    constellation_qpsk_make() -> constellation_qpsk_sptr

    Digital constellation for QPSK.

    Constructor Specific Documentation:


    """
  return _digital_swig.constellation_qpsk_make()

class constellation_dqpsk(constellation):
    """
    Digital constellation for DQPSK.

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_dqpsk_sptr

        Digital constellation for DQPSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_dqpsk_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_dqpsk
    __del__ = lambda self : None;
constellation_dqpsk_swigregister = _digital_swig.constellation_dqpsk_swigregister
constellation_dqpsk_swigregister(constellation_dqpsk)

def constellation_dqpsk_make():
  """
    constellation_dqpsk_make() -> constellation_dqpsk_sptr

    Digital constellation for DQPSK.

    Constructor Specific Documentation:


    """
  return _digital_swig.constellation_dqpsk_make()

class constellation_8psk(constellation):
    """
    Digital constellation for 8PSK.

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> constellation_8psk_sptr

        Digital constellation for 8PSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_8psk_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_8psk
    __del__ = lambda self : None;
constellation_8psk_swigregister = _digital_swig.constellation_8psk_swigregister
constellation_8psk_swigregister(constellation_8psk)

def constellation_8psk_make():
  """
    constellation_8psk_make() -> constellation_8psk_sptr

    Digital constellation for 8PSK.

    Constructor Specific Documentation:


    """
  return _digital_swig.constellation_8psk_make()

class constellation_decoder_cb(object):
    """
    Constellation Decoder.

    Decode a constellation's points from a complex space to (unpacked) bits based on the map of the  object.

    Constructor Specific Documentation:

    Make constellation decoder block.

    Args:
        constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(constellation_sptr constellation) -> constellation_decoder_cb_sptr

        Constellation Decoder.

        Decode a constellation's points from a complex space to (unpacked) bits based on the map of the  object.

        Constructor Specific Documentation:

        Make constellation decoder block.

        Args:
            constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.constellation_decoder_cb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_decoder_cb
    __del__ = lambda self : None;
constellation_decoder_cb_swigregister = _digital_swig.constellation_decoder_cb_swigregister
constellation_decoder_cb_swigregister(constellation_decoder_cb)

def constellation_decoder_cb_make(*args, **kwargs):
  """
    constellation_decoder_cb_make(constellation_sptr constellation) -> constellation_decoder_cb_sptr

    Constellation Decoder.

    Decode a constellation's points from a complex space to (unpacked) bits based on the map of the  object.

    Constructor Specific Documentation:

    Make constellation decoder block.

    Args:
        constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
  return _digital_swig.constellation_decoder_cb_make(*args, **kwargs)

class constellation_receiver_cb(object):
    """
    This block makes hard decisions about the received symbols (using a constellation object) and also fine tunes phase synchronization.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

    Constructor Specific Documentation:

    Constructs a constellation receiver that (phase/fine freq) synchronizes and decodes constellation points specified by a constellation object.

    Args:
        constellation : constellation of points for generic modulation
        loop_bw : Loop bandwidth of the Costas Loop (~ 2pi/100)
        fmin : minimum normalized frequency value the loop can achieve
        fmax : maximum normalized frequency value the loop can achieve
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(constellation_sptr constellation, float loop_bw, float fmin, float fmax) -> constellation_receiver_cb_sptr

        This block makes hard decisions about the received symbols (using a constellation object) and also fine tunes phase synchronization.

        The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

        Constructor Specific Documentation:

        Constructs a constellation receiver that (phase/fine freq) synchronizes and decodes constellation points specified by a constellation object.

        Args:
            constellation : constellation of points for generic modulation
            loop_bw : Loop bandwidth of the Costas Loop (~ 2pi/100)
            fmin : minimum normalized frequency value the loop can achieve
            fmax : maximum normalized frequency value the loop can achieve
        """
        return _digital_swig.constellation_receiver_cb_make(*args, **kwargs)

    make = staticmethod(make)
    def phase_error_tracking(self, *args, **kwargs):
        """phase_error_tracking(constellation_receiver_cb self, float phase_error)"""
        return _digital_swig.constellation_receiver_cb_phase_error_tracking(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_constellation_receiver_cb
    __del__ = lambda self : None;
constellation_receiver_cb_swigregister = _digital_swig.constellation_receiver_cb_swigregister
constellation_receiver_cb_swigregister(constellation_receiver_cb)

def constellation_receiver_cb_make(*args, **kwargs):
  """
    constellation_receiver_cb_make(constellation_sptr constellation, float loop_bw, float fmin, float fmax) -> constellation_receiver_cb_sptr

    This block makes hard decisions about the received symbols (using a constellation object) and also fine tunes phase synchronization.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

    Constructor Specific Documentation:

    Constructs a constellation receiver that (phase/fine freq) synchronizes and decodes constellation points specified by a constellation object.

    Args:
        constellation : constellation of points for generic modulation
        loop_bw : Loop bandwidth of the Costas Loop (~ 2pi/100)
        fmin : minimum normalized frequency value the loop can achieve
        fmax : maximum normalized frequency value the loop can achieve
    """
  return _digital_swig.constellation_receiver_cb_make(*args, **kwargs)

class constellation_soft_decoder_cf(object):
    """
    Constellation Decoder.

    Decode a constellation's points from a complex space to soft bits based on the map and soft decision LUT of the  object.

    Constructor Specific Documentation:

    Make constellation decoder block.

    Args:
        constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(constellation_sptr constellation) -> constellation_soft_decoder_cf_sptr

        Constellation Decoder.

        Decode a constellation's points from a complex space to soft bits based on the map and soft decision LUT of the  object.

        Constructor Specific Documentation:

        Make constellation decoder block.

        Args:
            constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.constellation_soft_decoder_cf_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_constellation_soft_decoder_cf
    __del__ = lambda self : None;
constellation_soft_decoder_cf_swigregister = _digital_swig.constellation_soft_decoder_cf_swigregister
constellation_soft_decoder_cf_swigregister(constellation_soft_decoder_cf)

def constellation_soft_decoder_cf_make(*args, **kwargs):
  """
    constellation_soft_decoder_cf_make(constellation_sptr constellation) -> constellation_soft_decoder_cf_sptr

    Constellation Decoder.

    Decode a constellation's points from a complex space to soft bits based on the map and soft decision LUT of the  object.

    Constructor Specific Documentation:

    Make constellation decoder block.

    Args:
        constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
  return _digital_swig.constellation_soft_decoder_cf_make(*args, **kwargs)

class correlate_access_code_bb(object):
    """
    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

    Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.

    Constructor Specific Documentation:

    Make a correlate_access_code block.

    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const & access_code, int threshold) -> correlate_access_code_bb_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

        Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.

        Constructor Specific Documentation:

        Make a correlate_access_code block.

        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
        """
        return _digital_swig.correlate_access_code_bb_make(*args, **kwargs)

    make = staticmethod(make)
    def set_access_code(self, *args, **kwargs):
        """
        set_access_code(correlate_access_code_bb self, std::string const & access_code) -> bool

        Set a new access code.
        """
        return _digital_swig.correlate_access_code_bb_set_access_code(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_bb
    __del__ = lambda self : None;
correlate_access_code_bb_swigregister = _digital_swig.correlate_access_code_bb_swigregister
correlate_access_code_bb_swigregister(correlate_access_code_bb)

def correlate_access_code_bb_make(*args, **kwargs):
  """
    correlate_access_code_bb_make(std::string const & access_code, int threshold) -> correlate_access_code_bb_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

    Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.

    Constructor Specific Documentation:

    Make a correlate_access_code block.

    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
    """
  return _digital_swig.correlate_access_code_bb_make(*args, **kwargs)

class correlate_access_code_tag_bb(object):
    """
    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

    This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_tag_bb_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

        This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_tag_bb_make(*args, **kwargs)

    make = staticmethod(make)
    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_tag_bb self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_set_access_code(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_tag_bb
    __del__ = lambda self : None;
correlate_access_code_tag_bb_swigregister = _digital_swig.correlate_access_code_tag_bb_swigregister
correlate_access_code_tag_bb_swigregister(correlate_access_code_tag_bb)

def correlate_access_code_tag_bb_make(*args, **kwargs):
  """
    correlate_access_code_tag_bb_make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_tag_bb_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

    This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
  return _digital_swig.correlate_access_code_tag_bb_make(*args, **kwargs)

class correlate_access_code_bb_ts(object):
    """
    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

    This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_bb_ts_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

        This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_bb_ts_make(*args, **kwargs)

    make = staticmethod(make)
    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_bb_ts self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_set_access_code(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_bb_ts
    __del__ = lambda self : None;
correlate_access_code_bb_ts_swigregister = _digital_swig.correlate_access_code_bb_ts_swigregister
correlate_access_code_bb_ts_swigregister(correlate_access_code_bb_ts)

def correlate_access_code_bb_ts_make(*args, **kwargs):
  """
    correlate_access_code_bb_ts_make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_bb_ts_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

    This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
  return _digital_swig.correlate_access_code_bb_ts_make(*args, **kwargs)

class correlate_access_code_ff_ts(object):
    """
    Examine input for specified access code, one bit at a time.

    input: stream of floats (generally, soft decisions) output: unaltered stream of floats in a tagged stream

    This block searches for the given access code by slicing the soft decision symbol inputs. Once found, it expects the following 32 samples to contain a header that includes the frame length. It decodes the header to get the frame length in order to set up the the tagged stream key information.

    The output of this block is appropriate for use with tagged stream blocks.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_ff_ts_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of floats (generally, soft decisions) output: unaltered stream of floats in a tagged stream

        This block searches for the given access code by slicing the soft decision symbol inputs. Once found, it expects the following 32 samples to contain a header that includes the frame length. It decodes the header to get the frame length in order to set up the the tagged stream key information.

        The output of this block is appropriate for use with tagged stream blocks.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_ff_ts_make(*args, **kwargs)

    make = staticmethod(make)
    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_ff_ts self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_set_access_code(self, *args, **kwargs)

    def access_code(self):
        """access_code(correlate_access_code_ff_ts self) -> unsigned long long"""
        return _digital_swig.correlate_access_code_ff_ts_access_code(self)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_ff_ts
    __del__ = lambda self : None;
correlate_access_code_ff_ts_swigregister = _digital_swig.correlate_access_code_ff_ts_swigregister
correlate_access_code_ff_ts_swigregister(correlate_access_code_ff_ts)

def correlate_access_code_ff_ts_make(*args, **kwargs):
  """
    correlate_access_code_ff_ts_make(std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_ff_ts_sptr

    Examine input for specified access code, one bit at a time.

    input: stream of floats (generally, soft decisions) output: unaltered stream of floats in a tagged stream

    This block searches for the given access code by slicing the soft decision symbol inputs. Once found, it expects the following 32 samples to contain a header that includes the frame length. It decodes the header to get the frame length in order to set up the the tagged stream key information.

    The output of this block is appropriate for use with tagged stream blocks.

    Constructor Specific Documentation:



    Args:
        access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
        threshold : maximum number of bits that may be wrong
        tag_name : key of the tag inserted into the tag stream
    """
  return _digital_swig.correlate_access_code_ff_ts_make(*args, **kwargs)

class correlate_and_sync_cc(object):
    """
    Correlate to a preamble and send time/phase sync info.

    Input: 
    Output: 
    This block is designed to search for a preamble by correlation and uses the results of the correlation to get a time and phase offset estimate. These estimates are passed downstream as stream tags for use by follow-on synchronization blocks.

    The preamble is provided as a set of symbols along with a baseband matched filter which we use to create the filtered and upsampled symbol that we will receive over-the-air.

    The phase_est tag is used to adjust the phase estimation of any downstream synchronization blocks and is currently used by the gr::digital::costas_loop_cc block.

    The time_est tag is used to adjust the sampling timing estimation of any downstream synchronization blocks and is currently used by the gr::digital::pfb_clock_sync_ccf block.

    Constructor Specific Documentation:

    Make a block that correlates against the  vector and outputs a phase and symbol timing estimate.

    Args:
        symbols : Set of symbols to correlate against (e.g., a preamble).
        filter : Baseband matched filter (e.g., RRC)
        sps : Samples per symbol
        nfilts : Number of filters in the internal PFB
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat symbols, pmt_vector_float filter, unsigned int sps, unsigned int nfilts=32) -> correlate_and_sync_cc_sptr

        Correlate to a preamble and send time/phase sync info.

        Input: 
        Output: 
        This block is designed to search for a preamble by correlation and uses the results of the correlation to get a time and phase offset estimate. These estimates are passed downstream as stream tags for use by follow-on synchronization blocks.

        The preamble is provided as a set of symbols along with a baseband matched filter which we use to create the filtered and upsampled symbol that we will receive over-the-air.

        The phase_est tag is used to adjust the phase estimation of any downstream synchronization blocks and is currently used by the gr::digital::costas_loop_cc block.

        The time_est tag is used to adjust the sampling timing estimation of any downstream synchronization blocks and is currently used by the gr::digital::pfb_clock_sync_ccf block.

        Constructor Specific Documentation:

        Make a block that correlates against the  vector and outputs a phase and symbol timing estimate.

        Args:
            symbols : Set of symbols to correlate against (e.g., a preamble).
            filter : Baseband matched filter (e.g., RRC)
            sps : Samples per symbol
            nfilts : Number of filters in the internal PFB
        """
        return _digital_swig.correlate_and_sync_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def symbols(self):
        """symbols(correlate_and_sync_cc self) -> pmt_vector_cfloat"""
        return _digital_swig.correlate_and_sync_cc_symbols(self)

    def set_symbols(self, *args, **kwargs):
        """set_symbols(correlate_and_sync_cc self, pmt_vector_cfloat symbols)"""
        return _digital_swig.correlate_and_sync_cc_set_symbols(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_correlate_and_sync_cc
    __del__ = lambda self : None;
correlate_and_sync_cc_swigregister = _digital_swig.correlate_and_sync_cc_swigregister
correlate_and_sync_cc_swigregister(correlate_and_sync_cc)

def correlate_and_sync_cc_make(*args, **kwargs):
  """
    correlate_and_sync_cc_make(pmt_vector_cfloat symbols, pmt_vector_float filter, unsigned int sps, unsigned int nfilts=32) -> correlate_and_sync_cc_sptr

    Correlate to a preamble and send time/phase sync info.

    Input: 
    Output: 
    This block is designed to search for a preamble by correlation and uses the results of the correlation to get a time and phase offset estimate. These estimates are passed downstream as stream tags for use by follow-on synchronization blocks.

    The preamble is provided as a set of symbols along with a baseband matched filter which we use to create the filtered and upsampled symbol that we will receive over-the-air.

    The phase_est tag is used to adjust the phase estimation of any downstream synchronization blocks and is currently used by the gr::digital::costas_loop_cc block.

    The time_est tag is used to adjust the sampling timing estimation of any downstream synchronization blocks and is currently used by the gr::digital::pfb_clock_sync_ccf block.

    Constructor Specific Documentation:

    Make a block that correlates against the  vector and outputs a phase and symbol timing estimate.

    Args:
        symbols : Set of symbols to correlate against (e.g., a preamble).
        filter : Baseband matched filter (e.g., RRC)
        sps : Samples per symbol
        nfilts : Number of filters in the internal PFB
    """
  return _digital_swig.correlate_and_sync_cc_make(*args, **kwargs)

class costas_loop_cc(control_loop):
    """
    A Costas loop carrier recovery module.

    The Costas loop locks to the center frequency of a signal and downconverts it to baseband.




    More details can be found online:

    J. Feigin, "Practical Costas loop design: Designing a simple
    and inexpensive BPSK Costas loop carrier recovery circuit," RF signal processing, pp. 20-36, 2002.



    The Costas loop can have two output streams:

    Constructor Specific Documentation:

    Make a Costas loop carrier recovery block.

    Args:
        loop_bw : internal 2nd order loop bandwidth (~ 2pi/100)
        order : the loop order, either 2, 4, or 8
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float loop_bw, int order) -> costas_loop_cc_sptr

        A Costas loop carrier recovery module.

        The Costas loop locks to the center frequency of a signal and downconverts it to baseband.




        More details can be found online:

        J. Feigin, "Practical Costas loop design: Designing a simple
        and inexpensive BPSK Costas loop carrier recovery circuit," RF signal processing, pp. 20-36, 2002.



        The Costas loop can have two output streams:

        Constructor Specific Documentation:

        Make a Costas loop carrier recovery block.

        Args:
            loop_bw : internal 2nd order loop bandwidth (~ 2pi/100)
            order : the loop order, either 2, 4, or 8
        """
        return _digital_swig.costas_loop_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def error(self):
        """
        error(costas_loop_cc self) -> float

        Returns the current value of the loop error.
        """
        return _digital_swig.costas_loop_cc_error(self)

    __swig_destroy__ = _digital_swig.delete_costas_loop_cc
    __del__ = lambda self : None;
costas_loop_cc_swigregister = _digital_swig.costas_loop_cc_swigregister
costas_loop_cc_swigregister(costas_loop_cc)

def costas_loop_cc_make(*args, **kwargs):
  """
    costas_loop_cc_make(float loop_bw, int order) -> costas_loop_cc_sptr

    A Costas loop carrier recovery module.

    The Costas loop locks to the center frequency of a signal and downconverts it to baseband.




    More details can be found online:

    J. Feigin, "Practical Costas loop design: Designing a simple
    and inexpensive BPSK Costas loop carrier recovery circuit," RF signal processing, pp. 20-36, 2002.



    The Costas loop can have two output streams:

    Constructor Specific Documentation:

    Make a Costas loop carrier recovery block.

    Args:
        loop_bw : internal 2nd order loop bandwidth (~ 2pi/100)
        order : the loop order, either 2, 4, or 8
    """
  return _digital_swig.costas_loop_cc_make(*args, **kwargs)

class cpmmod_bc(object):
    """
    Generic CPM modulator.

    Examples:


    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Constructor Specific Documentation:

    Make CPM modulator block.

    Args:
        type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
        h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
        samples_per_sym : Samples per symbol.
        L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
        beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(gr::analog::cpm::cpm_type type, float h, int samples_per_sym, int L, double beta=0.3) -> cpmmod_bc_sptr

        Generic CPM modulator.

        Examples:


        The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

        Constructor Specific Documentation:

        Make CPM modulator block.

        Args:
            type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
            h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
            samples_per_sym : Samples per symbol.
            L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
            beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
        """
        return _digital_swig.cpmmod_bc_make(*args, **kwargs)

    make = staticmethod(make)
    def make_gmskmod_bc(samples_per_sym=2, L=4, beta=0.3):
        """
        make_gmskmod_bc(int samples_per_sym=2, int L=4, double beta=0.3) -> cpmmod_bc_sptr

        Make GMSK modulator block.

        The type is GAUSSIAN and the modulation index for GMSK is 0.5. This are populated automatically by this factory function.
        """
        return _digital_swig.cpmmod_bc_make_gmskmod_bc(samples_per_sym, L, beta)

    make_gmskmod_bc = staticmethod(make_gmskmod_bc)
    def taps(self):
        """
        taps(cpmmod_bc self) -> pmt_vector_float

        Return the phase response FIR taps.
        """
        return _digital_swig.cpmmod_bc_taps(self)

    def type(self):
        """
        type(cpmmod_bc self) -> int

        Return the type of CPM modulator.
        """
        return _digital_swig.cpmmod_bc_type(self)

    def index(self):
        """
        index(cpmmod_bc self) -> float

        Return the modulation index of the modulator.
        """
        return _digital_swig.cpmmod_bc_index(self)

    def samples_per_sym(self):
        """
        samples_per_sym(cpmmod_bc self) -> int

        Return the number of samples per symbol.
        """
        return _digital_swig.cpmmod_bc_samples_per_sym(self)

    def length(self):
        """
        length(cpmmod_bc self) -> int

        Return the length of the phase duration (in symbols)
        """
        return _digital_swig.cpmmod_bc_length(self)

    def beta(self):
        """
        beta(cpmmod_bc self) -> double

        Return the value of beta for the modulator.
        """
        return _digital_swig.cpmmod_bc_beta(self)

    __swig_destroy__ = _digital_swig.delete_cpmmod_bc
    __del__ = lambda self : None;
cpmmod_bc_swigregister = _digital_swig.cpmmod_bc_swigregister
cpmmod_bc_swigregister(cpmmod_bc)

def cpmmod_bc_make(*args, **kwargs):
  """
    cpmmod_bc_make(gr::analog::cpm::cpm_type type, float h, int samples_per_sym, int L, double beta=0.3) -> cpmmod_bc_sptr

    Generic CPM modulator.

    Examples:


    The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

    Constructor Specific Documentation:

    Make CPM modulator block.

    Args:
        type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
        h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
        samples_per_sym : Samples per symbol.
        L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
        beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
    """
  return _digital_swig.cpmmod_bc_make(*args, **kwargs)

def cpmmod_bc_make_gmskmod_bc(samples_per_sym=2, L=4, beta=0.3):
  """
    cpmmod_bc_make_gmskmod_bc(int samples_per_sym=2, int L=4, double beta=0.3) -> cpmmod_bc_sptr

    Make GMSK modulator block.

    The type is GAUSSIAN and the modulation index for GMSK is 0.5. This are populated automatically by this factory function.
    """
  return _digital_swig.cpmmod_bc_make_gmskmod_bc(samples_per_sym, L, beta)


def update_crc32(*args):
  """
    update_crc32(unsigned int crc, unsigned char const * buf, size_t len) -> unsigned int
    update_crc32(unsigned int crc, std::string const buf) -> unsigned int

    update running CRC-32

    Update a running CRC with the bytes buf[0..len-1] The CRC should be initialized to all 1's, and the transmitted value is the 1's complement of the final running CRC. The resulting CRC should be transmitted in big endian order.
    """
  return _digital_swig.update_crc32(*args)

def crc32(*args):
  """
    crc32(unsigned char const * buf, size_t len) -> unsigned int
    crc32(std::string const buf) -> unsigned int
    """
  return _digital_swig.crc32(*args)
class crc32_bb(object):
    """
    Byte-stream CRC block.

    Input: stream of bytes, which form a packet. The first byte of the packet has a tag with key "length" and the value being the number of bytes in the packet.

    Output: The same bytes as incoming, but trailing a CRC32 of the packet. The tag is re-set to the new length.

    Constructor Specific Documentation:



    Args:
        check : Set to true if you want to check CRC, false to create CRC.
        lengthtagname : Length tag key
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(check=False, lengthtagname="packet_len"):
        """
        make(bool check=False, std::string const & lengthtagname="packet_len") -> crc32_bb_sptr

        Byte-stream CRC block.

        Input: stream of bytes, which form a packet. The first byte of the packet has a tag with key "length" and the value being the number of bytes in the packet.

        Output: The same bytes as incoming, but trailing a CRC32 of the packet. The tag is re-set to the new length.

        Constructor Specific Documentation:



        Args:
            check : Set to true if you want to check CRC, false to create CRC.
            lengthtagname : Length tag key
        """
        return _digital_swig.crc32_bb_make(check, lengthtagname)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_crc32_bb
    __del__ = lambda self : None;
crc32_bb_swigregister = _digital_swig.crc32_bb_swigregister
crc32_bb_swigregister(crc32_bb)

def crc32_bb_make(check=False, lengthtagname="packet_len"):
  """
    crc32_bb_make(bool check=False, std::string const & lengthtagname="packet_len") -> crc32_bb_sptr

    Byte-stream CRC block.

    Input: stream of bytes, which form a packet. The first byte of the packet has a tag with key "length" and the value being the number of bytes in the packet.

    Output: The same bytes as incoming, but trailing a CRC32 of the packet. The tag is re-set to the new length.

    Constructor Specific Documentation:



    Args:
        check : Set to true if you want to check CRC, false to create CRC.
        lengthtagname : Length tag key
    """
  return _digital_swig.crc32_bb_make(check, lengthtagname)

class crc32_async_bb(object):
    """
    Byte-stream CRC block for async messages.

    Processes packets (as async PDU messages) for CRC32. The  parameter determines if the block acts to check and strip the CRC or to calculate and append the CRC32.

    The input PDU is expected to be a message of packet bytes.

    When using check mode, if the CRC passes, the output is a payload of the message with the CRC stripped, so the output will be 4 bytes smaller than the input.

    When using calculate mode (check == false), then the CRC is calculated on the PDU and appended to it. The output is then 4 bytes longer than the input.

    This block implements the CRC32 using the Boost crc_optimal class for 32-bit CRCs with the standard generator 0x04C11DB7.

    Constructor Specific Documentation:



    Args:
        check : Set to true if you want to check CRC, false to create CRC.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(check=False):
        """
        make(bool check=False) -> crc32_async_bb_sptr

        Byte-stream CRC block for async messages.

        Processes packets (as async PDU messages) for CRC32. The  parameter determines if the block acts to check and strip the CRC or to calculate and append the CRC32.

        The input PDU is expected to be a message of packet bytes.

        When using check mode, if the CRC passes, the output is a payload of the message with the CRC stripped, so the output will be 4 bytes smaller than the input.

        When using calculate mode (check == false), then the CRC is calculated on the PDU and appended to it. The output is then 4 bytes longer than the input.

        This block implements the CRC32 using the Boost crc_optimal class for 32-bit CRCs with the standard generator 0x04C11DB7.

        Constructor Specific Documentation:



        Args:
            check : Set to true if you want to check CRC, false to create CRC.
        """
        return _digital_swig.crc32_async_bb_make(check)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_crc32_async_bb
    __del__ = lambda self : None;
crc32_async_bb_swigregister = _digital_swig.crc32_async_bb_swigregister
crc32_async_bb_swigregister(crc32_async_bb)

def crc32_async_bb_make(check=False):
  """
    crc32_async_bb_make(bool check=False) -> crc32_async_bb_sptr

    Byte-stream CRC block for async messages.

    Processes packets (as async PDU messages) for CRC32. The  parameter determines if the block acts to check and strip the CRC or to calculate and append the CRC32.

    The input PDU is expected to be a message of packet bytes.

    When using check mode, if the CRC passes, the output is a payload of the message with the CRC stripped, so the output will be 4 bytes smaller than the input.

    When using calculate mode (check == false), then the CRC is calculated on the PDU and appended to it. The output is then 4 bytes longer than the input.

    This block implements the CRC32 using the Boost crc_optimal class for 32-bit CRCs with the standard generator 0x04C11DB7.

    Constructor Specific Documentation:



    Args:
        check : Set to true if you want to check CRC, false to create CRC.
    """
  return _digital_swig.crc32_async_bb_make(check)

class descrambler_bb(object):
    """
    Descramber an input stream using an LFSR.

    Descramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked
    binary" stream, and produces the same format on its output.

    Constructor Specific Documentation:

    Make a descrambler block.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int mask, int seed, int len) -> descrambler_bb_sptr

        Descramber an input stream using an LFSR.

        Descramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked
        binary" stream, and produces the same format on its output.

        Constructor Specific Documentation:

        Make a descrambler block.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
        """
        return _digital_swig.descrambler_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_descrambler_bb
    __del__ = lambda self : None;
descrambler_bb_swigregister = _digital_swig.descrambler_bb_swigregister
descrambler_bb_swigregister(descrambler_bb)

def descrambler_bb_make(*args, **kwargs):
  """
    descrambler_bb_make(int mask, int seed, int len) -> descrambler_bb_sptr

    Descramber an input stream using an LFSR.

    Descramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked
    binary" stream, and produces the same format on its output.

    Constructor Specific Documentation:

    Make a descrambler block.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
  return _digital_swig.descrambler_bb_make(*args, **kwargs)

class diff_decoder_bb(object):
    """
    Differential encoder: y[0] = (x[0] - x[-1]) % M.

    Uses current and previous symbols and the alphabet modulus to perform differential decoding.

    Constructor Specific Documentation:

    Make a differntial decoder block.

    Args:
        modulus : Modulus of code's alphabet
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int modulus) -> diff_decoder_bb_sptr

        Differential encoder: y[0] = (x[0] - x[-1]) % M.

        Uses current and previous symbols and the alphabet modulus to perform differential decoding.

        Constructor Specific Documentation:

        Make a differntial decoder block.

        Args:
            modulus : Modulus of code's alphabet
        """
        return _digital_swig.diff_decoder_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_diff_decoder_bb
    __del__ = lambda self : None;
diff_decoder_bb_swigregister = _digital_swig.diff_decoder_bb_swigregister
diff_decoder_bb_swigregister(diff_decoder_bb)

def diff_decoder_bb_make(*args, **kwargs):
  """
    diff_decoder_bb_make(unsigned int modulus) -> diff_decoder_bb_sptr

    Differential encoder: y[0] = (x[0] - x[-1]) % M.

    Uses current and previous symbols and the alphabet modulus to perform differential decoding.

    Constructor Specific Documentation:

    Make a differntial decoder block.

    Args:
        modulus : Modulus of code's alphabet
    """
  return _digital_swig.diff_decoder_bb_make(*args, **kwargs)

class diff_encoder_bb(object):
    """
    Differential decoder: y[0] = (x[0] + y[-1]) % M.

    Uses current and previous symbols and the alphabet modulus to perform differential encoding.

    Constructor Specific Documentation:

    Make a differntial encoder block.

    Args:
        modulus : Modulus of code's alphabet
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int modulus) -> diff_encoder_bb_sptr

        Differential decoder: y[0] = (x[0] + y[-1]) % M.

        Uses current and previous symbols and the alphabet modulus to perform differential encoding.

        Constructor Specific Documentation:

        Make a differntial encoder block.

        Args:
            modulus : Modulus of code's alphabet
        """
        return _digital_swig.diff_encoder_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_diff_encoder_bb
    __del__ = lambda self : None;
diff_encoder_bb_swigregister = _digital_swig.diff_encoder_bb_swigregister
diff_encoder_bb_swigregister(diff_encoder_bb)

def diff_encoder_bb_make(*args, **kwargs):
  """
    diff_encoder_bb_make(unsigned int modulus) -> diff_encoder_bb_sptr

    Differential decoder: y[0] = (x[0] + y[-1]) % M.

    Uses current and previous symbols and the alphabet modulus to perform differential encoding.

    Constructor Specific Documentation:

    Make a differntial encoder block.

    Args:
        modulus : Modulus of code's alphabet
    """
  return _digital_swig.diff_encoder_bb_make(*args, **kwargs)

class diff_phasor_cc(object):
    """
    Differential decoding based on phase change.

    Uses the phase difference between two symbols to determine the output symbol:

    Constructor Specific Documentation:

    Make a differential phasor decoding block.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> diff_phasor_cc_sptr

        Differential decoding based on phase change.

        Uses the phase difference between two symbols to determine the output symbol:

        Constructor Specific Documentation:

        Make a differential phasor decoding block.
        """
        return _digital_swig.diff_phasor_cc_make()

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_diff_phasor_cc
    __del__ = lambda self : None;
diff_phasor_cc_swigregister = _digital_swig.diff_phasor_cc_swigregister
diff_phasor_cc_swigregister(diff_phasor_cc)

def diff_phasor_cc_make():
  """
    diff_phasor_cc_make() -> diff_phasor_cc_sptr

    Differential decoding based on phase change.

    Uses the phase difference between two symbols to determine the output symbol:

    Constructor Specific Documentation:

    Make a differential phasor decoding block.
    """
  return _digital_swig.diff_phasor_cc_make()

class fll_band_edge_cc(control_loop):
    """
    Frequency Lock Loop using band-edge filters.

    The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

    The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

    In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

    In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = frac{H(f)}{df}). In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

    Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

    It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

    Constructor Specific Documentation:

    Make an FLL block.

    Args:
        samps_per_sym : (float) number of samples per symbol
        rolloff : (float) Rolloff (excess bandwidth) of signal filter
        filter_size : (int) number of filter taps to generate
        bandwidth : (float) Loop bandwidth
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(float samps_per_sym, float rolloff, int filter_size, float bandwidth) -> fll_band_edge_cc_sptr

        Frequency Lock Loop using band-edge filters.

        The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

        The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

        In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

        In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = frac{H(f)}{df}). In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

        Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

        It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

        Constructor Specific Documentation:

        Make an FLL block.

        Args:
            samps_per_sym : (float) number of samples per symbol
            rolloff : (float) Rolloff (excess bandwidth) of signal filter
            filter_size : (int) number of filter taps to generate
            bandwidth : (float) Loop bandwidth
        """
        return _digital_swig.fll_band_edge_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_samples_per_symbol(self, *args, **kwargs):
        """
        set_samples_per_symbol(fll_band_edge_cc self, float sps)

        Set the number of samples per symbol.

        Set's the number of samples per symbol the system should use. This value is uesd to calculate the filter taps and will force a recalculation.
        """
        return _digital_swig.fll_band_edge_cc_set_samples_per_symbol(self, *args, **kwargs)

    def set_rolloff(self, *args, **kwargs):
        """
        set_rolloff(fll_band_edge_cc self, float rolloff)

        Set the rolloff factor of the shaping filter.

        This sets the rolloff factor that is used in the pulse shaping filter and is used to calculate the filter taps. Changing this will force a recalculation of the filter taps.

        This should be the same value that is used in the transmitter's pulse shaping filter. It must be between 0 and 1 and is usually between 0.2 and 0.5 (where 0.22 and 0.35 are commonly used values).
        """
        return _digital_swig.fll_band_edge_cc_set_rolloff(self, *args, **kwargs)

    def set_filter_size(self, *args, **kwargs):
        """
        set_filter_size(fll_band_edge_cc self, int filter_size)

        Set the number of taps in the filter.

        This sets the number of taps in the band-edge filters. Setting this will force a recalculation of the filter taps.

        This should be about the same number of taps used in the transmitter's shaping filter and also not very large. A large number of taps will result in a large delay between input and frequency estimation, and so will not be as accurate. Between 30 and 70 taps is usual.
        """
        return _digital_swig.fll_band_edge_cc_set_filter_size(self, *args, **kwargs)

    def samples_per_symbol(self):
        """
        samples_per_symbol(fll_band_edge_cc self) -> float

        Returns the number of sampler per symbol used for the filter.
        """
        return _digital_swig.fll_band_edge_cc_samples_per_symbol(self)

    def rolloff(self):
        """
        rolloff(fll_band_edge_cc self) -> float

        Returns the rolloff factor used for the filter.
        """
        return _digital_swig.fll_band_edge_cc_rolloff(self)

    def filter_size(self):
        """
        filter_size(fll_band_edge_cc self) -> int

        Returns the number of taps of the filter.
        """
        return _digital_swig.fll_band_edge_cc_filter_size(self)

    def print_taps(self):
        """
        print_taps(fll_band_edge_cc self)

        Print the taps to screen.
        """
        return _digital_swig.fll_band_edge_cc_print_taps(self)

    __swig_destroy__ = _digital_swig.delete_fll_band_edge_cc
    __del__ = lambda self : None;
fll_band_edge_cc_swigregister = _digital_swig.fll_band_edge_cc_swigregister
fll_band_edge_cc_swigregister(fll_band_edge_cc)

def fll_band_edge_cc_make(*args, **kwargs):
  """
    fll_band_edge_cc_make(float samps_per_sym, float rolloff, int filter_size, float bandwidth) -> fll_band_edge_cc_sptr

    Frequency Lock Loop using band-edge filters.

    The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

    The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

    In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

    In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = frac{H(f)}{df}). In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

    Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

    It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

    Constructor Specific Documentation:

    Make an FLL block.

    Args:
        samps_per_sym : (float) number of samples per symbol
        rolloff : (float) Rolloff (excess bandwidth) of signal filter
        filter_size : (int) number of filter taps to generate
        bandwidth : (float) Loop bandwidth
    """
  return _digital_swig.fll_band_edge_cc_make(*args, **kwargs)

class framer_sink_1(object):
    """
    Given a stream of bits and access_code flags, assemble packets.

    input: stream of bytes from digital_correlate_access_code_bb output: none. Pushes assembled packet into target queue

    The framer expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    The input data consists of bytes that have two bits used. Bit 0, the LSB, contains the data bit. Bit 1 if set, indicates that the corresponding bit is the the first bit of the packet. That is, this bit is the first one after the access code.

    Constructor Specific Documentation:

    Make a framer_sink_1 block.

    Args:
        target_queue : The message queue where frames go.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(msg_queue_sptr target_queue) -> framer_sink_1_sptr

        Given a stream of bits and access_code flags, assemble packets.

        input: stream of bytes from digital_correlate_access_code_bb output: none. Pushes assembled packet into target queue

        The framer expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

        The input data consists of bytes that have two bits used. Bit 0, the LSB, contains the data bit. Bit 1 if set, indicates that the corresponding bit is the the first bit of the packet. That is, this bit is the first one after the access code.

        Constructor Specific Documentation:

        Make a framer_sink_1 block.

        Args:
            target_queue : The message queue where frames go.
        """
        return _digital_swig.framer_sink_1_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_framer_sink_1
    __del__ = lambda self : None;
framer_sink_1_swigregister = _digital_swig.framer_sink_1_swigregister
framer_sink_1_swigregister(framer_sink_1)

def framer_sink_1_make(*args, **kwargs):
  """
    framer_sink_1_make(msg_queue_sptr target_queue) -> framer_sink_1_sptr

    Given a stream of bits and access_code flags, assemble packets.

    input: stream of bytes from digital_correlate_access_code_bb output: none. Pushes assembled packet into target queue

    The framer expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    The input data consists of bytes that have two bits used. Bit 0, the LSB, contains the data bit. Bit 1 if set, indicates that the corresponding bit is the the first bit of the packet. That is, this bit is the first one after the access code.

    Constructor Specific Documentation:

    Make a framer_sink_1 block.

    Args:
        target_queue : The message queue where frames go.
    """
  return _digital_swig.framer_sink_1_make(*args, **kwargs)

class glfsr_source_b(object):
    """
    Galois LFSR pseudo-random source.

    Constructor Specific Documentation:

    Make a Galois LFSR pseudo-random source block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_b_sptr

        Galois LFSR pseudo-random source.

        Constructor Specific Documentation:

        Make a Galois LFSR pseudo-random source block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            repeat : Set to repeat sequence.
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.glfsr_source_b_make(*args, **kwargs)

    make = staticmethod(make)
    def period(self):
        """period(glfsr_source_b self) -> unsigned int"""
        return _digital_swig.glfsr_source_b_period(self)

    def mask(self):
        """mask(glfsr_source_b self) -> int"""
        return _digital_swig.glfsr_source_b_mask(self)

    __swig_destroy__ = _digital_swig.delete_glfsr_source_b
    __del__ = lambda self : None;
glfsr_source_b_swigregister = _digital_swig.glfsr_source_b_swigregister
glfsr_source_b_swigregister(glfsr_source_b)

def glfsr_source_b_make(*args, **kwargs):
  """
    glfsr_source_b_make(int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_b_sptr

    Galois LFSR pseudo-random source.

    Constructor Specific Documentation:

    Make a Galois LFSR pseudo-random source block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.glfsr_source_b_make(*args, **kwargs)

class glfsr_source_f(object):
    """
    Galois LFSR pseudo-random source generating float outputs -1.0 - 1.0.

    Constructor Specific Documentation:

    Make a Galois LFSR pseudo-random source block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_f_sptr

        Galois LFSR pseudo-random source generating float outputs -1.0 - 1.0.

        Constructor Specific Documentation:

        Make a Galois LFSR pseudo-random source block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            repeat : Set to repeat sequence.
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.glfsr_source_f_make(*args, **kwargs)

    make = staticmethod(make)
    def period(self):
        """period(glfsr_source_f self) -> unsigned int"""
        return _digital_swig.glfsr_source_f_period(self)

    def mask(self):
        """mask(glfsr_source_f self) -> int"""
        return _digital_swig.glfsr_source_f_mask(self)

    __swig_destroy__ = _digital_swig.delete_glfsr_source_f
    __del__ = lambda self : None;
glfsr_source_f_swigregister = _digital_swig.glfsr_source_f_swigregister
glfsr_source_f_swigregister(glfsr_source_f)

def glfsr_source_f_make(*args, **kwargs):
  """
    glfsr_source_f_make(int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_f_sptr

    Galois LFSR pseudo-random source generating float outputs -1.0 - 1.0.

    Constructor Specific Documentation:

    Make a Galois LFSR pseudo-random source block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        repeat : Set to repeat sequence.
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.glfsr_source_f_make(*args, **kwargs)

class hdlc_deframer_bp(object):
    """
    HDLC deframer which takes in unpacked bits, and outputs PDU binary blobs. Frames which do not pass CRC are rejected.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of digital::hdlc_deframer.

    Args:
        length_min : Minimum frame size (default: 32)
        length_max : Maximum frame size (default: 500)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int length_min, int length_max) -> hdlc_deframer_bp_sptr

        HDLC deframer which takes in unpacked bits, and outputs PDU binary blobs. Frames which do not pass CRC are rejected.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of digital::hdlc_deframer.

        Args:
            length_min : Minimum frame size (default: 32)
            length_max : Maximum frame size (default: 500)
        """
        return _digital_swig.hdlc_deframer_bp_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_hdlc_deframer_bp
    __del__ = lambda self : None;
hdlc_deframer_bp_swigregister = _digital_swig.hdlc_deframer_bp_swigregister
hdlc_deframer_bp_swigregister(hdlc_deframer_bp)

def hdlc_deframer_bp_make(*args, **kwargs):
  """
    hdlc_deframer_bp_make(int length_min, int length_max) -> hdlc_deframer_bp_sptr

    HDLC deframer which takes in unpacked bits, and outputs PDU binary blobs. Frames which do not pass CRC are rejected.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of digital::hdlc_deframer.

    Args:
        length_min : Minimum frame size (default: 32)
        length_max : Maximum frame size (default: 500)
    """
  return _digital_swig.hdlc_deframer_bp_make(*args, **kwargs)

class hdlc_framer_pb(object):
    """
    HDLC framer which takes in PMT binary blobs and outputs HDLC frames as unpacked bits, with CRC and bit stuffing added. The first sample of the frame is tagged with the tag frame_tag_name and includes a length field for tagged_stream use.

    This block outputs one whole frame at a time; if there is not enough output buffer space to fit a frame, it is pushed onto a queue. As a result flowgraphs which only run for a finite number of samples may not receive all frames in the queue, due to the scheduler's granularity. For flowgraphs that stream continuously (anything using a USRP) this should not be an issue.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of digital::hdlc_framer.

    Args:
        frame_tag_name : The tag to add to the first sample of each frame.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const frame_tag_name) -> hdlc_framer_pb_sptr

        HDLC framer which takes in PMT binary blobs and outputs HDLC frames as unpacked bits, with CRC and bit stuffing added. The first sample of the frame is tagged with the tag frame_tag_name and includes a length field for tagged_stream use.

        This block outputs one whole frame at a time; if there is not enough output buffer space to fit a frame, it is pushed onto a queue. As a result flowgraphs which only run for a finite number of samples may not receive all frames in the queue, due to the scheduler's granularity. For flowgraphs that stream continuously (anything using a USRP) this should not be an issue.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of digital::hdlc_framer.

        Args:
            frame_tag_name : The tag to add to the first sample of each frame.
        """
        return _digital_swig.hdlc_framer_pb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_hdlc_framer_pb
    __del__ = lambda self : None;
hdlc_framer_pb_swigregister = _digital_swig.hdlc_framer_pb_swigregister
hdlc_framer_pb_swigregister(hdlc_framer_pb)

def hdlc_framer_pb_make(*args, **kwargs):
  """
    hdlc_framer_pb_make(std::string const frame_tag_name) -> hdlc_framer_pb_sptr

    HDLC framer which takes in PMT binary blobs and outputs HDLC frames as unpacked bits, with CRC and bit stuffing added. The first sample of the frame is tagged with the tag frame_tag_name and includes a length field for tagged_stream use.

    This block outputs one whole frame at a time; if there is not enough output buffer space to fit a frame, it is pushed onto a queue. As a result flowgraphs which only run for a finite number of samples may not receive all frames in the queue, due to the scheduler's granularity. For flowgraphs that stream continuously (anything using a USRP) this should not be an issue.

    Constructor Specific Documentation:

    Return a shared_ptr to a new instance of digital::hdlc_framer.

    Args:
        frame_tag_name : The tag to add to the first sample of each frame.
    """
  return _digital_swig.hdlc_framer_pb_make(*args, **kwargs)

class header_payload_demux(object):
    """
    Header/Payload demuxer.

    This block is designed to handle packets from a bursty transmission. Input 0 takes a continuous transmission of samples. If used, input 1 is a trigger signal. In this case, a 1 on input 1 is a trigger. Otherwise, a tag with the key specified in  is used as a trigger (its value is irrelevant).

    Until a trigger signal is detected, all samples are dropped onto the floor. Once a trigger is detected, a total of  items are copied to output 0. The block then stalls until it receives a message on the message port . The message must be a PMT dictionary; all key/value pairs are copied as tags to the first item of the payload (which is assumed to be the first item after the header). The value corresponding to the key specified in  is read and taken as the payload length. The payload, together with the header data as tags, is then copied to output 1.

    If specified,  items are discarded before every symbol. This is useful for demuxing bursts of OFDM signals.

    Any tags on the input stream are copied to the corresponding output  they're on an item that is propagated. Note that a tag on the header items is copied to the header stream; that means the header-parsing block must handle these tags if they should go on the payload. A special case are tags on items that make up the guard interval. These are copied to the first item of the following symbol. If a tag is situated very close to the end of the payload, it might be unclear if it belongs to this packet or the following. In this case, the tag might be propagated twice.

    Tags outside of packets are generally discarded. If this information is important, there are two additional mechanisms to preserve the tags:

    Constructor Specific Documentation:



    Args:
        header_len : Number of symbols per header
        items_per_symbol : Number of items per symbol
        guard_interval : Number of items between two consecutive symbols
        length_tag_key : Key of the frame length tag
        trigger_tag_key : Key of the trigger tag
        output_symbols : Output symbols (true) or items (false)?
        itemsize : Item size (bytes per item)
        timing_tag_key : The name of the tag with timing information, usually 'rx_time' or empty (this means timing info is discarded)
        samp_rate : Sampling rate at the input. Necessary to calculate the rx time of packets.
        special_tags : A vector of strings denoting tags which shall be preserved.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
            std::string const & trigger_tag_key="", bool output_symbols=False, 
            size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
            double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

        Header/Payload demuxer.

        This block is designed to handle packets from a bursty transmission. Input 0 takes a continuous transmission of samples. If used, input 1 is a trigger signal. In this case, a 1 on input 1 is a trigger. Otherwise, a tag with the key specified in  is used as a trigger (its value is irrelevant).

        Until a trigger signal is detected, all samples are dropped onto the floor. Once a trigger is detected, a total of  items are copied to output 0. The block then stalls until it receives a message on the message port . The message must be a PMT dictionary; all key/value pairs are copied as tags to the first item of the payload (which is assumed to be the first item after the header). The value corresponding to the key specified in  is read and taken as the payload length. The payload, together with the header data as tags, is then copied to output 1.

        If specified,  items are discarded before every symbol. This is useful for demuxing bursts of OFDM signals.

        Any tags on the input stream are copied to the corresponding output  they're on an item that is propagated. Note that a tag on the header items is copied to the header stream; that means the header-parsing block must handle these tags if they should go on the payload. A special case are tags on items that make up the guard interval. These are copied to the first item of the following symbol. If a tag is situated very close to the end of the payload, it might be unclear if it belongs to this packet or the following. In this case, the tag might be propagated twice.

        Tags outside of packets are generally discarded. If this information is important, there are two additional mechanisms to preserve the tags:

        Constructor Specific Documentation:



        Args:
            header_len : Number of symbols per header
            items_per_symbol : Number of items per symbol
            guard_interval : Number of items between two consecutive symbols
            length_tag_key : Key of the frame length tag
            trigger_tag_key : Key of the trigger tag
            output_symbols : Output symbols (true) or items (false)?
            itemsize : Item size (bytes per item)
            timing_tag_key : The name of the tag with timing information, usually 'rx_time' or empty (this means timing info is discarded)
            samp_rate : Sampling rate at the input. Necessary to calculate the rx time of packets.
            special_tags : A vector of strings denoting tags which shall be preserved.
        """
        return _digital_swig.header_payload_demux_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_header_payload_demux
    __del__ = lambda self : None;
header_payload_demux_swigregister = _digital_swig.header_payload_demux_swigregister
header_payload_demux_swigregister(header_payload_demux)

def header_payload_demux_make(*args, **kwargs):
  """
    header_payload_demux_make(int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
        std::string const & trigger_tag_key="", bool output_symbols=False, 
        size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
        double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

    Header/Payload demuxer.

    This block is designed to handle packets from a bursty transmission. Input 0 takes a continuous transmission of samples. If used, input 1 is a trigger signal. In this case, a 1 on input 1 is a trigger. Otherwise, a tag with the key specified in  is used as a trigger (its value is irrelevant).

    Until a trigger signal is detected, all samples are dropped onto the floor. Once a trigger is detected, a total of  items are copied to output 0. The block then stalls until it receives a message on the message port . The message must be a PMT dictionary; all key/value pairs are copied as tags to the first item of the payload (which is assumed to be the first item after the header). The value corresponding to the key specified in  is read and taken as the payload length. The payload, together with the header data as tags, is then copied to output 1.

    If specified,  items are discarded before every symbol. This is useful for demuxing bursts of OFDM signals.

    Any tags on the input stream are copied to the corresponding output  they're on an item that is propagated. Note that a tag on the header items is copied to the header stream; that means the header-parsing block must handle these tags if they should go on the payload. A special case are tags on items that make up the guard interval. These are copied to the first item of the following symbol. If a tag is situated very close to the end of the payload, it might be unclear if it belongs to this packet or the following. In this case, the tag might be propagated twice.

    Tags outside of packets are generally discarded. If this information is important, there are two additional mechanisms to preserve the tags:

    Constructor Specific Documentation:



    Args:
        header_len : Number of symbols per header
        items_per_symbol : Number of items per symbol
        guard_interval : Number of items between two consecutive symbols
        length_tag_key : Key of the frame length tag
        trigger_tag_key : Key of the trigger tag
        output_symbols : Output symbols (true) or items (false)?
        itemsize : Item size (bytes per item)
        timing_tag_key : The name of the tag with timing information, usually 'rx_time' or empty (this means timing info is discarded)
        samp_rate : Sampling rate at the input. Necessary to calculate the rx time of packets.
        special_tags : A vector of strings denoting tags which shall be preserved.
    """
  return _digital_swig.header_payload_demux_make(*args, **kwargs)

class kurtotic_equalizer_cc(object):
    """
    Implements a kurtosis-based adaptive equalizer on complex stream.

    Warning: This block does not yet work.

    "Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind equalization algorithm," IEEE Conf. on Control, Automation,
    Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057."

    Constructor Specific Documentation:



    Args:
        num_taps : 
        mu : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int num_taps, float mu) -> kurtotic_equalizer_cc_sptr

        Implements a kurtosis-based adaptive equalizer on complex stream.

        Warning: This block does not yet work.

        "Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind equalization algorithm," IEEE Conf. on Control, Automation,
        Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057."

        Constructor Specific Documentation:



        Args:
            num_taps : 
            mu : 
        """
        return _digital_swig.kurtotic_equalizer_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def gain(self):
        """gain(kurtotic_equalizer_cc self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(kurtotic_equalizer_cc self, float mu)"""
        return _digital_swig.kurtotic_equalizer_cc_set_gain(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_kurtotic_equalizer_cc
    __del__ = lambda self : None;
kurtotic_equalizer_cc_swigregister = _digital_swig.kurtotic_equalizer_cc_swigregister
kurtotic_equalizer_cc_swigregister(kurtotic_equalizer_cc)

def kurtotic_equalizer_cc_make(*args, **kwargs):
  """
    kurtotic_equalizer_cc_make(int num_taps, float mu) -> kurtotic_equalizer_cc_sptr

    Implements a kurtosis-based adaptive equalizer on complex stream.

    Warning: This block does not yet work.

    "Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind equalization algorithm," IEEE Conf. on Control, Automation,
    Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057."

    Constructor Specific Documentation:



    Args:
        num_taps : 
        mu : 
    """
  return _digital_swig.kurtotic_equalizer_cc_make(*args, **kwargs)

class lfsr(object):
    """
    Fibonacci Linear Feedback Shift Register using specified polynomial mask.

    Generates a maximal length pseudo-random sequence of length 2^degree-1

    Constructor: digital::lfsr(int mask, int seed, int reg_len);


    Some common masks might be: x^4 + x^3 + x^0 = 0x19 x^5 + x^3 + x^0 = 0x29 x^6 + x^5 + x^0 = 0x61


    see  for more explanation.

    next_bit() - Standard LFSR operation 

    next_bit_scramble(unsigned char input) - Scramble an input stream 

    next_bit_descramble(unsigned char input) - Descramble an input stream 

    See  for operation of these last two functions (see multiplicative scrambler.)

    Args:
        mask : - polynomial coefficients representing the locations of feedback taps from a shift register which are xor'ed together to form the new high order bit.
        seed : - the initialization vector placed into the register durring initialization. Low order bit corresponds to x^0 coefficient  the first to be shifted as output.
        reg_len : - specifies the length of the feedback shift register to be used. Durring each iteration, the register is rightshifted one and the new bit is placed in bit reg_len. reg_len should generally be at least order(mask) + 1
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(gr::digital::lfsr self, uint32_t mask, uint32_t seed, uint32_t reg_len) -> lfsr"""
        this = _digital_swig.new_lfsr(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def next_bit(self):
        """next_bit(lfsr self) -> unsigned char"""
        return _digital_swig.lfsr_next_bit(self)

    def next_bit_scramble(self, *args, **kwargs):
        """next_bit_scramble(lfsr self, unsigned char input) -> unsigned char"""
        return _digital_swig.lfsr_next_bit_scramble(self, *args, **kwargs)

    def next_bit_descramble(self, *args, **kwargs):
        """next_bit_descramble(lfsr self, unsigned char input) -> unsigned char"""
        return _digital_swig.lfsr_next_bit_descramble(self, *args, **kwargs)

    def reset(self):
        """
        reset(lfsr self)

        Reset shift register to initial seed value
        """
        return _digital_swig.lfsr_reset(self)

    def pre_shift(self, *args, **kwargs):
        """
        pre_shift(lfsr self, int num)

        Rotate the register through x number of bits where we are just throwing away the results to get queued up correctly
        """
        return _digital_swig.lfsr_pre_shift(self, *args, **kwargs)

    def mask(self):
        """mask(lfsr self) -> int"""
        return _digital_swig.lfsr_mask(self)

    __swig_destroy__ = _digital_swig.delete_lfsr
    __del__ = lambda self : None;
lfsr_swigregister = _digital_swig.lfsr_swigregister
lfsr_swigregister(lfsr)

class lms_dd_equalizer_cc(object):
    """
    Least-Mean-Square Decision Directed Equalizer (complex in/out)

    This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update the weight vector.

    y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

    Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

    This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like:

    self.constellation = digital.constellation_qpsk()

    To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

    The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.

    Constructor Specific Documentation:

    Make an LMS decision-directed equalizer

    Args:
        num_taps : Numer of taps in the equalizer (channel size)
        mu : Gain of the update loop
        sps : Number of samples per symbol of the input signal
        cnst : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int num_taps, float mu, int sps, constellation_sptr cnst) -> lms_dd_equalizer_cc_sptr

        Least-Mean-Square Decision Directed Equalizer (complex in/out)

        This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update the weight vector.

        y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

        Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

        This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like:

        self.constellation = digital.constellation_qpsk()

        To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

        The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.

        Constructor Specific Documentation:

        Make an LMS decision-directed equalizer

        Args:
            num_taps : Numer of taps in the equalizer (channel size)
            mu : Gain of the update loop
            sps : Number of samples per symbol of the input signal
            cnst : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.lms_dd_equalizer_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def set_taps(self, *args, **kwargs):
        """set_taps(lms_dd_equalizer_cc self, pmt_vector_cfloat taps)"""
        return _digital_swig.lms_dd_equalizer_cc_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(lms_dd_equalizer_cc self) -> pmt_vector_cfloat"""
        return _digital_swig.lms_dd_equalizer_cc_taps(self)

    def gain(self):
        """gain(lms_dd_equalizer_cc self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(lms_dd_equalizer_cc self, float mu)"""
        return _digital_swig.lms_dd_equalizer_cc_set_gain(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_lms_dd_equalizer_cc
    __del__ = lambda self : None;
lms_dd_equalizer_cc_swigregister = _digital_swig.lms_dd_equalizer_cc_swigregister
lms_dd_equalizer_cc_swigregister(lms_dd_equalizer_cc)

def lms_dd_equalizer_cc_make(*args, **kwargs):
  """
    lms_dd_equalizer_cc_make(int num_taps, float mu, int sps, constellation_sptr cnst) -> lms_dd_equalizer_cc_sptr

    Least-Mean-Square Decision Directed Equalizer (complex in/out)

    This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update the weight vector.

    y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

    Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

    This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like:

    self.constellation = digital.constellation_qpsk()

    To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

    The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.

    Constructor Specific Documentation:

    Make an LMS decision-directed equalizer

    Args:
        num_taps : Numer of taps in the equalizer (channel size)
        mu : Gain of the update loop
        sps : Number of samples per symbol of the input signal
        cnst : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
    """
  return _digital_swig.lms_dd_equalizer_cc_make(*args, **kwargs)

class map_bb(object):
    """
    output[i] = map[input[i]]

    This block maps an incoming signal to the value in the map. The block expects that the incoming signal has a maximum value of len(map)-1.

    -> output[i] = map[input[i]]

    Constructor Specific Documentation:

    Make a map block.

    Args:
        map : a vector of integers that maps x to map[x].
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > const & map) -> map_bb_sptr

        output[i] = map[input[i]]

        This block maps an incoming signal to the value in the map. The block expects that the incoming signal has a maximum value of len(map)-1.

        -> output[i] = map[input[i]]

        Constructor Specific Documentation:

        Make a map block.

        Args:
            map : a vector of integers that maps x to map[x].
        """
        return _digital_swig.map_bb_make(*args, **kwargs)

    make = staticmethod(make)
    def set_map(self, *args, **kwargs):
        """set_map(map_bb self, std::vector< int,std::allocator< int > > const & map)"""
        return _digital_swig.map_bb_set_map(self, *args, **kwargs)

    def map(self):
        """
        map(map_bb self) -> std::vector< int,std::allocator< int > >

        Apply  element-wise to the elements of list and returns a list of the results, in order.

        must be a list. The dynamic order in which  is applied to the elements of  is unspecified.
        """
        return _digital_swig.map_bb_map(self)

    __swig_destroy__ = _digital_swig.delete_map_bb
    __del__ = lambda self : None;
map_bb_swigregister = _digital_swig.map_bb_swigregister
map_bb_swigregister(map_bb)

def map_bb_make(*args, **kwargs):
  """
    map_bb_make(std::vector< int,std::allocator< int > > const & map) -> map_bb_sptr

    output[i] = map[input[i]]

    This block maps an incoming signal to the value in the map. The block expects that the incoming signal has a maximum value of len(map)-1.

    -> output[i] = map[input[i]]

    Constructor Specific Documentation:

    Make a map block.

    Args:
        map : a vector of integers that maps x to map[x].
    """
  return _digital_swig.map_bb_make(*args, **kwargs)

TRELLIS_EUCLIDEAN = _digital_swig.TRELLIS_EUCLIDEAN
TRELLIS_HARD_SYMBOL = _digital_swig.TRELLIS_HARD_SYMBOL
TRELLIS_HARD_BIT = _digital_swig.TRELLIS_HARD_BIT
class mpsk_receiver_cc(control_loop):
    """
    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

    It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    "G. R. Danesfahani, T. G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
    June 1995, pp. 1032 - 1033."

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

    Constructor Specific Documentation:

    Make a M-PSK receiver block.

    The constructor also chooses which phase detector and decision maker to use in the work loop based on the value of M.

    Args:
        M : modulation order of the M-PSK modulation
        theta : any constant phase rotation from the real axis of the constellation
        loop_bw : Loop bandwidth to set gains of phase/freq tracking loop
        fmin : minimum normalized frequency value the loop can achieve
        fmax : maximum normalized frequency value the loop can achieve
        mu : initial parameter for the interpolator [0,1]
        gain_mu : gain parameter of the M&M error signal to adjust mu (~0.05)
        omega : initial value for the number of symbols between samples (~number of samples/symbol)
        gain_omega : gain parameter to adjust omega based on the error (~omega^2/4)
        omega_rel : sets the maximum (omega*(1+omega_rel)) and minimum (omega*(1+omega_rel)) omega (~0.005)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int M, float theta, float loop_bw, float fmin, float fmax, float mu, float gain_mu, 
            float omega, float gain_omega, float omega_rel) -> mpsk_receiver_cc_sptr

        This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

        It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

        The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

        The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

        "G. R. Danesfahani, T. G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
        June 1995, pp. 1032 - 1033."

        This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

        Constructor Specific Documentation:

        Make a M-PSK receiver block.

        The constructor also chooses which phase detector and decision maker to use in the work loop based on the value of M.

        Args:
            M : modulation order of the M-PSK modulation
            theta : any constant phase rotation from the real axis of the constellation
            loop_bw : Loop bandwidth to set gains of phase/freq tracking loop
            fmin : minimum normalized frequency value the loop can achieve
            fmax : maximum normalized frequency value the loop can achieve
            mu : initial parameter for the interpolator [0,1]
            gain_mu : gain parameter of the M&M error signal to adjust mu (~0.05)
            omega : initial value for the number of symbols between samples (~number of samples/symbol)
            gain_omega : gain parameter to adjust omega based on the error (~omega^2/4)
            omega_rel : sets the maximum (omega*(1+omega_rel)) and minimum (omega*(1+omega_rel)) omega (~0.005)
        """
        return _digital_swig.mpsk_receiver_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def modulation_order(self):
        """
        modulation_order(mpsk_receiver_cc self) -> float

        Returns the modulation order (M) currently set.
        """
        return _digital_swig.mpsk_receiver_cc_modulation_order(self)

    def theta(self):
        """
        theta(mpsk_receiver_cc self) -> float

        Returns current value of theta.
        """
        return _digital_swig.mpsk_receiver_cc_theta(self)

    def mu(self):
        """
        mu(mpsk_receiver_cc self) -> float

        Returns current value of mu.
        """
        return _digital_swig.mpsk_receiver_cc_mu(self)

    def omega(self):
        """
        omega(mpsk_receiver_cc self) -> float

        Returns current value of omega.
        """
        return _digital_swig.mpsk_receiver_cc_omega(self)

    def gain_mu(self):
        """
        gain_mu(mpsk_receiver_cc self) -> float

        Returns mu gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(mpsk_receiver_cc self) -> float

        Returns omega gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_gain_omega(self)

    def gain_omega_rel(self):
        """
        gain_omega_rel(mpsk_receiver_cc self) -> float

        Returns the relative omega limit.
        """
        return _digital_swig.mpsk_receiver_cc_gain_omega_rel(self)

    def set_modulation_order(self, *args, **kwargs):
        """
        set_modulation_order(mpsk_receiver_cc self, unsigned int M)

        Sets the modulation order (M) currently.
        """
        return _digital_swig.mpsk_receiver_cc_set_modulation_order(self, *args, **kwargs)

    def set_theta(self, *args, **kwargs):
        """
        set_theta(mpsk_receiver_cc self, float theta)

        Sets value of theta.
        """
        return _digital_swig.mpsk_receiver_cc_set_theta(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(mpsk_receiver_cc self, float mu)

        Sets value of mu.
        """
        return _digital_swig.mpsk_receiver_cc_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(mpsk_receiver_cc self, float omega)

        Sets value of omega and its min and max values.
        """
        return _digital_swig.mpsk_receiver_cc_set_omega(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(mpsk_receiver_cc self, float gain_mu)

        Sets value for mu gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(mpsk_receiver_cc self, float gain_omega)

        Sets value for omega gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_set_gain_omega(self, *args, **kwargs)

    def set_gain_omega_rel(self, *args, **kwargs):
        """
        set_gain_omega_rel(mpsk_receiver_cc self, float omega_rel)

        Sets the relative omega limit and resets omega min/max values.
        """
        return _digital_swig.mpsk_receiver_cc_set_gain_omega_rel(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_mpsk_receiver_cc
    __del__ = lambda self : None;
mpsk_receiver_cc_swigregister = _digital_swig.mpsk_receiver_cc_swigregister
mpsk_receiver_cc_swigregister(mpsk_receiver_cc)

def mpsk_receiver_cc_make(*args, **kwargs):
  """
    mpsk_receiver_cc_make(unsigned int M, float theta, float loop_bw, float fmin, float fmax, float mu, float gain_mu, 
        float omega, float gain_omega, float omega_rel) -> mpsk_receiver_cc_sptr

    This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

    It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

    The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

    The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

    "G. R. Danesfahani, T. G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
    June 1995, pp. 1032 - 1033."

    This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

    Constructor Specific Documentation:

    Make a M-PSK receiver block.

    The constructor also chooses which phase detector and decision maker to use in the work loop based on the value of M.

    Args:
        M : modulation order of the M-PSK modulation
        theta : any constant phase rotation from the real axis of the constellation
        loop_bw : Loop bandwidth to set gains of phase/freq tracking loop
        fmin : minimum normalized frequency value the loop can achieve
        fmax : maximum normalized frequency value the loop can achieve
        mu : initial parameter for the interpolator [0,1]
        gain_mu : gain parameter of the M&M error signal to adjust mu (~0.05)
        omega : initial value for the number of symbols between samples (~number of samples/symbol)
        gain_omega : gain parameter to adjust omega based on the error (~omega^2/4)
        omega_rel : sets the maximum (omega*(1+omega_rel)) and minimum (omega*(1+omega_rel)) omega (~0.005)
    """
  return _digital_swig.mpsk_receiver_cc_make(*args, **kwargs)

SNR_EST_SIMPLE = _digital_swig.SNR_EST_SIMPLE
SNR_EST_SKEW = _digital_swig.SNR_EST_SKEW
SNR_EST_M2M4 = _digital_swig.SNR_EST_M2M4
SNR_EST_SVR = _digital_swig.SNR_EST_SVR
class mpsk_snr_est(object):
    """A parent class for SNR estimators, specifically for M-PSK signals in AWGN channels."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::mpsk_snr_est self, double alpha) -> mpsk_snr_est

        Constructor

        Parameters:
        """
        this = _digital_swig.new_mpsk_snr_est(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est
    __del__ = lambda self : None;
    def alpha(self):
        """
        alpha(mpsk_snr_est self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_alpha(self)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(mpsk_snr_est self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_set_alpha(self, *args, **kwargs)

    def update(self, *args, **kwargs):
        """
        update(mpsk_snr_est self, int noutput_items, gr_complex const * input) -> int

        Update the current registers.
        """
        return _digital_swig.mpsk_snr_est_update(self, *args, **kwargs)

    def snr(self):
        """
        snr(mpsk_snr_est self) -> double

        Use the register values to compute a new estimate.
        """
        return _digital_swig.mpsk_snr_est_snr(self)

mpsk_snr_est_swigregister = _digital_swig.mpsk_snr_est_swigregister
mpsk_snr_est_swigregister(mpsk_snr_est)

class mpsk_snr_est_simple(mpsk_snr_est):
    """
    SNR Estimator using simple mean/variance estimates.

    A very simple SNR estimator that just uses mean and variance estimates of an M-PSK constellation. This esimator is quick and cheap and accurate for high SNR (above 7 dB or so) but quickly starts to overestimate the SNR at low SNR.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::mpsk_snr_est_simple self, double alpha) -> mpsk_snr_est_simple

        Constructor

        Parameters:
        """
        this = _digital_swig.new_mpsk_snr_est_simple(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_simple
    __del__ = lambda self : None;
mpsk_snr_est_simple_swigregister = _digital_swig.mpsk_snr_est_simple_swigregister
mpsk_snr_est_simple_swigregister(mpsk_snr_est_simple)

class mpsk_snr_est_skew(mpsk_snr_est):
    """
    SNR Estimator using skewness correction.

    This is an estimator that came from a discussion between Tom Rondeau and fred harris with no known paper reference. The idea is that at low SNR, the variance estimations will be affected because of fold-over around the decision boundaries, which results in a skewness to the samples. We estimate the skewness and use this as a correcting term.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::mpsk_snr_est_skew self, double alpha) -> mpsk_snr_est_skew

        Constructor

        Parameters:
        """
        this = _digital_swig.new_mpsk_snr_est_skew(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_skew
    __del__ = lambda self : None;
mpsk_snr_est_skew_swigregister = _digital_swig.mpsk_snr_est_skew_swigregister
mpsk_snr_est_skew_swigregister(mpsk_snr_est_skew)

class mpsk_snr_est_m2m4(mpsk_snr_est):
    """
    SNR Estimator using 2nd and 4th-order moments.

    An SNR estimator for M-PSK signals that uses 2nd (M2) and 4th (M4) order moments. This estimator uses knowledge of the kurtosis of the signal (k_a) and noise (k_w) to make its estimation. We use Beaulieu's approximations here to M-PSK signals and AWGN channels such that k_a=1 and k_w=2. These approximations significantly reduce the complexity of the calculations (and computations) required.

    Reference: D. R. Pauluzzi and N. C. Beaulieu, "A comparison of SNR
    estimation techniques for the AWGN channel," IEEE Trans. Communications, Vol. 48, No. 10, pp. 1681-1691, 2000.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::mpsk_snr_est_m2m4 self, double alpha) -> mpsk_snr_est_m2m4

        Constructor

        Parameters:
        """
        this = _digital_swig.new_mpsk_snr_est_m2m4(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_m2m4
    __del__ = lambda self : None;
mpsk_snr_est_m2m4_swigregister = _digital_swig.mpsk_snr_est_m2m4_swigregister
mpsk_snr_est_m2m4_swigregister(mpsk_snr_est_m2m4)

class snr_est_m2m4(mpsk_snr_est):
    """
    SNR Estimator using 2nd and 4th-order moments.

    An SNR estimator for M-PSK signals that uses 2nd (M2) and 4th (M4) order moments. This estimator uses knowledge of the kurtosis of the signal (k_a) and noise (k_w) to make its estimation. In this case, you can set your own estimations for k_a and k_w, the kurtosis of the signal and noise, to fit this estimation better to your signal and channel conditions.

    A word of warning: this estimator has not been fully tested or proved with any amount of rigor. The estimation for M4 in particular might be ignoring effectf of when k_a and k_w are different. Use this estimator with caution and a copy of the reference on hand.

    The digital_mpsk_snr_est_m2m4 assumes k_a and k_w to simplify the computations for M-PSK and AWGN channels. Use that estimator unless you have a way to guess or estimate these values here.

    Original paper: R. Matzner, "An SNR estimation algorithm for complex baseband
    signal using higher order statistics," Facta Universitatis (Nis), no. 6, pp. 41-52, 1993.

    Reference used in derivation: D. R. Pauluzzi and N. C. Beaulieu, "A comparison of SNR
    estimation techniques for the AWGN channel," IEEE Trans. Communications, Vol. 48, No. 10, pp. 1681-1691, 2000.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::snr_est_m2m4 self, double alpha, double ka, double kw) -> snr_est_m2m4

        Constructor

        Parameters:
        """
        this = _digital_swig.new_snr_est_m2m4(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_snr_est_m2m4
    __del__ = lambda self : None;
snr_est_m2m4_swigregister = _digital_swig.snr_est_m2m4_swigregister
snr_est_m2m4_swigregister(snr_est_m2m4)

class mpsk_snr_est_svr(mpsk_snr_est):
    """
    Signal-to-Variation Ratio SNR Estimator.

    This estimator actually comes from an SNR estimator for M-PSK signals in fading channels, but this implementation is specifically for AWGN channels. The math was simplified to assume a signal and noise kurtosis (k_a and k_w) for M-PSK signals in AWGN. These approximations significantly reduce the complexity of the calculations (and computations) required.

    Original paper: A. L. Brandao, L. B. Lopes, and D. C. McLernon, "In-service monitoring of multipath delay and cochannel interference for indoor mobile communication systems," Proc. IEEE Int. Conf. Communications, vol. 3, pp. 1458-1462, May 1994.

    Reference: D. R. Pauluzzi and N. C. Beaulieu, "A comparison of SNR
    estimation techniques for the AWGN channel," IEEE Trans. Communications, Vol. 48, No. 10, pp. 1681-1691, 2000.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::mpsk_snr_est_svr self, double alpha) -> mpsk_snr_est_svr

        Constructor

        Parameters:
        """
        this = _digital_swig.new_mpsk_snr_est_svr(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_svr
    __del__ = lambda self : None;
mpsk_snr_est_svr_swigregister = _digital_swig.mpsk_snr_est_svr_swigregister
mpsk_snr_est_svr_swigregister(mpsk_snr_est_svr)

class mpsk_snr_est_cc(object):
    """
    A block for computing SNR of a signal.

    This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

    The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Constructor Specific Documentation:

    Factory function returning shared pointer of this class

    Args:
        type : the type of estimator to use gr::digital::snr_est_type_t "snr_est_type_t" for details about the available types
        tag_nsamples : after this many samples, a tag containing the SNR (key='snr') will be sent
        alpha : the update rate of internal running average calculations
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(gr::digital::snr_est_type_t type, int tag_nsamples=10000, double alpha=0.001) -> mpsk_snr_est_cc_sptr

        A block for computing SNR of a signal.

        This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

        The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

        Constructor Specific Documentation:

        Factory function returning shared pointer of this class

        Args:
            type : the type of estimator to use gr::digital::snr_est_type_t "snr_est_type_t" for details about the available types
            tag_nsamples : after this many samples, a tag containing the SNR (key='snr') will be sent
            alpha : the update rate of internal running average calculations
        """
        return _digital_swig.mpsk_snr_est_cc_make(*args, **kwargs)

    make = staticmethod(make)
    def snr(self):
        """
        snr(mpsk_snr_est_cc self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.mpsk_snr_est_cc_snr(self)

    def type(self):
        """
        type(mpsk_snr_est_cc self) -> gr::digital::snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.mpsk_snr_est_cc_type(self)

    def tag_nsample(self):
        """
        tag_nsample(mpsk_snr_est_cc self) -> int

        Return how many samples between SNR tags.
        """
        return _digital_swig.mpsk_snr_est_cc_tag_nsample(self)

    def alpha(self):
        """
        alpha(mpsk_snr_est_cc self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_cc_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(mpsk_snr_est_cc self, gr::digital::snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.mpsk_snr_est_cc_set_type(self, *args, **kwargs)

    def set_tag_nsample(self, *args, **kwargs):
        """
        set_tag_nsample(mpsk_snr_est_cc self, int n)

        Set the number of samples between SNR tags.
        """
        return _digital_swig.mpsk_snr_est_cc_set_tag_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(mpsk_snr_est_cc self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_cc_set_alpha(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_cc
    __del__ = lambda self : None;
mpsk_snr_est_cc_swigregister = _digital_swig.mpsk_snr_est_cc_swigregister
mpsk_snr_est_cc_swigregister(mpsk_snr_est_cc)

def mpsk_snr_est_cc_make(*args, **kwargs):
  """
    mpsk_snr_est_cc_make(gr::digital::snr_est_type_t type, int tag_nsamples=10000, double alpha=0.001) -> mpsk_snr_est_cc_sptr

    A block for computing SNR of a signal.

    This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

    The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Constructor Specific Documentation:

    Factory function returning shared pointer of this class

    Args:
        type : the type of estimator to use gr::digital::snr_est_type_t "snr_est_type_t" for details about the available types
        tag_nsamples : after this many samples, a tag containing the SNR (key='snr') will be sent
        alpha : the update rate of internal running average calculations
    """
  return _digital_swig.mpsk_snr_est_cc_make(*args, **kwargs)

class ofdm_carrier_allocator_cvc(object):
    """
    Create frequency domain OFDM symbols from complex values, add pilots.

    This block turns a stream of complex, scalar modulation symbols into vectors which are the input for an IFFT in an OFDM transmitter. It also supports the possibility of placing pilot symbols onto the carriers.

    The carriers can be allocated freely, if a carrier is not allocated, it is set to zero. This allows doing OFDMA-style carrier allocations.

    Input: A tagged stream of complex scalars. The first item must have a tag containing the number of complex symbols in this frame. Output: A tagged stream of complex vectors of length fft_len. This can directly be connected to an FFT block. Make sure to set this block to 'reverse' for the IFFT. If  is true, the FFT block must activate FFT shifting, otherwise, set shifting to false. If given, sync words are prepended to the output. Note that sync words are prepended verbatim, make sure they are shifted (or not).

    Carrier indexes are always such that index 0 is the DC carrier (note: you should not allocate this carrier). The carriers below the DC carrier are either indexed with negative numbers, or with indexes larger than . Index -1 and index  both identify the carrier below the DC carrier.

    There are some basic checks in place during initialization which check that the carrier allocation table is valid. However, it is possible to overwrite data symbols with pilot symbols, or provide a carrier allocation that has mismatching pilot symbol positions and -values.

    Tags are propagated such that a tag on an incoming complex symbol is mapped to the corresponding OFDM symbol. There is one exception: If a tag is on the first OFDM symbol, it is assumed that this tag should stay there, so it is moved to the front even if a sync word is included (any other tags will never be attached to the sync word). This allows tags to control the transmit timing to pass through in the correct position.

    Constructor Specific Documentation:



    Args:
        fft_len : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        sync_words : 
        len_tag_key : 
        output_is_shifted : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def len_tag_key(self):
        """len_tag_key(ofdm_carrier_allocator_cvc self) -> std::string"""
        return _digital_swig.ofdm_carrier_allocator_cvc_len_tag_key(self)

    def fft_len(self):
        """fft_len(ofdm_carrier_allocator_cvc self) -> int const"""
        return _digital_swig.ofdm_carrier_allocator_cvc_fft_len(self)

    def occupied_carriers(self):
        """occupied_carriers(ofdm_carrier_allocator_cvc self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >"""
        return _digital_swig.ofdm_carrier_allocator_cvc_occupied_carriers(self)

    def make(*args, **kwargs):
        """
        make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

        Create frequency domain OFDM symbols from complex values, add pilots.

        This block turns a stream of complex, scalar modulation symbols into vectors which are the input for an IFFT in an OFDM transmitter. It also supports the possibility of placing pilot symbols onto the carriers.

        The carriers can be allocated freely, if a carrier is not allocated, it is set to zero. This allows doing OFDMA-style carrier allocations.

        Input: A tagged stream of complex scalars. The first item must have a tag containing the number of complex symbols in this frame. Output: A tagged stream of complex vectors of length fft_len. This can directly be connected to an FFT block. Make sure to set this block to 'reverse' for the IFFT. If  is true, the FFT block must activate FFT shifting, otherwise, set shifting to false. If given, sync words are prepended to the output. Note that sync words are prepended verbatim, make sure they are shifted (or not).

        Carrier indexes are always such that index 0 is the DC carrier (note: you should not allocate this carrier). The carriers below the DC carrier are either indexed with negative numbers, or with indexes larger than . Index -1 and index  both identify the carrier below the DC carrier.

        There are some basic checks in place during initialization which check that the carrier allocation table is valid. However, it is possible to overwrite data symbols with pilot symbols, or provide a carrier allocation that has mismatching pilot symbol positions and -values.

        Tags are propagated such that a tag on an incoming complex symbol is mapped to the corresponding OFDM symbol. There is one exception: If a tag is on the first OFDM symbol, it is assumed that this tag should stay there, so it is moved to the front even if a sync word is included (any other tags will never be attached to the sync word). This allows tags to control the transmit timing to pass through in the correct position.

        Constructor Specific Documentation:



        Args:
            fft_len : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            sync_words : 
            len_tag_key : 
            output_is_shifted : 
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_carrier_allocator_cvc
    __del__ = lambda self : None;
ofdm_carrier_allocator_cvc_swigregister = _digital_swig.ofdm_carrier_allocator_cvc_swigregister
ofdm_carrier_allocator_cvc_swigregister(ofdm_carrier_allocator_cvc)

def ofdm_carrier_allocator_cvc_make(*args, **kwargs):
  """
    ofdm_carrier_allocator_cvc_make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
        gr_vector_vector_complexf pilot_symbols, 
        gr_vector_vector_complexf sync_words, 
        std::string const & len_tag_key="packet_len", 
        bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

    Create frequency domain OFDM symbols from complex values, add pilots.

    This block turns a stream of complex, scalar modulation symbols into vectors which are the input for an IFFT in an OFDM transmitter. It also supports the possibility of placing pilot symbols onto the carriers.

    The carriers can be allocated freely, if a carrier is not allocated, it is set to zero. This allows doing OFDMA-style carrier allocations.

    Input: A tagged stream of complex scalars. The first item must have a tag containing the number of complex symbols in this frame. Output: A tagged stream of complex vectors of length fft_len. This can directly be connected to an FFT block. Make sure to set this block to 'reverse' for the IFFT. If  is true, the FFT block must activate FFT shifting, otherwise, set shifting to false. If given, sync words are prepended to the output. Note that sync words are prepended verbatim, make sure they are shifted (or not).

    Carrier indexes are always such that index 0 is the DC carrier (note: you should not allocate this carrier). The carriers below the DC carrier are either indexed with negative numbers, or with indexes larger than . Index -1 and index  both identify the carrier below the DC carrier.

    There are some basic checks in place during initialization which check that the carrier allocation table is valid. However, it is possible to overwrite data symbols with pilot symbols, or provide a carrier allocation that has mismatching pilot symbol positions and -values.

    Tags are propagated such that a tag on an incoming complex symbol is mapped to the corresponding OFDM symbol. There is one exception: If a tag is on the first OFDM symbol, it is assumed that this tag should stay there, so it is moved to the front even if a sync word is included (any other tags will never be attached to the sync word). This allows tags to control the transmit timing to pass through in the correct position.

    Constructor Specific Documentation:



    Args:
        fft_len : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        sync_words : 
        len_tag_key : 
        output_is_shifted : 
    """
  return _digital_swig.ofdm_carrier_allocator_cvc_make(*args, **kwargs)

class ofdm_chanest_vcvc(object):
    """
    Estimate channel and coarse frequency offset for OFDM from preambles

    Input: OFDM symbols (in frequency domain). The first one (or two) symbols are expected to be synchronisation symbols, which are used to estimate the coarse freq offset and the initial equalizer taps (these symbols are removed from the stream). The following  are passed through unmodified (the actual equalisation must be done elsewhere). Output: The data symbols, without the synchronisation symbols. The first data symbol passed through has two tags: 'ofdm_sync_carr_offset' (integer), the coarse frequency offset as number of carriers, and 'ofdm_sync_eq_taps' (complex vector). Any tags attached to the synchronisation symbols are attached to the first data symbol. All other tags are propagated as expected.

    Note: The vector on ofdm_sync_eq_taps is already frequency-corrected, whereas the rest is not.

    This block assumes the frequency offset is even (i.e. an integer multiple of 2).

    [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997. [2] K.D. Kammeyer, "Nachrichtenuebertragung," Chapter. 16.3.2.

    Constructor Specific Documentation:



    Args:
        sync_symbol1 : First synchronisation symbol in the frequency domain. Its length must be the FFT length. For Schmidl & Cox synchronisation, every second sub-carrier has to be zero.
        sync_symbol2 : Second synchronisation symbol in the frequency domain. Must be equal to the FFT length, or zero length if only one synchronisation symbol is used. Using this symbol is how synchronisation is described in [1]. Leaving this empty forces us to interpolate the equalizer taps. If you are using an unusual sub-carrier configuration (e.g. because of OFDMA), this sync symbol is used to identify the active sub-carriers. If you only have one synchronisation symbol, set the active sub-carriers to a non-zero value in here, and also set  parameter to true.
        n_data_symbols : The number of data symbols following each set of synchronisation symbols. Must be at least 1.
        eq_noise_red_len : If non-zero, noise reduction for the equalizer taps is done according to [2]. In this case, it is the channel influence time in number of samples. A good value is usually the length of the cyclic prefix.
        max_carr_offset : Limit the number of sub-carriers the frequency offset can maximally be. Leave this zero to try all possibilities.
        force_one_sync_symbol : See .
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
            int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

        Estimate channel and coarse frequency offset for OFDM from preambles

        Input: OFDM symbols (in frequency domain). The first one (or two) symbols are expected to be synchronisation symbols, which are used to estimate the coarse freq offset and the initial equalizer taps (these symbols are removed from the stream). The following  are passed through unmodified (the actual equalisation must be done elsewhere). Output: The data symbols, without the synchronisation symbols. The first data symbol passed through has two tags: 'ofdm_sync_carr_offset' (integer), the coarse frequency offset as number of carriers, and 'ofdm_sync_eq_taps' (complex vector). Any tags attached to the synchronisation symbols are attached to the first data symbol. All other tags are propagated as expected.

        Note: The vector on ofdm_sync_eq_taps is already frequency-corrected, whereas the rest is not.

        This block assumes the frequency offset is even (i.e. an integer multiple of 2).

        [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997. [2] K.D. Kammeyer, "Nachrichtenuebertragung," Chapter. 16.3.2.

        Constructor Specific Documentation:



        Args:
            sync_symbol1 : First synchronisation symbol in the frequency domain. Its length must be the FFT length. For Schmidl & Cox synchronisation, every second sub-carrier has to be zero.
            sync_symbol2 : Second synchronisation symbol in the frequency domain. Must be equal to the FFT length, or zero length if only one synchronisation symbol is used. Using this symbol is how synchronisation is described in [1]. Leaving this empty forces us to interpolate the equalizer taps. If you are using an unusual sub-carrier configuration (e.g. because of OFDMA), this sync symbol is used to identify the active sub-carriers. If you only have one synchronisation symbol, set the active sub-carriers to a non-zero value in here, and also set  parameter to true.
            n_data_symbols : The number of data symbols following each set of synchronisation symbols. Must be at least 1.
            eq_noise_red_len : If non-zero, noise reduction for the equalizer taps is done according to [2]. In this case, it is the channel influence time in number of samples. A good value is usually the length of the cyclic prefix.
            max_carr_offset : Limit the number of sub-carriers the frequency offset can maximally be. Leave this zero to try all possibilities.
            force_one_sync_symbol : See .
        """
        return _digital_swig.ofdm_chanest_vcvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_chanest_vcvc
    __del__ = lambda self : None;
ofdm_chanest_vcvc_swigregister = _digital_swig.ofdm_chanest_vcvc_swigregister
ofdm_chanest_vcvc_swigregister(ofdm_chanest_vcvc)

def ofdm_chanest_vcvc_make(*args, **kwargs):
  """
    ofdm_chanest_vcvc_make(pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
        int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

    Estimate channel and coarse frequency offset for OFDM from preambles

    Input: OFDM symbols (in frequency domain). The first one (or two) symbols are expected to be synchronisation symbols, which are used to estimate the coarse freq offset and the initial equalizer taps (these symbols are removed from the stream). The following  are passed through unmodified (the actual equalisation must be done elsewhere). Output: The data symbols, without the synchronisation symbols. The first data symbol passed through has two tags: 'ofdm_sync_carr_offset' (integer), the coarse frequency offset as number of carriers, and 'ofdm_sync_eq_taps' (complex vector). Any tags attached to the synchronisation symbols are attached to the first data symbol. All other tags are propagated as expected.

    Note: The vector on ofdm_sync_eq_taps is already frequency-corrected, whereas the rest is not.

    This block assumes the frequency offset is even (i.e. an integer multiple of 2).

    [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997. [2] K.D. Kammeyer, "Nachrichtenuebertragung," Chapter. 16.3.2.

    Constructor Specific Documentation:



    Args:
        sync_symbol1 : First synchronisation symbol in the frequency domain. Its length must be the FFT length. For Schmidl & Cox synchronisation, every second sub-carrier has to be zero.
        sync_symbol2 : Second synchronisation symbol in the frequency domain. Must be equal to the FFT length, or zero length if only one synchronisation symbol is used. Using this symbol is how synchronisation is described in [1]. Leaving this empty forces us to interpolate the equalizer taps. If you are using an unusual sub-carrier configuration (e.g. because of OFDMA), this sync symbol is used to identify the active sub-carriers. If you only have one synchronisation symbol, set the active sub-carriers to a non-zero value in here, and also set  parameter to true.
        n_data_symbols : The number of data symbols following each set of synchronisation symbols. Must be at least 1.
        eq_noise_red_len : If non-zero, noise reduction for the equalizer taps is done according to [2]. In this case, it is the channel influence time in number of samples. A good value is usually the length of the cyclic prefix.
        max_carr_offset : Limit the number of sub-carriers the frequency offset can maximally be. Leave this zero to try all possibilities.
        force_one_sync_symbol : See .
    """
  return _digital_swig.ofdm_chanest_vcvc_make(*args, **kwargs)

class ofdm_cyclic_prefixer(object):
    """
    Adds a cyclic prefix and performs pulse shaping on OFDM symbols.

    Input: OFDM symbols (in the time domain, i.e. after the IFFT). Optionally, entire frames can be processed. In this case,  must be specified which holds the key of the tag that denotes how many OFDM symbols are in a frame. Output: A stream of (scalar) complex symbols, which include the cyclic prefix and the pulse shaping. Note: If complete frames are processed, and  is greater than zero, the final OFDM symbol is followed by the delay line of the pulse shaping.

    The pulse shape is a raised cosine in the time domain.

    Constructor Specific Documentation:



    Args:
        input_size : FFT length (i.e. length of the OFDM symbols)
        output_size : FFT length + cyclic prefix length (in samples)
        rolloff_len : Length of the rolloff flank in samples
        len_tag_key : For framed processing the key of the length tag
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

        Adds a cyclic prefix and performs pulse shaping on OFDM symbols.

        Input: OFDM symbols (in the time domain, i.e. after the IFFT). Optionally, entire frames can be processed. In this case,  must be specified which holds the key of the tag that denotes how many OFDM symbols are in a frame. Output: A stream of (scalar) complex symbols, which include the cyclic prefix and the pulse shaping. Note: If complete frames are processed, and  is greater than zero, the final OFDM symbol is followed by the delay line of the pulse shaping.

        The pulse shape is a raised cosine in the time domain.

        Constructor Specific Documentation:



        Args:
            input_size : FFT length (i.e. length of the OFDM symbols)
            output_size : FFT length + cyclic prefix length (in samples)
            rolloff_len : Length of the rolloff flank in samples
            len_tag_key : For framed processing the key of the length tag
        """
        return _digital_swig.ofdm_cyclic_prefixer_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_cyclic_prefixer
    __del__ = lambda self : None;
ofdm_cyclic_prefixer_swigregister = _digital_swig.ofdm_cyclic_prefixer_swigregister
ofdm_cyclic_prefixer_swigregister(ofdm_cyclic_prefixer)

def ofdm_cyclic_prefixer_make(*args, **kwargs):
  """
    ofdm_cyclic_prefixer_make(size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

    Adds a cyclic prefix and performs pulse shaping on OFDM symbols.

    Input: OFDM symbols (in the time domain, i.e. after the IFFT). Optionally, entire frames can be processed. In this case,  must be specified which holds the key of the tag that denotes how many OFDM symbols are in a frame. Output: A stream of (scalar) complex symbols, which include the cyclic prefix and the pulse shaping. Note: If complete frames are processed, and  is greater than zero, the final OFDM symbol is followed by the delay line of the pulse shaping.

    The pulse shape is a raised cosine in the time domain.

    Constructor Specific Documentation:



    Args:
        input_size : FFT length (i.e. length of the OFDM symbols)
        output_size : FFT length + cyclic prefix length (in samples)
        rolloff_len : Length of the rolloff flank in samples
        len_tag_key : For framed processing the key of the length tag
    """
  return _digital_swig.ofdm_cyclic_prefixer_make(*args, **kwargs)

class ofdm_equalizer_base(object):
    """Proxy of C++ gr::digital::ofdm_equalizer_base class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_base
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_base self)

        Reset the channel information state knowledge.
        """
        return _digital_swig.ofdm_equalizer_base_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.
        """
        return _digital_swig.ofdm_equalizer_base_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_base self, pmt_vector_cfloat taps)

        Return the current channel state.
        """
        return _digital_swig.ofdm_equalizer_base_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """fft_len(ofdm_equalizer_base self) -> int"""
        return _digital_swig.ofdm_equalizer_base_fft_len(self)

    def base(self):
        """base(ofdm_equalizer_base self) -> ofdm_equalizer_base_sptr"""
        return _digital_swig.ofdm_equalizer_base_base(self)

ofdm_equalizer_base_swigregister = _digital_swig.ofdm_equalizer_base_swigregister
ofdm_equalizer_base_swigregister(ofdm_equalizer_base)

class ofdm_equalizer_1d_pilots(ofdm_equalizer_base):
    """Proxy of C++ gr::digital::ofdm_equalizer_1d_pilots class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_1d_pilots
    __del__ = lambda self : None;
ofdm_equalizer_1d_pilots_swigregister = _digital_swig.ofdm_equalizer_1d_pilots_swigregister
ofdm_equalizer_1d_pilots_swigregister(ofdm_equalizer_1d_pilots)

class ofdm_equalizer_simpledfe(ofdm_equalizer_1d_pilots):
    """
    Constructor Specific Documentation:



    Args:
        fft_len : 
        constellation : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        symbols_skipped : 
        alpha : 
        input_is_shifted : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::ofdm_equalizer_simpledfe self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe
        """
        this = _digital_swig.new_ofdm_equalizer_simpledfe(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_simpledfe
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

        Constructor Specific Documentation:



        Args:
            fft_len : 
            constellation : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            symbols_skipped : 
            alpha : 
            input_is_shifted : 
        """
        return _digital_swig.ofdm_equalizer_simpledfe_make(*args, **kwargs)

    make = staticmethod(make)
ofdm_equalizer_simpledfe_swigregister = _digital_swig.ofdm_equalizer_simpledfe_swigregister
ofdm_equalizer_simpledfe_swigregister(ofdm_equalizer_simpledfe)

def ofdm_equalizer_simpledfe_make(*args, **kwargs):
  """
    ofdm_equalizer_simpledfe_make(int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
        gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
        int symbols_skipped=0, 
        float alpha=0.1, 
        bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

    Constructor Specific Documentation:



    Args:
        fft_len : 
        constellation : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        symbols_skipped : 
        alpha : 
        input_is_shifted : 
    """
  return _digital_swig.ofdm_equalizer_simpledfe_make(*args, **kwargs)

class ofdm_equalizer_static(ofdm_equalizer_1d_pilots):
    """
    Constructor Specific Documentation:



    Args:
        fft_len : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        symbols_skipped : 
        input_is_shifted : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::ofdm_equalizer_static self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            bool input_is_shifted=True) -> ofdm_equalizer_static
        """
        this = _digital_swig.new_ofdm_equalizer_static(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_static
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            bool input_is_shifted=True) -> ofdm_equalizer_static_sptr

        Constructor Specific Documentation:



        Args:
            fft_len : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            symbols_skipped : 
            input_is_shifted : 
        """
        return _digital_swig.ofdm_equalizer_static_make(*args, **kwargs)

    make = staticmethod(make)
ofdm_equalizer_static_swigregister = _digital_swig.ofdm_equalizer_static_swigregister
ofdm_equalizer_static_swigregister(ofdm_equalizer_static)

def ofdm_equalizer_static_make(*args, **kwargs):
  """
    ofdm_equalizer_static_make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
        std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
        gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
        int symbols_skipped=0, 
        bool input_is_shifted=True) -> ofdm_equalizer_static_sptr

    Constructor Specific Documentation:



    Args:
        fft_len : 
        occupied_carriers : 
        pilot_carriers : 
        pilot_symbols : 
        symbols_skipped : 
        input_is_shifted : 
    """
  return _digital_swig.ofdm_equalizer_static_make(*args, **kwargs)

class ofdm_frame_acquisition(object):
    """
    take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

    This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

    It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.

    Constructor Specific Documentation:

    Make an OFDM correlator and equalizer.

    Args:
        occupied_carriers : The number of subcarriers with data in the received symbol
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        cplen : The length of the cycle prefix
        known_symbol : A vector of complex numbers representing a known symbol at the start of a frame (usually a BPSK PN sequence)
        max_fft_shift_len : Set's the maximum distance you can look between bins for correlation
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int occupied_carriers, unsigned int fft_length, unsigned int cplen, pmt_vector_cfloat known_symbol, 
            unsigned int max_fft_shift_len=4) -> ofdm_frame_acquisition_sptr

        take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

        This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

        It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.

        Constructor Specific Documentation:

        Make an OFDM correlator and equalizer.

        Args:
            occupied_carriers : The number of subcarriers with data in the received symbol
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
            cplen : The length of the cycle prefix
            known_symbol : A vector of complex numbers representing a known symbol at the start of a frame (usually a BPSK PN sequence)
            max_fft_shift_len : Set's the maximum distance you can look between bins for correlation
        """
        return _digital_swig.ofdm_frame_acquisition_make(*args, **kwargs)

    make = staticmethod(make)
    def snr(self):
        """
        snr(ofdm_frame_acquisition self) -> float

        Return an estimate of the SNR of the channel.
        """
        return _digital_swig.ofdm_frame_acquisition_snr(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_frame_acquisition
    __del__ = lambda self : None;
ofdm_frame_acquisition_swigregister = _digital_swig.ofdm_frame_acquisition_swigregister
ofdm_frame_acquisition_swigregister(ofdm_frame_acquisition)

def ofdm_frame_acquisition_make(*args, **kwargs):
  """
    ofdm_frame_acquisition_make(unsigned int occupied_carriers, unsigned int fft_length, unsigned int cplen, pmt_vector_cfloat known_symbol, 
        unsigned int max_fft_shift_len=4) -> ofdm_frame_acquisition_sptr

    take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

    This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

    It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.

    Constructor Specific Documentation:

    Make an OFDM correlator and equalizer.

    Args:
        occupied_carriers : The number of subcarriers with data in the received symbol
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        cplen : The length of the cycle prefix
        known_symbol : A vector of complex numbers representing a known symbol at the start of a frame (usually a BPSK PN sequence)
        max_fft_shift_len : Set's the maximum distance you can look between bins for correlation
    """
  return _digital_swig.ofdm_frame_acquisition_make(*args, **kwargs)

class ofdm_frame_equalizer_vcvc(object):
    """
    OFDM frame equalizer.

    Performs equalization in one or two dimensions on a tagged OFDM frame.

    This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'ofdm_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged OFDM frame. The actual equalization is done by a ofdm_frame_equalizer object, outside of the block.

    Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

    Input: a tagged series of OFDM symbols. Output: The same as the input, but equalized and frequency-corrected.

    Constructor Specific Documentation:



    Args:
        equalizer : The equalizer object that will do the actual work
        cp_len : Length of the cyclic prefix in samples (required to correct the frequency offset)
        len_tag_key : Length tag key
        propagate_channel_state : If true, the channel state after the last symbol will be added to the first symbol as a tag
        fixed_frame_len : Set if the frame length is fixed throughout, helps with book keeping.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(ofdm_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

        OFDM frame equalizer.

        Performs equalization in one or two dimensions on a tagged OFDM frame.

        This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'ofdm_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged OFDM frame. The actual equalization is done by a ofdm_frame_equalizer object, outside of the block.

        Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

        Input: a tagged series of OFDM symbols. Output: The same as the input, but equalized and frequency-corrected.

        Constructor Specific Documentation:



        Args:
            equalizer : The equalizer object that will do the actual work
            cp_len : Length of the cyclic prefix in samples (required to correct the frequency offset)
            len_tag_key : Length tag key
            propagate_channel_state : If true, the channel state after the last symbol will be added to the first symbol as a tag
            fixed_frame_len : Set if the frame length is fixed throughout, helps with book keeping.
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_frame_equalizer_vcvc
    __del__ = lambda self : None;
ofdm_frame_equalizer_vcvc_swigregister = _digital_swig.ofdm_frame_equalizer_vcvc_swigregister
ofdm_frame_equalizer_vcvc_swigregister(ofdm_frame_equalizer_vcvc)

def ofdm_frame_equalizer_vcvc_make(*args, **kwargs):
  """
    ofdm_frame_equalizer_vcvc_make(ofdm_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
        bool propagate_channel_state=False, int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

    OFDM frame equalizer.

    Performs equalization in one or two dimensions on a tagged OFDM frame.

    This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'ofdm_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged OFDM frame. The actual equalization is done by a ofdm_frame_equalizer object, outside of the block.

    Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

    Input: a tagged series of OFDM symbols. Output: The same as the input, but equalized and frequency-corrected.

    Constructor Specific Documentation:



    Args:
        equalizer : The equalizer object that will do the actual work
        cp_len : Length of the cyclic prefix in samples (required to correct the frequency offset)
        len_tag_key : Length tag key
        propagate_channel_state : If true, the channel state after the last symbol will be added to the first symbol as a tag
        fixed_frame_len : Set if the frame length is fixed throughout, helps with book keeping.
    """
  return _digital_swig.ofdm_frame_equalizer_vcvc_make(*args, **kwargs)

class ofdm_frame_sink(object):
    """
    Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

    NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.

    Constructor Specific Documentation:

    Make an OFDM frame sink block.

    Args:
        sym_position : vector of OFDM carrier symbols in complex space
        sym_value_out : vector of bit mapped from the complex symbol space
        target_queue : message queue for the packets to go into
        occupied_tones : The number of subcarriers with data in the received symbol
        phase_gain : gain of the phase tracking loop
        freq_gain : gain of the frequency tracking loop
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat sym_position, std::vector< char,std::allocator< char > > const & sym_value_out, 
            msg_queue_sptr target_queue, int occupied_tones, float phase_gain=0.25, 
            float freq_gain=0.25*0.25/4) -> ofdm_frame_sink_sptr

        Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

        NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.

        Constructor Specific Documentation:

        Make an OFDM frame sink block.

        Args:
            sym_position : vector of OFDM carrier symbols in complex space
            sym_value_out : vector of bit mapped from the complex symbol space
            target_queue : message queue for the packets to go into
            occupied_tones : The number of subcarriers with data in the received symbol
            phase_gain : gain of the phase tracking loop
            freq_gain : gain of the frequency tracking loop
        """
        return _digital_swig.ofdm_frame_sink_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_frame_sink
    __del__ = lambda self : None;
ofdm_frame_sink_swigregister = _digital_swig.ofdm_frame_sink_swigregister
ofdm_frame_sink_swigregister(ofdm_frame_sink)

def ofdm_frame_sink_make(*args, **kwargs):
  """
    ofdm_frame_sink_make(pmt_vector_cfloat sym_position, std::vector< char,std::allocator< char > > const & sym_value_out, 
        msg_queue_sptr target_queue, int occupied_tones, float phase_gain=0.25, 
        float freq_gain=0.25*0.25/4) -> ofdm_frame_sink_sptr

    Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

    NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.

    Constructor Specific Documentation:

    Make an OFDM frame sink block.

    Args:
        sym_position : vector of OFDM carrier symbols in complex space
        sym_value_out : vector of bit mapped from the complex symbol space
        target_queue : message queue for the packets to go into
        occupied_tones : The number of subcarriers with data in the received symbol
        phase_gain : gain of the phase tracking loop
        freq_gain : gain of the frequency tracking loop
    """
  return _digital_swig.ofdm_frame_sink_make(*args, **kwargs)

class ofdm_insert_preamble(object):
    """
    insert "pre-modulated" preamble symbols before each payload.

    Constructor Specific Documentation:

    Make an OFDM preamble inserter block.

    Args:
        fft_length : length of each symbol in samples.
        preamble : vector of symbols that represent the pre-modulated preamble.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_length, gr_vector_vector_complexf preamble) -> ofdm_insert_preamble_sptr

        insert "pre-modulated" preamble symbols before each payload.

        Constructor Specific Documentation:

        Make an OFDM preamble inserter block.

        Args:
            fft_length : length of each symbol in samples.
            preamble : vector of symbols that represent the pre-modulated preamble.
        """
        return _digital_swig.ofdm_insert_preamble_make(*args, **kwargs)

    make = staticmethod(make)
    def enter_preamble(self):
        """enter_preamble(ofdm_insert_preamble self)"""
        return _digital_swig.ofdm_insert_preamble_enter_preamble(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_insert_preamble
    __del__ = lambda self : None;
ofdm_insert_preamble_swigregister = _digital_swig.ofdm_insert_preamble_swigregister
ofdm_insert_preamble_swigregister(ofdm_insert_preamble)

def ofdm_insert_preamble_make(*args, **kwargs):
  """
    ofdm_insert_preamble_make(int fft_length, gr_vector_vector_complexf preamble) -> ofdm_insert_preamble_sptr

    insert "pre-modulated" preamble symbols before each payload.

    Constructor Specific Documentation:

    Make an OFDM preamble inserter block.

    Args:
        fft_length : length of each symbol in samples.
        preamble : vector of symbols that represent the pre-modulated preamble.
    """
  return _digital_swig.ofdm_insert_preamble_make(*args, **kwargs)

class ofdm_mapper_bcv(object):
    """
    take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator.

    Abstract class must be subclassed with specific mapping.

    Constructor Specific Documentation:

    Make an OFDM mapper block.

    Args:
        constellation : vector of OFDM carrier symbols in complex space
        msgq_limit : limit on number of messages the queue can store
        occupied_carriers : The number of subcarriers with data in the received symbol
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat constellation, unsigned int msgq_limit, unsigned int occupied_carriers, 
            unsigned int fft_length) -> ofdm_mapper_bcv_sptr

        take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator.

        Abstract class must be subclassed with specific mapping.

        Constructor Specific Documentation:

        Make an OFDM mapper block.

        Args:
            constellation : vector of OFDM carrier symbols in complex space
            msgq_limit : limit on number of messages the queue can store
            occupied_carriers : The number of subcarriers with data in the received symbol
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        """
        return _digital_swig.ofdm_mapper_bcv_make(*args, **kwargs)

    make = staticmethod(make)
    def msgq(self):
        """msgq(ofdm_mapper_bcv self) -> msg_queue_sptr"""
        return _digital_swig.ofdm_mapper_bcv_msgq(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_mapper_bcv
    __del__ = lambda self : None;
ofdm_mapper_bcv_swigregister = _digital_swig.ofdm_mapper_bcv_swigregister
ofdm_mapper_bcv_swigregister(ofdm_mapper_bcv)

def ofdm_mapper_bcv_make(*args, **kwargs):
  """
    ofdm_mapper_bcv_make(pmt_vector_cfloat constellation, unsigned int msgq_limit, unsigned int occupied_carriers, 
        unsigned int fft_length) -> ofdm_mapper_bcv_sptr

    take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator.

    Abstract class must be subclassed with specific mapping.

    Constructor Specific Documentation:

    Make an OFDM mapper block.

    Args:
        constellation : vector of OFDM carrier symbols in complex space
        msgq_limit : limit on number of messages the queue can store
        occupied_carriers : The number of subcarriers with data in the received symbol
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
    """
  return _digital_swig.ofdm_mapper_bcv_make(*args, **kwargs)

class ofdm_sampler(object):
    """
    does the rest of the OFDM stuff

    Constructor Specific Documentation:

    Make an OFDM sampler block.

    Args:
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        symbol_length : Length of the full symbol (fft_length + CP length)
        timeout : timeout in samples when we stop looking for a symbol after initial ack.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(unsigned int fft_length, unsigned int symbol_length, unsigned int timeout=1000) -> ofdm_sampler_sptr

        does the rest of the OFDM stuff

        Constructor Specific Documentation:

        Make an OFDM sampler block.

        Args:
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
            symbol_length : Length of the full symbol (fft_length + CP length)
            timeout : timeout in samples when we stop looking for a symbol after initial ack.
        """
        return _digital_swig.ofdm_sampler_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_sampler
    __del__ = lambda self : None;
ofdm_sampler_swigregister = _digital_swig.ofdm_sampler_swigregister
ofdm_sampler_swigregister(ofdm_sampler)

def ofdm_sampler_make(*args, **kwargs):
  """
    ofdm_sampler_make(unsigned int fft_length, unsigned int symbol_length, unsigned int timeout=1000) -> ofdm_sampler_sptr

    does the rest of the OFDM stuff

    Constructor Specific Documentation:

    Make an OFDM sampler block.

    Args:
        fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        symbol_length : Length of the full symbol (fft_length + CP length)
        timeout : timeout in samples when we stop looking for a symbol after initial ack.
    """
  return _digital_swig.ofdm_sampler_make(*args, **kwargs)

class ofdm_serializer_vcc(object):
    """
    Serializes complex modulations symbols from OFDM sub-carriers.

    This is the inverse block to the carrier_allocator_cvc. It outputs the complex data symbols as a tagged stream, discarding the pilot symbols.

    If given, two different tags are parsed: The first key () specifies the number of OFDM symbols in the frame at the input. The second key () specifies the number of complex symbols that are coded into this frame. If given, this second key is then used at the output, otherwise,  is used. If both are given, the packet length specifies the maximum number of output items, and the frame length specifies the exact number of consumed input items.

    It is possible to correct a carrier offset in this function by passing another tag with said offset.

    Input: Complex vectors of length  Output: Complex scalars, in the same order as specified in occupied_carriers.

    Constructor Specific Documentation:



    Args:
        fft_len : FFT length
        occupied_carriers : See ofdm_carrier_allocator_cvc.
        len_tag_key : The key of the tag identifying the length of the input frame in OFDM symbols.
        packet_len_tag_key : The key of the tag identifying the number of complex symbols in this packet.
        symbols_skipped : If the first symbol is not allocated as in [0], set this
        carr_offset_key : When this block should correct a carrier offset, specify the tag key of the offset here (not necessary if following an ofdm_frame_equalizer_vcvc)
        input_is_shifted : If the input has the DC carrier on index 0 (i.e. it is not FFT shifted), set this to false
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::string const & len_tag_key="frame_len", 
            std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", 
            bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
        make(ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

        Serializes complex modulations symbols from OFDM sub-carriers.

        This is the inverse block to the carrier_allocator_cvc. It outputs the complex data symbols as a tagged stream, discarding the pilot symbols.

        If given, two different tags are parsed: The first key () specifies the number of OFDM symbols in the frame at the input. The second key () specifies the number of complex symbols that are coded into this frame. If given, this second key is then used at the output, otherwise,  is used. If both are given, the packet length specifies the maximum number of output items, and the frame length specifies the exact number of consumed input items.

        It is possible to correct a carrier offset in this function by passing another tag with said offset.

        Input: Complex vectors of length  Output: Complex scalars, in the same order as specified in occupied_carriers.

        Constructor Specific Documentation:



        Args:
            fft_len : FFT length
            occupied_carriers : See ofdm_carrier_allocator_cvc.
            len_tag_key : The key of the tag identifying the length of the input frame in OFDM symbols.
            packet_len_tag_key : The key of the tag identifying the number of complex symbols in this packet.
            symbols_skipped : If the first symbol is not allocated as in [0], set this
            carr_offset_key : When this block should correct a carrier offset, specify the tag key of the offset here (not necessary if following an ofdm_frame_equalizer_vcvc)
            input_is_shifted : If the input has the DC carrier on index 0 (i.e. it is not FFT shifted), set this to false
        """
        return _digital_swig.ofdm_serializer_vcc_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_serializer_vcc
    __del__ = lambda self : None;
ofdm_serializer_vcc_swigregister = _digital_swig.ofdm_serializer_vcc_swigregister
ofdm_serializer_vcc_swigregister(ofdm_serializer_vcc)

def ofdm_serializer_vcc_make(*args):
  """
    make(int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        std::string const & len_tag_key="frame_len", 
        std::string const & packet_len_tag_key="", 
        int symbols_skipped=0, std::string const & carr_offset_key="", 
        bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
    ofdm_serializer_vcc_make(ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
        int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

    Serializes complex modulations symbols from OFDM sub-carriers.

    This is the inverse block to the carrier_allocator_cvc. It outputs the complex data symbols as a tagged stream, discarding the pilot symbols.

    If given, two different tags are parsed: The first key () specifies the number of OFDM symbols in the frame at the input. The second key () specifies the number of complex symbols that are coded into this frame. If given, this second key is then used at the output, otherwise,  is used. If both are given, the packet length specifies the maximum number of output items, and the frame length specifies the exact number of consumed input items.

    It is possible to correct a carrier offset in this function by passing another tag with said offset.

    Input: Complex vectors of length  Output: Complex scalars, in the same order as specified in occupied_carriers.

    Constructor Specific Documentation:



    Args:
        fft_len : FFT length
        occupied_carriers : See ofdm_carrier_allocator_cvc.
        len_tag_key : The key of the tag identifying the length of the input frame in OFDM symbols.
        packet_len_tag_key : The key of the tag identifying the number of complex symbols in this packet.
        symbols_skipped : If the first symbol is not allocated as in [0], set this
        carr_offset_key : When this block should correct a carrier offset, specify the tag key of the offset here (not necessary if following an ofdm_frame_equalizer_vcvc)
        input_is_shifted : If the input has the DC carrier on index 0 (i.e. it is not FFT shifted), set this to false
    """
  return _digital_swig.ofdm_serializer_vcc_make(*args)

class ofdm_sync_sc_cfb(object):
    """
    Schmidl & Cox synchronisation for OFDM.

    Input: complex samples. Output 0: Fine frequency offset, scaled by the OFDM symbol duration. This is  in [1]. The normalized frequency offset is then 2.0*output0/fft_len. Output 1: Beginning of the first OFDM symbol after the first (doubled) OFDM symbol. The beginning is marked with a 1 (it's 0 everywhere else).

    The evaluation of the coarse frequency offset is  done in this block. Also, the initial equalizer taps are not calculated here.

    Note that we use a different normalization factor in the timing metric than the authors do in their original work[1]. If the timing metric (8) is  we calculate the normalization as  i.e., we estimate the energy from  half-symbols. This avoids spurious detects at the end of a burst, when the energy level suddenly drops.

    [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997.

    Constructor Specific Documentation:



    Args:
        fft_len : FFT length
        cp_len : Length of the guard interval (cyclic prefix) in samples
        use_even_carriers : If true, the carriers in the sync preamble are occupied such that the even carriers are used (0, 2, 4, ...). If you use all carriers, that would include the DC carrier, so be careful.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int fft_len, int cp_len, bool use_even_carriers=False) -> ofdm_sync_sc_cfb_sptr

        Schmidl & Cox synchronisation for OFDM.

        Input: complex samples. Output 0: Fine frequency offset, scaled by the OFDM symbol duration. This is  in [1]. The normalized frequency offset is then 2.0*output0/fft_len. Output 1: Beginning of the first OFDM symbol after the first (doubled) OFDM symbol. The beginning is marked with a 1 (it's 0 everywhere else).

        The evaluation of the coarse frequency offset is  done in this block. Also, the initial equalizer taps are not calculated here.

        Note that we use a different normalization factor in the timing metric than the authors do in their original work[1]. If the timing metric (8) is  we calculate the normalization as  i.e., we estimate the energy from  half-symbols. This avoids spurious detects at the end of a burst, when the energy level suddenly drops.

        [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997.

        Constructor Specific Documentation:



        Args:
            fft_len : FFT length
            cp_len : Length of the guard interval (cyclic prefix) in samples
            use_even_carriers : If true, the carriers in the sync preamble are occupied such that the even carriers are used (0, 2, 4, ...). If you use all carriers, that would include the DC carrier, so be careful.
        """
        return _digital_swig.ofdm_sync_sc_cfb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_ofdm_sync_sc_cfb
    __del__ = lambda self : None;
ofdm_sync_sc_cfb_swigregister = _digital_swig.ofdm_sync_sc_cfb_swigregister
ofdm_sync_sc_cfb_swigregister(ofdm_sync_sc_cfb)

def ofdm_sync_sc_cfb_make(*args, **kwargs):
  """
    ofdm_sync_sc_cfb_make(int fft_len, int cp_len, bool use_even_carriers=False) -> ofdm_sync_sc_cfb_sptr

    Schmidl & Cox synchronisation for OFDM.

    Input: complex samples. Output 0: Fine frequency offset, scaled by the OFDM symbol duration. This is  in [1]. The normalized frequency offset is then 2.0*output0/fft_len. Output 1: Beginning of the first OFDM symbol after the first (doubled) OFDM symbol. The beginning is marked with a 1 (it's 0 everywhere else).

    The evaluation of the coarse frequency offset is  done in this block. Also, the initial equalizer taps are not calculated here.

    Note that we use a different normalization factor in the timing metric than the authors do in their original work[1]. If the timing metric (8) is  we calculate the normalization as  i.e., we estimate the energy from  half-symbols. This avoids spurious detects at the end of a burst, when the energy level suddenly drops.

    [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997.

    Constructor Specific Documentation:



    Args:
        fft_len : FFT length
        cp_len : Length of the guard interval (cyclic prefix) in samples
        use_even_carriers : If true, the carriers in the sync preamble are occupied such that the even carriers are used (0, 2, 4, ...). If you use all carriers, that would include the DC carrier, so be careful.
    """
  return _digital_swig.ofdm_sync_sc_cfb_make(*args, **kwargs)

class packet_header_default(object):
    """
    Default header formatter for digital packet transmission.

    For bursty/packetized digital transmission, packets are usually prepended with a packet header, containing the number of bytes etc. This class is not a block, but a tool to create these packet header.

    This is a default packet header (see header_formatter()) for a description on the header format). To create other header, derive packet header creator classes from this function.

    gr::digital::packet_headergenerator_bb uses header generators derived from this class to create packet headers from data streams.

    Constructor Specific Documentation:



    Args:
        header_len : 
        len_tag_key : 
        num_tag_key : 
        bits_per_byte : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::packet_header_default self, long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            int bits_per_byte=1) -> packet_header_default
        """
        this = _digital_swig.new_packet_header_default(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_packet_header_default
    __del__ = lambda self : None;
    def base(self):
        """base(packet_header_default self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_default_base(self)

    def formatter(self):
        """formatter(packet_header_default self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_default_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """set_header_num(packet_header_default self, unsigned int header_num)"""
        return _digital_swig.packet_header_default_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """header_len(packet_header_default self) -> long"""
        return _digital_swig.packet_header_default_header_len(self)

    def len_tag_key(self):
        """len_tag_key(packet_header_default self) -> swig_int_ptr"""
        return _digital_swig.packet_header_default_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.
        """
        return _digital_swig.packet_header_default_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_default self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .
        """
        return _digital_swig.packet_header_default_header_parser(self, *args, **kwargs)

    def make(*args, **kwargs):
        """
        make(long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            int bits_per_byte=1) -> packet_header_default_sptr

        Default header formatter for digital packet transmission.

        For bursty/packetized digital transmission, packets are usually prepended with a packet header, containing the number of bytes etc. This class is not a block, but a tool to create these packet header.

        This is a default packet header (see header_formatter()) for a description on the header format). To create other header, derive packet header creator classes from this function.

        gr::digital::packet_headergenerator_bb uses header generators derived from this class to create packet headers from data streams.

        Constructor Specific Documentation:



        Args:
            header_len : 
            len_tag_key : 
            num_tag_key : 
            bits_per_byte : 
        """
        return _digital_swig.packet_header_default_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_default_swigregister = _digital_swig.packet_header_default_swigregister
packet_header_default_swigregister(packet_header_default)

def packet_header_default_make(*args, **kwargs):
  """
    packet_header_default_make(long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
        int bits_per_byte=1) -> packet_header_default_sptr

    Default header formatter for digital packet transmission.

    For bursty/packetized digital transmission, packets are usually prepended with a packet header, containing the number of bytes etc. This class is not a block, but a tool to create these packet header.

    This is a default packet header (see header_formatter()) for a description on the header format). To create other header, derive packet header creator classes from this function.

    gr::digital::packet_headergenerator_bb uses header generators derived from this class to create packet headers from data streams.

    Constructor Specific Documentation:



    Args:
        header_len : 
        len_tag_key : 
        num_tag_key : 
        bits_per_byte : 
    """
  return _digital_swig.packet_header_default_make(*args, **kwargs)

class packet_header_ofdm(packet_header_default):
    """
    Header utility for OFDM signals.

    Constructor Specific Documentation:



    Args:
        occupied_carriers : See carrier allocator
        n_syms : The number of OFDM symbols the header should be (usually 1)
        len_tag_key : The tag key used for the packet length (number of bytes)
        frame_len_tag_key : The tag key used for the frame length (number of OFDM symbols, this is the tag key required for the frame equalizer etc.)
        num_tag_key : The tag key used for packet numbering.
        bits_per_header_sym : Bits per complex symbol in the header, e.g. 1 if the header is BPSK modulated, 2 if it's QPSK modulated etc.
        bits_per_payload_sym : Bits per complex symbol in the payload. This is required to figure out how many OFDM symbols are necessary to encode the given number of bytes.
        scramble_header : Set this to true to scramble the bits. This is highly recommended, as it reduces PAPR spikes.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::digital::packet_header_ofdm self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key, 
            std::string const & frame_len_tag_key, std::string const & num_tag_key, 
            int bits_per_header_sym, int bits_per_payload_sym, 
            bool scramble_header) -> packet_header_ofdm
        """
        this = _digital_swig.new_packet_header_ofdm(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _digital_swig.delete_packet_header_ofdm
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key="packet_len", 
            std::string const & frame_len_tag_key="frame_len", 
            std::string const & num_tag_key="packet_num", int bits_per_header_sym=1, 
            int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_sptr

        Header utility for OFDM signals.

        Constructor Specific Documentation:



        Args:
            occupied_carriers : See carrier allocator
            n_syms : The number of OFDM symbols the header should be (usually 1)
            len_tag_key : The tag key used for the packet length (number of bytes)
            frame_len_tag_key : The tag key used for the frame length (number of OFDM symbols, this is the tag key required for the frame equalizer etc.)
            num_tag_key : The tag key used for packet numbering.
            bits_per_header_sym : Bits per complex symbol in the header, e.g. 1 if the header is BPSK modulated, 2 if it's QPSK modulated etc.
            bits_per_payload_sym : Bits per complex symbol in the payload. This is required to figure out how many OFDM symbols are necessary to encode the given number of bytes.
            scramble_header : Set this to true to scramble the bits. This is highly recommended, as it reduces PAPR spikes.
        """
        return _digital_swig.packet_header_ofdm_make(*args, **kwargs)

    make = staticmethod(make)
packet_header_ofdm_swigregister = _digital_swig.packet_header_ofdm_swigregister
packet_header_ofdm_swigregister(packet_header_ofdm)

def packet_header_ofdm_make(*args, **kwargs):
  """
    packet_header_ofdm_make(std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
        int n_syms, std::string const & len_tag_key="packet_len", 
        std::string const & frame_len_tag_key="frame_len", 
        std::string const & num_tag_key="packet_num", int bits_per_header_sym=1, 
        int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_sptr

    Header utility for OFDM signals.

    Constructor Specific Documentation:



    Args:
        occupied_carriers : See carrier allocator
        n_syms : The number of OFDM symbols the header should be (usually 1)
        len_tag_key : The tag key used for the packet length (number of bytes)
        frame_len_tag_key : The tag key used for the frame length (number of OFDM symbols, this is the tag key required for the frame equalizer etc.)
        num_tag_key : The tag key used for packet numbering.
        bits_per_header_sym : Bits per complex symbol in the header, e.g. 1 if the header is BPSK modulated, 2 if it's QPSK modulated etc.
        bits_per_payload_sym : Bits per complex symbol in the payload. This is required to figure out how many OFDM symbols are necessary to encode the given number of bytes.
        scramble_header : Set this to true to scramble the bits. This is highly recommended, as it reduces PAPR spikes.
    """
  return _digital_swig.packet_header_ofdm_make(*args, **kwargs)

class packet_headergenerator_bb(object):
    """
    Generates a header for a tagged, streamed packet.

    Input: A tagged stream. This is consumed entirely, it is not appended to the output stream. Output: An tagged stream containing the header. The details on the header are set in a header formatter object (of type packet_header_default or a subclass thereof). If only a number of bits is specified, a default header is generated (see packet_header_default).

    Constructor Specific Documentation:



    Args:
        header_formatter : 
        len_tag_key : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr
        make(long header_len, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr

        Generates a header for a tagged, streamed packet.

        Input: A tagged stream. This is consumed entirely, it is not appended to the output stream. Output: An tagged stream containing the header. The details on the header are set in a header formatter object (of type packet_header_default or a subclass thereof). If only a number of bits is specified, a default header is generated (see packet_header_default).

        Constructor Specific Documentation:



        Args:
            header_formatter : 
            len_tag_key : 
        """
        return _digital_swig.packet_headergenerator_bb_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_packet_headergenerator_bb
    __del__ = lambda self : None;
packet_headergenerator_bb_swigregister = _digital_swig.packet_headergenerator_bb_swigregister
packet_headergenerator_bb_swigregister(packet_headergenerator_bb)

def packet_headergenerator_bb_make(*args):
  """
    make(packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr
    packet_headergenerator_bb_make(long header_len, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr

    Generates a header for a tagged, streamed packet.

    Input: A tagged stream. This is consumed entirely, it is not appended to the output stream. Output: An tagged stream containing the header. The details on the header are set in a header formatter object (of type packet_header_default or a subclass thereof). If only a number of bits is specified, a default header is generated (see packet_header_default).

    Constructor Specific Documentation:



    Args:
        header_formatter : 
        len_tag_key : 
    """
  return _digital_swig.packet_headergenerator_bb_make(*args)

class packet_headerparser_b(object):
    """
    Post header metadata as a PMT.

    In a sense, this is the inverse block to packet_headergenerator_bb. The difference is, the parsed header is not output as a stream, but as a PMT dictionary, which is published to message port with the id "header_data".

    The dictionary consists of the tags created by the header formatter object. You should be able to use the exact same formatter object as used on the Tx side in the packet_headergenerator_bb.

    If only a header length is given, this block uses the default header format.

    Constructor Specific Documentation:



    Args:
        header_formatter : Header object. This should be the same as used for packet_headergenerator_bb.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args):
        """
        make(packet_header_default_sptr header_formatter) -> packet_headerparser_b_sptr
        make(long header_len, std::string const & len_tag_key) -> packet_headerparser_b_sptr

        Post header metadata as a PMT.

        In a sense, this is the inverse block to packet_headergenerator_bb. The difference is, the parsed header is not output as a stream, but as a PMT dictionary, which is published to message port with the id "header_data".

        The dictionary consists of the tags created by the header formatter object. You should be able to use the exact same formatter object as used on the Tx side in the packet_headergenerator_bb.

        If only a header length is given, this block uses the default header format.

        Constructor Specific Documentation:



        Args:
            header_formatter : Header object. This should be the same as used for packet_headergenerator_bb.
        """
        return _digital_swig.packet_headerparser_b_make(*args)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_packet_headerparser_b
    __del__ = lambda self : None;
packet_headerparser_b_swigregister = _digital_swig.packet_headerparser_b_swigregister
packet_headerparser_b_swigregister(packet_headerparser_b)

def packet_headerparser_b_make(*args):
  """
    make(packet_header_default_sptr header_formatter) -> packet_headerparser_b_sptr
    packet_headerparser_b_make(long header_len, std::string const & len_tag_key) -> packet_headerparser_b_sptr

    Post header metadata as a PMT.

    In a sense, this is the inverse block to packet_headergenerator_bb. The difference is, the parsed header is not output as a stream, but as a PMT dictionary, which is published to message port with the id "header_data".

    The dictionary consists of the tags created by the header formatter object. You should be able to use the exact same formatter object as used on the Tx side in the packet_headergenerator_bb.

    If only a header length is given, this block uses the default header format.

    Constructor Specific Documentation:



    Args:
        header_formatter : Header object. This should be the same as used for packet_headergenerator_bb.
    """
  return _digital_swig.packet_headerparser_b_make(*args)

class packet_sink(object):
    """
    process received bits looking for packet sync, header, and process bits into packet

    input: stream of symbols to be sliced.

    output: none. Pushes assembled packet into target queue

    The packet sink takes in a stream of binary symbols that are sliced around 0. The bits are then checked for the  to determine find and decode the packet. It then expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    This block is not very useful anymore as it only works with 2-level modulations such as BPSK or GMSK. The block can generally be replaced with a correlate access code and frame sink blocks.

    Constructor Specific Documentation:

    Make a packet_sink block.

    Args:
        sync_vector : The synchronization vector as a vector of 1's and 0's.
        target_queue : The message queue that packets are sent to.
        threshold : Number of bits that can be incorrect in the .
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned char,std::allocator< unsigned char > > const & sync_vector, 
            msg_queue_sptr target_queue, int threshold=-1) -> packet_sink_sptr

        process received bits looking for packet sync, header, and process bits into packet

        input: stream of symbols to be sliced.

        output: none. Pushes assembled packet into target queue

        The packet sink takes in a stream of binary symbols that are sliced around 0. The bits are then checked for the  to determine find and decode the packet. It then expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

        This block is not very useful anymore as it only works with 2-level modulations such as BPSK or GMSK. The block can generally be replaced with a correlate access code and frame sink blocks.

        Constructor Specific Documentation:

        Make a packet_sink block.

        Args:
            sync_vector : The synchronization vector as a vector of 1's and 0's.
            target_queue : The message queue that packets are sent to.
            threshold : Number of bits that can be incorrect in the .
        """
        return _digital_swig.packet_sink_make(*args, **kwargs)

    make = staticmethod(make)
    def carrier_sensed(self):
        """
        carrier_sensed(packet_sink self) -> bool

        return true if we detect carrier
        """
        return _digital_swig.packet_sink_carrier_sensed(self)

    __swig_destroy__ = _digital_swig.delete_packet_sink
    __del__ = lambda self : None;
packet_sink_swigregister = _digital_swig.packet_sink_swigregister
packet_sink_swigregister(packet_sink)

def packet_sink_make(*args, **kwargs):
  """
    packet_sink_make(std::vector< unsigned char,std::allocator< unsigned char > > const & sync_vector, 
        msg_queue_sptr target_queue, int threshold=-1) -> packet_sink_sptr

    process received bits looking for packet sync, header, and process bits into packet

    input: stream of symbols to be sliced.

    output: none. Pushes assembled packet into target queue

    The packet sink takes in a stream of binary symbols that are sliced around 0. The bits are then checked for the  to determine find and decode the packet. It then expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

    This block is not very useful anymore as it only works with 2-level modulations such as BPSK or GMSK. The block can generally be replaced with a correlate access code and frame sink blocks.

    Constructor Specific Documentation:

    Make a packet_sink block.

    Args:
        sync_vector : The synchronization vector as a vector of 1's and 0's.
        target_queue : The message queue that packets are sent to.
        threshold : Number of bits that can be incorrect in the .
    """
  return _digital_swig.packet_sink_make(*args, **kwargs)

class pfb_clock_sync_ccf(object):
    """
    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:








    Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
    Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

    Constructor Specific Documentation:

    Build the polyphase filterbank timing synchronizer.

    Args:
        sps : (double) The number of samples per symbol in the incoming signal
        loop_bw : (float) The bandwidth of the control loop; set's alpha and beta.
        taps : (vector<int>) The filter taps.
        filter_size : (uint) The number of filters in the filterbank (default = 32).
        init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
        max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
        osps : (int) The number of output samples per symbol (default=1).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double sps, float loop_bw, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
            float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_ccf_sptr

        Timing synchronizer using polyphase filterbanks.

        This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

        This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

        If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

        The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

        The block's parameters are:








        Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
        Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

        Constructor Specific Documentation:

        Build the polyphase filterbank timing synchronizer.

        Args:
            sps : (double) The number of samples per symbol in the incoming signal
            loop_bw : (float) The bandwidth of the control loop; set's alpha and beta.
            taps : (vector<int>) The filter taps.
            filter_size : (uint) The number of filters in the filterbank (default = 32).
            init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
            max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
            osps : (int) The number of output samples per symbol (default=1).
        """
        return _digital_swig.pfb_clock_sync_ccf_make(*args, **kwargs)

    make = staticmethod(make)
    def update_gains(self):
        """
        update_gains(pfb_clock_sync_ccf self)

        update the system gains from omega and eta

        This function updates the system gains based on the loop bandwidth and damping factor of the system. These two factors can be set separately through their own set functions.
        """
        return _digital_swig.pfb_clock_sync_ccf_update_gains(self)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_clock_sync_ccf self, pmt_vector_float taps, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > & ourtaps, 
            std::vector< gr::filter::kernel::fir_filter_ccf *,std::allocator< gr::filter::kernel::fir_filter_ccf * > > & ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.pfb_clock_sync_ccf_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_clock_sync_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the matched filter
        """
        return _digital_swig.pfb_clock_sync_ccf_taps(self)

    def diff_taps(self):
        """
        diff_taps(pfb_clock_sync_ccf self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.pfb_clock_sync_ccf_diff_taps(self)

    def channel_taps(self, *args, **kwargs):
        """
        channel_taps(pfb_clock_sync_ccf self, int channel) -> pmt_vector_float

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_ccf_channel_taps(self, *args, **kwargs)

    def diff_channel_taps(self, *args, **kwargs):
        """
        diff_channel_taps(pfb_clock_sync_ccf self, int channel) -> pmt_vector_float

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_ccf_diff_channel_taps(self, *args, **kwargs)

    def taps_as_string(self):
        """
        taps_as_string(pfb_clock_sync_ccf self) -> std::string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_ccf_taps_as_string(self)

    def diff_taps_as_string(self):
        """
        diff_taps_as_string(pfb_clock_sync_ccf self) -> std::string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_ccf_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(pfb_clock_sync_ccf self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_ccf_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(pfb_clock_sync_ccf self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_ccf_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(pfb_clock_sync_ccf self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(pfb_clock_sync_ccf self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(pfb_clock_sync_ccf self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.pfb_clock_sync_ccf_set_max_rate_deviation(self, *args, **kwargs)

    def loop_bandwidth(self):
        """
        loop_bandwidth(pfb_clock_sync_ccf self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.pfb_clock_sync_ccf_loop_bandwidth(self)

    def damping_factor(self):
        """
        damping_factor(pfb_clock_sync_ccf self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_damping_factor(self)

    def alpha(self):
        """
        alpha(pfb_clock_sync_ccf self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.pfb_clock_sync_ccf_alpha(self)

    def beta(self):
        """
        beta(pfb_clock_sync_ccf self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.pfb_clock_sync_ccf_beta(self)

    def clock_rate(self):
        """
        clock_rate(pfb_clock_sync_ccf self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.pfb_clock_sync_ccf_clock_rate(self)

    def error(self):
        """
        error(pfb_clock_sync_ccf self) -> float

        Returns the current error of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_error(self)

    def rate(self):
        """
        rate(pfb_clock_sync_ccf self) -> float

        Returns the current rate of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_rate(self)

    def phase(self):
        """
        phase(pfb_clock_sync_ccf self) -> float

        Returns the current phase arm of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_phase(self)

    __swig_destroy__ = _digital_swig.delete_pfb_clock_sync_ccf
    __del__ = lambda self : None;
pfb_clock_sync_ccf_swigregister = _digital_swig.pfb_clock_sync_ccf_swigregister
pfb_clock_sync_ccf_swigregister(pfb_clock_sync_ccf)

def pfb_clock_sync_ccf_make(*args, **kwargs):
  """
    pfb_clock_sync_ccf_make(double sps, float loop_bw, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
        float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_ccf_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:








    Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
    Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

    Constructor Specific Documentation:

    Build the polyphase filterbank timing synchronizer.

    Args:
        sps : (double) The number of samples per symbol in the incoming signal
        loop_bw : (float) The bandwidth of the control loop; set's alpha and beta.
        taps : (vector<int>) The filter taps.
        filter_size : (uint) The number of filters in the filterbank (default = 32).
        init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
        max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
        osps : (int) The number of output samples per symbol (default=1).
    """
  return _digital_swig.pfb_clock_sync_ccf_make(*args, **kwargs)

class pfb_clock_sync_fff(object):
    """
    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:








    Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
    Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

    Constructor Specific Documentation:

    Build the polyphase filterbank timing synchronizer.

    Args:
        sps : (double) The number of samples per second in the incoming signal
        gain : (float) The alpha gain of the control loop; beta = (gain^2)/4 by default.
        taps : (vector<int>) The filter taps.
        filter_size : (uint) The number of filters in the filterbank (default = 32).
        init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
        max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
        osps : (int) The number of output samples per symbol (default=1).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double sps, float gain, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
            float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_fff_sptr

        Timing synchronizer using polyphase filterbanks.

        This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

        This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

        If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

        The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

        The block's parameters are:








        Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
        Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

        Constructor Specific Documentation:

        Build the polyphase filterbank timing synchronizer.

        Args:
            sps : (double) The number of samples per second in the incoming signal
            gain : (float) The alpha gain of the control loop; beta = (gain^2)/4 by default.
            taps : (vector<int>) The filter taps.
            filter_size : (uint) The number of filters in the filterbank (default = 32).
            init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
            max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
            osps : (int) The number of output samples per symbol (default=1).
        """
        return _digital_swig.pfb_clock_sync_fff_make(*args, **kwargs)

    make = staticmethod(make)
    def update_gains(self):
        """
        update_gains(pfb_clock_sync_fff self)

        update the system gains from omega and eta

        This function updates the system gains based on the loop bandwidth and damping factor of the system. These two factors can be set separately through their own set functions.
        """
        return _digital_swig.pfb_clock_sync_fff_update_gains(self)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_clock_sync_fff self, pmt_vector_float taps, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > & ourtaps, 
            std::vector< gr::filter::kernel::fir_filter_fff *,std::allocator< gr::filter::kernel::fir_filter_fff * > > & ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.pfb_clock_sync_fff_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_clock_sync_fff self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the matched filter
        """
        return _digital_swig.pfb_clock_sync_fff_taps(self)

    def diff_taps(self):
        """
        diff_taps(pfb_clock_sync_fff self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.pfb_clock_sync_fff_diff_taps(self)

    def channel_taps(self, *args, **kwargs):
        """
        channel_taps(pfb_clock_sync_fff self, int channel) -> pmt_vector_float

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_fff_channel_taps(self, *args, **kwargs)

    def diff_channel_taps(self, *args, **kwargs):
        """
        diff_channel_taps(pfb_clock_sync_fff self, int channel) -> pmt_vector_float

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_fff_diff_channel_taps(self, *args, **kwargs)

    def taps_as_string(self):
        """
        taps_as_string(pfb_clock_sync_fff self) -> std::string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_fff_taps_as_string(self)

    def diff_taps_as_string(self):
        """
        diff_taps_as_string(pfb_clock_sync_fff self) -> std::string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_fff_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(pfb_clock_sync_fff self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_fff_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(pfb_clock_sync_fff self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_fff_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(pfb_clock_sync_fff self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(pfb_clock_sync_fff self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(pfb_clock_sync_fff self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.pfb_clock_sync_fff_set_max_rate_deviation(self, *args, **kwargs)

    def loop_bandwidth(self):
        """
        loop_bandwidth(pfb_clock_sync_fff self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.pfb_clock_sync_fff_loop_bandwidth(self)

    def damping_factor(self):
        """
        damping_factor(pfb_clock_sync_fff self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_damping_factor(self)

    def alpha(self):
        """
        alpha(pfb_clock_sync_fff self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.pfb_clock_sync_fff_alpha(self)

    def beta(self):
        """
        beta(pfb_clock_sync_fff self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.pfb_clock_sync_fff_beta(self)

    def clock_rate(self):
        """
        clock_rate(pfb_clock_sync_fff self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.pfb_clock_sync_fff_clock_rate(self)

    __swig_destroy__ = _digital_swig.delete_pfb_clock_sync_fff
    __del__ = lambda self : None;
pfb_clock_sync_fff_swigregister = _digital_swig.pfb_clock_sync_fff_swigregister
pfb_clock_sync_fff_swigregister(pfb_clock_sync_fff)

def pfb_clock_sync_fff_make(*args, **kwargs):
  """
    pfb_clock_sync_fff_make(double sps, float gain, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
        float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_fff_sptr

    Timing synchronizer using polyphase filterbanks.

    This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

    This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

    If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

    The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

    The block's parameters are:








    Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
    Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

    Constructor Specific Documentation:

    Build the polyphase filterbank timing synchronizer.

    Args:
        sps : (double) The number of samples per second in the incoming signal
        gain : (float) The alpha gain of the control loop; beta = (gain^2)/4 by default.
        taps : (vector<int>) The filter taps.
        filter_size : (uint) The number of filters in the filterbank (default = 32).
        init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
        max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
        osps : (int) The number of output samples per symbol (default=1).
    """
  return _digital_swig.pfb_clock_sync_fff_make(*args, **kwargs)

class pn_correlator_cc(object):
    """
    PN code sequential search correlator.

    Receives complex baseband signal, outputs complex correlation against reference PN code, one sample per PN code period. The PN sequence is generated using a GLFSR.

    Constructor Specific Documentation:

    Make PN code sequential search correlator block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int degree, int mask=0, int seed=1) -> pn_correlator_cc_sptr

        PN code sequential search correlator.

        Receives complex baseband signal, outputs complex correlation against reference PN code, one sample per PN code period. The PN sequence is generated using a GLFSR.

        Constructor Specific Documentation:

        Make PN code sequential search correlator block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.pn_correlator_cc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_pn_correlator_cc
    __del__ = lambda self : None;
pn_correlator_cc_swigregister = _digital_swig.pn_correlator_cc_swigregister
pn_correlator_cc_swigregister(pn_correlator_cc)

def pn_correlator_cc_make(*args, **kwargs):
  """
    pn_correlator_cc_make(int degree, int mask=0, int seed=1) -> pn_correlator_cc_sptr

    PN code sequential search correlator.

    Receives complex baseband signal, outputs complex correlation against reference PN code, one sample per PN code period. The PN sequence is generated using a GLFSR.

    Constructor Specific Documentation:

    Make PN code sequential search correlator block.

    Args:
        degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
        mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
        seed : Initial setting for values in shift register.
    """
  return _digital_swig.pn_correlator_cc_make(*args, **kwargs)

class probe_density_b(object):
    """
    This block maintains a running average of the input stream and makes it available as an accessor function. The input stream is type unsigned char.

    If you send this block a stream of unpacked bytes, it will tell you what the bit density is.

    Constructor Specific Documentation:

    Make a density probe block.

    Args:
        alpha : Average filter constant
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(double alpha) -> probe_density_b_sptr

        This block maintains a running average of the input stream and makes it available as an accessor function. The input stream is type unsigned char.

        If you send this block a stream of unpacked bytes, it will tell you what the bit density is.

        Constructor Specific Documentation:

        Make a density probe block.

        Args:
            alpha : Average filter constant
        """
        return _digital_swig.probe_density_b_make(*args, **kwargs)

    make = staticmethod(make)
    def density(self):
        """
        density(probe_density_b self) -> double

        Returns the current density value.
        """
        return _digital_swig.probe_density_b_density(self)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(probe_density_b self, double alpha)

        Set the average filter constant.
        """
        return _digital_swig.probe_density_b_set_alpha(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_probe_density_b
    __del__ = lambda self : None;
probe_density_b_swigregister = _digital_swig.probe_density_b_swigregister
probe_density_b_swigregister(probe_density_b)

def probe_density_b_make(*args, **kwargs):
  """
    probe_density_b_make(double alpha) -> probe_density_b_sptr

    This block maintains a running average of the input stream and makes it available as an accessor function. The input stream is type unsigned char.

    If you send this block a stream of unpacked bytes, it will tell you what the bit density is.

    Constructor Specific Documentation:

    Make a density probe block.

    Args:
        alpha : Average filter constant
    """
  return _digital_swig.probe_density_b_make(*args, **kwargs)

class probe_mpsk_snr_est_c(object):
    """
    A probe for computing SNR of a signal.

    This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Constructor Specific Documentation:

    Make an MPSK SNR probe.

    Parameters:

    Args:
        type : the type of estimator to use see gr::digital::snr_est_type_t for details about the types.
        msg_nsamples : [not implemented yet] after this many samples, a message containing the SNR (key='snr') will be sent
        alpha : the update rate of internal running average calculations.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(gr::digital::snr_est_type_t type, int msg_nsamples=10000, double alpha=0.001) -> probe_mpsk_snr_est_c_sptr

        A probe for computing SNR of a signal.

        This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

        Constructor Specific Documentation:

        Make an MPSK SNR probe.

        Parameters:

        Args:
            type : the type of estimator to use see gr::digital::snr_est_type_t for details about the types.
            msg_nsamples : [not implemented yet] after this many samples, a message containing the SNR (key='snr') will be sent
            alpha : the update rate of internal running average calculations.
        """
        return _digital_swig.probe_mpsk_snr_est_c_make(*args, **kwargs)

    make = staticmethod(make)
    def snr(self):
        """
        snr(probe_mpsk_snr_est_c self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.probe_mpsk_snr_est_c_snr(self)

    def type(self):
        """
        type(probe_mpsk_snr_est_c self) -> gr::digital::snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.probe_mpsk_snr_est_c_type(self)

    def msg_nsample(self):
        """
        msg_nsample(probe_mpsk_snr_est_c self) -> int

        Return how many samples between SNR messages.
        """
        return _digital_swig.probe_mpsk_snr_est_c_msg_nsample(self)

    def alpha(self):
        """
        alpha(probe_mpsk_snr_est_c self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.probe_mpsk_snr_est_c_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(probe_mpsk_snr_est_c self, gr::digital::snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.probe_mpsk_snr_est_c_set_type(self, *args, **kwargs)

    def set_msg_nsample(self, *args, **kwargs):
        """
        set_msg_nsample(probe_mpsk_snr_est_c self, int n)

        Set the number of samples between SNR messages.
        """
        return _digital_swig.probe_mpsk_snr_est_c_set_msg_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(probe_mpsk_snr_est_c self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.probe_mpsk_snr_est_c_set_alpha(self, *args, **kwargs)

    __swig_destroy__ = _digital_swig.delete_probe_mpsk_snr_est_c
    __del__ = lambda self : None;
probe_mpsk_snr_est_c_swigregister = _digital_swig.probe_mpsk_snr_est_c_swigregister
probe_mpsk_snr_est_c_swigregister(probe_mpsk_snr_est_c)

def probe_mpsk_snr_est_c_make(*args, **kwargs):
  """
    probe_mpsk_snr_est_c_make(gr::digital::snr_est_type_t type, int msg_nsamples=10000, double alpha=0.001) -> probe_mpsk_snr_est_c_sptr

    A probe for computing SNR of a signal.

    This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

    Constructor Specific Documentation:

    Make an MPSK SNR probe.

    Parameters:

    Args:
        type : the type of estimator to use see gr::digital::snr_est_type_t for details about the types.
        msg_nsamples : [not implemented yet] after this many samples, a message containing the SNR (key='snr') will be sent
        alpha : the update rate of internal running average calculations.
    """
  return _digital_swig.probe_mpsk_snr_est_c_make(*args, **kwargs)

class scrambler_bb(object):
    """
    Scramble an input stream using an LFSR.

    This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

    Constructor Specific Documentation:

    Make a scramber block.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int mask, int seed, int len) -> scrambler_bb_sptr

        Scramble an input stream using an LFSR.

        This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

        Constructor Specific Documentation:

        Make a scramber block.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
        """
        return _digital_swig.scrambler_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_scrambler_bb
    __del__ = lambda self : None;
scrambler_bb_swigregister = _digital_swig.scrambler_bb_swigregister
scrambler_bb_swigregister(scrambler_bb)

def scrambler_bb_make(*args, **kwargs):
  """
    scrambler_bb_make(int mask, int seed, int len) -> scrambler_bb_sptr

    Scramble an input stream using an LFSR.

    This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

    Constructor Specific Documentation:

    Make a scramber block.

    Args:
        mask : Polynomial mask for LFSR
        seed : Initial shift register contents
        len : Shift register length
    """
  return _digital_swig.scrambler_bb_make(*args, **kwargs)

class simple_correlator(object):
    """
    inverse of simple_framer (more or less)

    Constructor Specific Documentation:



    Args:
        payload_bytesize : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int payload_bytesize) -> simple_correlator_sptr

        inverse of simple_framer (more or less)

        Constructor Specific Documentation:



        Args:
            payload_bytesize : 
        """
        return _digital_swig.simple_correlator_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_simple_correlator
    __del__ = lambda self : None;
simple_correlator_swigregister = _digital_swig.simple_correlator_swigregister
simple_correlator_swigregister(simple_correlator)

def simple_correlator_make(*args, **kwargs):
  """
    simple_correlator_make(int payload_bytesize) -> simple_correlator_sptr

    inverse of simple_framer (more or less)

    Constructor Specific Documentation:



    Args:
        payload_bytesize : 
    """
  return _digital_swig.simple_correlator_make(*args, **kwargs)

class simple_framer(object):
    """
    add sync field, seq number and command field to payload

    Takes in enough samples to create a full output frame. The frame is prepended with the GRSF_SYNC (defind in simple_framer_sync.h) and an 8-bit sequence number.

    Constructor Specific Documentation:

    Make a simple_framer block.

    Args:
        payload_bytesize : The size of the payload in bytes.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int payload_bytesize) -> simple_framer_sptr

        add sync field, seq number and command field to payload

        Takes in enough samples to create a full output frame. The frame is prepended with the GRSF_SYNC (defind in simple_framer_sync.h) and an 8-bit sequence number.

        Constructor Specific Documentation:

        Make a simple_framer block.

        Args:
            payload_bytesize : The size of the payload in bytes.
        """
        return _digital_swig.simple_framer_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _digital_swig.delete_simple_framer
    __del__ = lambda self : None;
simple_framer_swigregister = _digital_swig.simple_framer_swigregister
simple_framer_swigregister(simple_framer)

def simple_framer_make(*args, **kwargs):
  """
    simple_framer_make(int payload_bytesize) -> simple_framer_sptr

    add sync field, seq number and command field to payload

    Takes in enough samples to create a full output frame. The frame is prepended with the GRSF_SYNC (defind in simple_framer_sync.h) and an 8-bit sequence number.

    Constructor Specific Documentation:

    Make a simple_framer block.

    Args:
        payload_bytesize : The size of the payload in bytes.
    """
  return _digital_swig.simple_framer_make(*args, **kwargs)

class additive_scrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::additive_scrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::additive_scrambler_bb)> self) -> additive_scrambler_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::additive_scrambler_bb)> self, additive_scrambler_bb p) -> additive_scrambler_bb_sptr
        """
        this = _digital_swig.new_additive_scrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(additive_scrambler_bb_sptr self) -> additive_scrambler_bb"""
        return _digital_swig.additive_scrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_additive_scrambler_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(additive_scrambler_bb_sptr self, int mask, int seed, int len, int count=0, int bits_per_byte=1, std::string const & reset_tag_key="") -> additive_scrambler_bb_sptr

        Scramble an input stream using an LFSR.

        This block scrambles up to 8 bits per byte of the input data stream, starting at the LSB.

        The scrambler works by XORing the incoming bit stream by the output of the LFSR. Optionally, after  bits have been processed, the shift register is reset to the  value. This allows processing fixed length vectors of samples.

        Alternatively, the LFSR can be reset using a reset tag to scramble variable length vectors. However, it cannot be reset between bytes.

        For details on configuring the LFSR, see gr::digital::lfsr.

        Constructor Specific Documentation:

        Create additive scrambler.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
            count : Number of bytes after which shift register is reset, 0=never
            bits_per_byte : Number of bits per byte
            reset_tag_key : When a tag with this key is detected, the shift register is reset (when this is set, count is ignored!)
        """
        return _digital_swig.additive_scrambler_bb_sptr_make(self, *args, **kwargs)

    def mask(self):
        """mask(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_mask(self)

    def seed(self):
        """seed(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_seed(self)

    def len(self):
        """len(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_len(self)

    def count(self):
        """count(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_count(self)

    def bits_per_byte(self):
        """bits_per_byte(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_bits_per_byte(self)

    def history(self):
        """history(additive_scrambler_bb_sptr self) -> unsigned int"""
        return _digital_swig.additive_scrambler_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(additive_scrambler_bb_sptr self, int which, int delay)
        declare_sample_delay(additive_scrambler_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.additive_scrambler_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(additive_scrambler_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.additive_scrambler_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(additive_scrambler_bb_sptr self) -> double"""
        return _digital_swig.additive_scrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(additive_scrambler_bb_sptr self) -> bool"""
        return _digital_swig.additive_scrambler_bb_sptr_start(self)

    def stop(self):
        """stop(additive_scrambler_bb_sptr self) -> bool"""
        return _digital_swig.additive_scrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(additive_scrambler_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.additive_scrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(additive_scrambler_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.additive_scrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(additive_scrambler_bb_sptr self, int m)"""
        return _digital_swig.additive_scrambler_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(additive_scrambler_bb_sptr self)"""
        return _digital_swig.additive_scrambler_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(additive_scrambler_bb_sptr self) -> bool"""
        return _digital_swig.additive_scrambler_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(additive_scrambler_bb_sptr self, int m)"""
        return _digital_swig.additive_scrambler_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(additive_scrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.additive_scrambler_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(additive_scrambler_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(additive_scrambler_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.additive_scrambler_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(additive_scrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.additive_scrambler_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(additive_scrambler_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(additive_scrambler_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.additive_scrambler_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(additive_scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(additive_scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(additive_scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(additive_scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(additive_scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(additive_scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(additive_scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.additive_scrambler_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(additive_scrambler_bb_sptr self) -> float"""
        return _digital_swig.additive_scrambler_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(additive_scrambler_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.additive_scrambler_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(additive_scrambler_bb_sptr self)"""
        return _digital_swig.additive_scrambler_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(additive_scrambler_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.additive_scrambler_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(additive_scrambler_bb_sptr self) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(additive_scrambler_bb_sptr self, int priority) -> int"""
        return _digital_swig.additive_scrambler_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(additive_scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.additive_scrambler_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(additive_scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.additive_scrambler_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(additive_scrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.additive_scrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(additive_scrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.additive_scrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(additive_scrambler_bb_sptr self) -> long"""
        return _digital_swig.additive_scrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(additive_scrambler_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.additive_scrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(additive_scrambler_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.additive_scrambler_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(additive_scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.additive_scrambler_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(additive_scrambler_bb_sptr self, std::string name)"""
        return _digital_swig.additive_scrambler_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(additive_scrambler_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.additive_scrambler_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(additive_scrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.additive_scrambler_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(additive_scrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.additive_scrambler_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(additive_scrambler_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.additive_scrambler_bb_sptr_message_subscribers(self, *args, **kwargs)

additive_scrambler_bb_sptr_swigregister = _digital_swig.additive_scrambler_bb_sptr_swigregister
additive_scrambler_bb_sptr_swigregister(additive_scrambler_bb_sptr)

additive_scrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
additive_scrambler_bb = additive_scrambler_bb.make;

class binary_slicer_fb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::binary_slicer_fb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::binary_slicer_fb)> self) -> binary_slicer_fb_sptr
        __init__(boost::shared_ptr<(gr::digital::binary_slicer_fb)> self, binary_slicer_fb p) -> binary_slicer_fb_sptr
        """
        this = _digital_swig.new_binary_slicer_fb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(binary_slicer_fb_sptr self) -> binary_slicer_fb"""
        return _digital_swig.binary_slicer_fb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_binary_slicer_fb_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(binary_slicer_fb_sptr self) -> binary_slicer_fb_sptr

        Slice float binary symbol producing 1 bit output.

        Constructor Specific Documentation:

        Make binary symbol slicer block.
        """
        return _digital_swig.binary_slicer_fb_sptr_make(self)

    def history(self):
        """history(binary_slicer_fb_sptr self) -> unsigned int"""
        return _digital_swig.binary_slicer_fb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(binary_slicer_fb_sptr self, int which, int delay)
        declare_sample_delay(binary_slicer_fb_sptr self, unsigned int delay)
        """
        return _digital_swig.binary_slicer_fb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(binary_slicer_fb_sptr self, int which) -> unsigned int"""
        return _digital_swig.binary_slicer_fb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(binary_slicer_fb_sptr self) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(binary_slicer_fb_sptr self) -> double"""
        return _digital_swig.binary_slicer_fb_sptr_relative_rate(self)

    def start(self):
        """start(binary_slicer_fb_sptr self) -> bool"""
        return _digital_swig.binary_slicer_fb_sptr_start(self)

    def stop(self):
        """stop(binary_slicer_fb_sptr self) -> bool"""
        return _digital_swig.binary_slicer_fb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(binary_slicer_fb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.binary_slicer_fb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(binary_slicer_fb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.binary_slicer_fb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(binary_slicer_fb_sptr self) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(binary_slicer_fb_sptr self, int m)"""
        return _digital_swig.binary_slicer_fb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(binary_slicer_fb_sptr self)"""
        return _digital_swig.binary_slicer_fb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(binary_slicer_fb_sptr self) -> bool"""
        return _digital_swig.binary_slicer_fb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(binary_slicer_fb_sptr self, int m)"""
        return _digital_swig.binary_slicer_fb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(binary_slicer_fb_sptr self) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(binary_slicer_fb_sptr self, int i) -> long"""
        return _digital_swig.binary_slicer_fb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(binary_slicer_fb_sptr self, long max_output_buffer)
        set_max_output_buffer(binary_slicer_fb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.binary_slicer_fb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(binary_slicer_fb_sptr self, int i) -> long"""
        return _digital_swig.binary_slicer_fb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(binary_slicer_fb_sptr self, long min_output_buffer)
        set_min_output_buffer(binary_slicer_fb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.binary_slicer_fb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(binary_slicer_fb_sptr self, int which) -> float
        pc_input_buffers_full(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(binary_slicer_fb_sptr self, int which) -> float
        pc_input_buffers_full_avg(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(binary_slicer_fb_sptr self, int which) -> float
        pc_input_buffers_full_var(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(binary_slicer_fb_sptr self, int which) -> float
        pc_output_buffers_full(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(binary_slicer_fb_sptr self, int which) -> float
        pc_output_buffers_full_avg(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(binary_slicer_fb_sptr self, int which) -> float
        pc_output_buffers_full_var(binary_slicer_fb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.binary_slicer_fb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(binary_slicer_fb_sptr self) -> float"""
        return _digital_swig.binary_slicer_fb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(binary_slicer_fb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.binary_slicer_fb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(binary_slicer_fb_sptr self)"""
        return _digital_swig.binary_slicer_fb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(binary_slicer_fb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.binary_slicer_fb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(binary_slicer_fb_sptr self) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(binary_slicer_fb_sptr self) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(binary_slicer_fb_sptr self, int priority) -> int"""
        return _digital_swig.binary_slicer_fb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(binary_slicer_fb_sptr self) -> std::string"""
        return _digital_swig.binary_slicer_fb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(binary_slicer_fb_sptr self) -> std::string"""
        return _digital_swig.binary_slicer_fb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(binary_slicer_fb_sptr self) -> io_signature_sptr"""
        return _digital_swig.binary_slicer_fb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(binary_slicer_fb_sptr self) -> io_signature_sptr"""
        return _digital_swig.binary_slicer_fb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(binary_slicer_fb_sptr self) -> long"""
        return _digital_swig.binary_slicer_fb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(binary_slicer_fb_sptr self) -> basic_block_sptr"""
        return _digital_swig.binary_slicer_fb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(binary_slicer_fb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.binary_slicer_fb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(binary_slicer_fb_sptr self) -> std::string"""
        return _digital_swig.binary_slicer_fb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(binary_slicer_fb_sptr self, std::string name)"""
        return _digital_swig.binary_slicer_fb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(binary_slicer_fb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.binary_slicer_fb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(binary_slicer_fb_sptr self) -> swig_int_ptr"""
        return _digital_swig.binary_slicer_fb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(binary_slicer_fb_sptr self) -> swig_int_ptr"""
        return _digital_swig.binary_slicer_fb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(binary_slicer_fb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.binary_slicer_fb_sptr_message_subscribers(self, *args, **kwargs)

binary_slicer_fb_sptr_swigregister = _digital_swig.binary_slicer_fb_sptr_swigregister
binary_slicer_fb_sptr_swigregister(binary_slicer_fb_sptr)

binary_slicer_fb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
binary_slicer_fb = binary_slicer_fb.make;

class chunks_to_symbols_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_bc)> self) -> chunks_to_symbols_bc_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_bc)> self, chunks_to_symbols_bc p) -> chunks_to_symbols_bc_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_bc_sptr self) -> chunks_to_symbols_bc"""
        return _digital_swig.chunks_to_symbols_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_bc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_bc_sptr self, pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_bc_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_bc_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_bc_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_bc_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_bc_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_bc_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_bc_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_bc_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_bc_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_bc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bc_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_bc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_bc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_bc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_bc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_bc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_bc_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_bc_sptr self)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_bc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_bc_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_bc_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_bc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_bc_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_bc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_bc_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_bc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_bc_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_bc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_bc_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_bc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_bc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_bc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_bc_sptr self)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_bc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_bc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_bc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_bc_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_bc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_bc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_bc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_bc_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_bc_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_bc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_bc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_bc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_bc_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_bc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_bc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_bc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_bc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bc_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_bc_sptr_swigregister = _digital_swig.chunks_to_symbols_bc_sptr_swigregister
chunks_to_symbols_bc_sptr_swigregister(chunks_to_symbols_bc_sptr)

chunks_to_symbols_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_bc = chunks_to_symbols_bc.make;

class chunks_to_symbols_bf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_bf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_bf)> self) -> chunks_to_symbols_bf_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_bf)> self, chunks_to_symbols_bf p) -> chunks_to_symbols_bf_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_bf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_bf_sptr self) -> chunks_to_symbols_bf"""
        return _digital_swig.chunks_to_symbols_bf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_bf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_bf_sptr self, pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_bf_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_bf_sptr self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_bf_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_bf_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_bf_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_bf_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_bf_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_bf_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_bf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bf_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_bf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_bf_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_bf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_bf_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_bf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_bf_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_bf_sptr self)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_bf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_bf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_bf_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_bf_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_bf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_bf_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_bf_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_bf_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_bf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_bf_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_bf_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_bf_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_bf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_bf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_bf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_bf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_bf_sptr self)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_bf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_bf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_bf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_bf_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_bf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_bf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_bf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_bf_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_bf_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_bf_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_bf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_bf_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_bf_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_bf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_bf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_bf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_bf_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_bf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_bf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_bf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_bf_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_bf_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_bf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_bf_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_bf_sptr_swigregister = _digital_swig.chunks_to_symbols_bf_sptr_swigregister
chunks_to_symbols_bf_sptr_swigregister(chunks_to_symbols_bf_sptr)

chunks_to_symbols_bf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_bf = chunks_to_symbols_bf.make;

class chunks_to_symbols_ic_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_ic)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_ic)> self) -> chunks_to_symbols_ic_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_ic)> self, chunks_to_symbols_ic p) -> chunks_to_symbols_ic_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_ic_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_ic_sptr self) -> chunks_to_symbols_ic"""
        return _digital_swig.chunks_to_symbols_ic_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_ic_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_ic_sptr self, pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_ic_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_ic_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_ic_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_ic_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_ic_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_ic_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_ic_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_ic_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_ic_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_ic_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_ic_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_ic_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_ic_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_ic_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_ic_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_ic_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_ic_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_ic_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_ic_sptr self)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_ic_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_ic_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_ic_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_ic_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_ic_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_ic_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_ic_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_ic_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_ic_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_ic_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_ic_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_ic_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_ic_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_ic_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_ic_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_ic_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_ic_sptr self)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_ic_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_ic_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_ic_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_ic_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_ic_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_ic_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_ic_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_ic_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_ic_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_ic_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_ic_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_ic_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_ic_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_ic_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_ic_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_ic_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_ic_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_ic_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_ic_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_ic_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_ic_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_ic_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_ic_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_ic_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_ic_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_ic_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_ic_sptr_swigregister = _digital_swig.chunks_to_symbols_ic_sptr_swigregister
chunks_to_symbols_ic_sptr_swigregister(chunks_to_symbols_ic_sptr)

chunks_to_symbols_ic_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_ic = chunks_to_symbols_ic.make;

class chunks_to_symbols_if_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_if)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_if)> self) -> chunks_to_symbols_if_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_if)> self, chunks_to_symbols_if p) -> chunks_to_symbols_if_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_if_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_if_sptr self) -> chunks_to_symbols_if"""
        return _digital_swig.chunks_to_symbols_if_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_if_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_if_sptr self, pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_if_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_if_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_if_sptr self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_if_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_if_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_if_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_if_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_if_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_if_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_if_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_if_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_if_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_if_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_if_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_if_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_if_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_if_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_if_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_if_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_if_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_if_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_if_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_if_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_if_sptr self)"""
        return _digital_swig.chunks_to_symbols_if_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_if_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_if_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_if_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_if_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_if_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_if_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_if_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_if_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_if_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_if_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_if_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_if_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_if_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_if_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_if_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_if_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_if_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_if_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_if_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_if_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_if_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_if_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_if_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_if_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_if_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_if_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_if_sptr self)"""
        return _digital_swig.chunks_to_symbols_if_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_if_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_if_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_if_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_if_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_if_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_if_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_if_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_if_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_if_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_if_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_if_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_if_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_if_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_if_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_if_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_if_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_if_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_if_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_if_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_if_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_if_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_if_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_if_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_if_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_if_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_if_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_if_sptr_swigregister = _digital_swig.chunks_to_symbols_if_sptr_swigregister
chunks_to_symbols_if_sptr_swigregister(chunks_to_symbols_if_sptr)

chunks_to_symbols_if_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_if = chunks_to_symbols_if.make;

class chunks_to_symbols_sc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_sc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_sc)> self) -> chunks_to_symbols_sc_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_sc)> self, chunks_to_symbols_sc p) -> chunks_to_symbols_sc_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_sc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_sc_sptr self) -> chunks_to_symbols_sc"""
        return _digital_swig.chunks_to_symbols_sc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_sc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_sc_sptr self, pmt_vector_cfloat symbol_table, int const D=1) -> chunks_to_symbols_sc_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_sc_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.chunks_to_symbols_sc_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_sc_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_sc_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_sc_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_sc_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_sc_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_sc_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_sc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sc_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_sc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_sc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_sc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_sc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_sc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_sc_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_sc_sptr self)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_sc_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_sc_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_sc_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_sc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_sc_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_sc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_sc_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_sc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_sc_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_sc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_sc_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_sc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_sc_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_sc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_sc_sptr self)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_sc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_sc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_sc_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_sc_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_sc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_sc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_sc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_sc_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_sc_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_sc_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_sc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_sc_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_sc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_sc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_sc_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_sc_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_sc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_sc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_sc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_sc_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_sc_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_sc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sc_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_sc_sptr_swigregister = _digital_swig.chunks_to_symbols_sc_sptr_swigregister
chunks_to_symbols_sc_sptr_swigregister(chunks_to_symbols_sc_sptr)

chunks_to_symbols_sc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_sc = chunks_to_symbols_sc.make;

class chunks_to_symbols_sf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::chunks_to_symbols_sf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_sf)> self) -> chunks_to_symbols_sf_sptr
        __init__(boost::shared_ptr<(gr::digital::chunks_to_symbols_sf)> self, chunks_to_symbols_sf p) -> chunks_to_symbols_sf_sptr
        """
        this = _digital_swig.new_chunks_to_symbols_sf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(chunks_to_symbols_sf_sptr self) -> chunks_to_symbols_sf"""
        return _digital_swig.chunks_to_symbols_sf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_chunks_to_symbols_sf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(chunks_to_symbols_sf_sptr self, pmt_vector_float symbol_table, int const D=1) -> chunks_to_symbols_sf_sptr

        Map a stream of unpacked symbol indexes to stream of float or complex constellation points in D dimensions (D = 1 by default)

        The combination of gr::blocks::packed_to_unpacked_XX followed by gr::digital::chunks_to_symbols_XY handles the general case of mapping from a stream of bytes or shorts into arbitrary float or complex symbols.

        Constructor Specific Documentation:

        Make a chunks-to-symbols block.

        Args:
            symbol_table : list that maps chunks to symbols.
            D : dimension of table.
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_make(self, *args, **kwargs)

    def D(self):
        """D(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_D(self)

    def symbol_table(self):
        """symbol_table(chunks_to_symbols_sf_sptr self) -> pmt_vector_float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_symbol_table(self)

    def history(self):
        """history(chunks_to_symbols_sf_sptr self) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(chunks_to_symbols_sf_sptr self, int which, int delay)
        declare_sample_delay(chunks_to_symbols_sf_sptr self, unsigned int delay)
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(chunks_to_symbols_sf_sptr self, int which) -> unsigned int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(chunks_to_symbols_sf_sptr self) -> double"""
        return _digital_swig.chunks_to_symbols_sf_sptr_relative_rate(self)

    def start(self):
        """start(chunks_to_symbols_sf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sf_sptr_start(self)

    def stop(self):
        """stop(chunks_to_symbols_sf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(chunks_to_symbols_sf_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_sf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(chunks_to_symbols_sf_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.chunks_to_symbols_sf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(chunks_to_symbols_sf_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(chunks_to_symbols_sf_sptr self)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(chunks_to_symbols_sf_sptr self) -> bool"""
        return _digital_swig.chunks_to_symbols_sf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(chunks_to_symbols_sf_sptr self, int m)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(chunks_to_symbols_sf_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_sf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(chunks_to_symbols_sf_sptr self, long max_output_buffer)
        set_max_output_buffer(chunks_to_symbols_sf_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(chunks_to_symbols_sf_sptr self, int i) -> long"""
        return _digital_swig.chunks_to_symbols_sf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(chunks_to_symbols_sf_sptr self, long min_output_buffer)
        set_min_output_buffer(chunks_to_symbols_sf_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_input_buffers_full(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_input_buffers_full_avg(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_input_buffers_full_var(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_output_buffers_full(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_output_buffers_full_avg(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(chunks_to_symbols_sf_sptr self, int which) -> float
        pc_output_buffers_full_var(chunks_to_symbols_sf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(chunks_to_symbols_sf_sptr self) -> float"""
        return _digital_swig.chunks_to_symbols_sf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(chunks_to_symbols_sf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(chunks_to_symbols_sf_sptr self)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(chunks_to_symbols_sf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.chunks_to_symbols_sf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(chunks_to_symbols_sf_sptr self) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(chunks_to_symbols_sf_sptr self, int priority) -> int"""
        return _digital_swig.chunks_to_symbols_sf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(chunks_to_symbols_sf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(chunks_to_symbols_sf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(chunks_to_symbols_sf_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(chunks_to_symbols_sf_sptr self) -> io_signature_sptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(chunks_to_symbols_sf_sptr self) -> long"""
        return _digital_swig.chunks_to_symbols_sf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(chunks_to_symbols_sf_sptr self) -> basic_block_sptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(chunks_to_symbols_sf_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.chunks_to_symbols_sf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(chunks_to_symbols_sf_sptr self) -> std::string"""
        return _digital_swig.chunks_to_symbols_sf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(chunks_to_symbols_sf_sptr self, std::string name)"""
        return _digital_swig.chunks_to_symbols_sf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(chunks_to_symbols_sf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.chunks_to_symbols_sf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(chunks_to_symbols_sf_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(chunks_to_symbols_sf_sptr self) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(chunks_to_symbols_sf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.chunks_to_symbols_sf_sptr_message_subscribers(self, *args, **kwargs)

chunks_to_symbols_sf_sptr_swigregister = _digital_swig.chunks_to_symbols_sf_sptr_swigregister
chunks_to_symbols_sf_sptr_swigregister(chunks_to_symbols_sf_sptr)

chunks_to_symbols_sf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
chunks_to_symbols_sf = chunks_to_symbols_sf.make;

class clock_recovery_mm_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::clock_recovery_mm_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::clock_recovery_mm_cc)> self) -> clock_recovery_mm_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::clock_recovery_mm_cc)> self, clock_recovery_mm_cc p) -> clock_recovery_mm_cc_sptr
        """
        this = _digital_swig.new_clock_recovery_mm_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(clock_recovery_mm_cc_sptr self) -> clock_recovery_mm_cc"""
        return _digital_swig.clock_recovery_mm_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_clock_recovery_mm_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(clock_recovery_mm_cc_sptr self, float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_cc_sptr

        Mueller and M?ller (M&M) based clock recovery block with complex input, complex output.

        This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

        The complex version here is based on: Modified Mueller and Muller clock recovery circuit:

        G. R. Danesfahani, T.G. Jeans, "Optimisation of modified Mueller
           and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22 June 1995, pp. 1032 - 1033.

        Constructor Specific Documentation:

        Make a M&M clock recovery block.

        Args:
            omega : Initial estimate of samples per symbol
            gain_omega : Gain setting for omega update loop
            mu : Initial estimate of phase of sample
            gain_mu : Gain setting for mu update loop
            omega_relative_limit : limit on omega
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_mu(self)

    def omega(self):
        """omega(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_omega(self)

    def gain_mu(self):
        """gain_mu(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """gain_omega(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_gain_omega(self)

    def set_verbose(self, *args, **kwargs):
        """set_verbose(clock_recovery_mm_cc_sptr self, bool verbose)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_verbose(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(clock_recovery_mm_cc_sptr self, float gain_mu)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(clock_recovery_mm_cc_sptr self, float gain_omega)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(clock_recovery_mm_cc_sptr self, float mu)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(clock_recovery_mm_cc_sptr self, float omega)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_omega(self, *args, **kwargs)

    def history(self):
        """history(clock_recovery_mm_cc_sptr self) -> unsigned int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(clock_recovery_mm_cc_sptr self, int which, int delay)
        declare_sample_delay(clock_recovery_mm_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(clock_recovery_mm_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(clock_recovery_mm_cc_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(clock_recovery_mm_cc_sptr self) -> double"""
        return _digital_swig.clock_recovery_mm_cc_sptr_relative_rate(self)

    def start(self):
        """start(clock_recovery_mm_cc_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_cc_sptr_start(self)

    def stop(self):
        """stop(clock_recovery_mm_cc_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(clock_recovery_mm_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.clock_recovery_mm_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(clock_recovery_mm_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.clock_recovery_mm_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(clock_recovery_mm_cc_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(clock_recovery_mm_cc_sptr self, int m)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(clock_recovery_mm_cc_sptr self)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(clock_recovery_mm_cc_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(clock_recovery_mm_cc_sptr self, int m)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(clock_recovery_mm_cc_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(clock_recovery_mm_cc_sptr self, int i) -> long"""
        return _digital_swig.clock_recovery_mm_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(clock_recovery_mm_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(clock_recovery_mm_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(clock_recovery_mm_cc_sptr self, int i) -> long"""
        return _digital_swig.clock_recovery_mm_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(clock_recovery_mm_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(clock_recovery_mm_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_input_buffers_full(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_output_buffers_full(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(clock_recovery_mm_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(clock_recovery_mm_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(clock_recovery_mm_cc_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(clock_recovery_mm_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(clock_recovery_mm_cc_sptr self)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(clock_recovery_mm_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.clock_recovery_mm_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(clock_recovery_mm_cc_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(clock_recovery_mm_cc_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(clock_recovery_mm_cc_sptr self, int priority) -> int"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(clock_recovery_mm_cc_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(clock_recovery_mm_cc_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(clock_recovery_mm_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(clock_recovery_mm_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(clock_recovery_mm_cc_sptr self) -> long"""
        return _digital_swig.clock_recovery_mm_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(clock_recovery_mm_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(clock_recovery_mm_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.clock_recovery_mm_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(clock_recovery_mm_cc_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(clock_recovery_mm_cc_sptr self, std::string name)"""
        return _digital_swig.clock_recovery_mm_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(clock_recovery_mm_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.clock_recovery_mm_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(clock_recovery_mm_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(clock_recovery_mm_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(clock_recovery_mm_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_cc_sptr_message_subscribers(self, *args, **kwargs)

clock_recovery_mm_cc_sptr_swigregister = _digital_swig.clock_recovery_mm_cc_sptr_swigregister
clock_recovery_mm_cc_sptr_swigregister(clock_recovery_mm_cc_sptr)

clock_recovery_mm_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
clock_recovery_mm_cc = clock_recovery_mm_cc.make;

class clock_recovery_mm_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::clock_recovery_mm_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::clock_recovery_mm_ff)> self) -> clock_recovery_mm_ff_sptr
        __init__(boost::shared_ptr<(gr::digital::clock_recovery_mm_ff)> self, clock_recovery_mm_ff p) -> clock_recovery_mm_ff_sptr
        """
        this = _digital_swig.new_clock_recovery_mm_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(clock_recovery_mm_ff_sptr self) -> clock_recovery_mm_ff"""
        return _digital_swig.clock_recovery_mm_ff_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_clock_recovery_mm_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(clock_recovery_mm_ff_sptr self, float omega, float gain_omega, float mu, float gain_mu, float omega_relative_limit) -> clock_recovery_mm_ff_sptr

        Mueller and M?ller (M&M) based clock recovery block with float input, float output.

        This implements the Mueller and M?ller (M&M) discrete-time error-tracking synchronizer.

        See "Digital Communication Receivers: Synchronization, Channel
        Estimation and Signal Processing" by Heinrich Meyr, Marc Moeneclaey, & Stefan Fechtel. ISBN 0-471-50275-8.

        Constructor Specific Documentation:

        Make a M&M clock recovery block.

        Args:
            omega : Initial estimate of samples per symbol
            gain_omega : Gain setting for omega update loop
            mu : Initial estimate of phase of sample
            gain_mu : Gain setting for mu update loop
            omega_relative_limit : limit on omega
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_make(self, *args, **kwargs)

    def mu(self):
        """mu(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_mu(self)

    def omega(self):
        """omega(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_omega(self)

    def gain_mu(self):
        """gain_mu(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_gain_mu(self)

    def gain_omega(self):
        """gain_omega(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_gain_omega(self)

    def set_verbose(self, *args, **kwargs):
        """set_verbose(clock_recovery_mm_ff_sptr self, bool verbose)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_verbose(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """set_gain_mu(clock_recovery_mm_ff_sptr self, float gain_mu)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """set_gain_omega(clock_recovery_mm_ff_sptr self, float gain_omega)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_gain_omega(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """set_mu(clock_recovery_mm_ff_sptr self, float mu)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """set_omega(clock_recovery_mm_ff_sptr self, float omega)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_omega(self, *args, **kwargs)

    def history(self):
        """history(clock_recovery_mm_ff_sptr self) -> unsigned int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(clock_recovery_mm_ff_sptr self, int which, int delay)
        declare_sample_delay(clock_recovery_mm_ff_sptr self, unsigned int delay)
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(clock_recovery_mm_ff_sptr self, int which) -> unsigned int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(clock_recovery_mm_ff_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(clock_recovery_mm_ff_sptr self) -> double"""
        return _digital_swig.clock_recovery_mm_ff_sptr_relative_rate(self)

    def start(self):
        """start(clock_recovery_mm_ff_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_ff_sptr_start(self)

    def stop(self):
        """stop(clock_recovery_mm_ff_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(clock_recovery_mm_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.clock_recovery_mm_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(clock_recovery_mm_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.clock_recovery_mm_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(clock_recovery_mm_ff_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(clock_recovery_mm_ff_sptr self, int m)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(clock_recovery_mm_ff_sptr self)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(clock_recovery_mm_ff_sptr self) -> bool"""
        return _digital_swig.clock_recovery_mm_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(clock_recovery_mm_ff_sptr self, int m)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(clock_recovery_mm_ff_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(clock_recovery_mm_ff_sptr self, int i) -> long"""
        return _digital_swig.clock_recovery_mm_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(clock_recovery_mm_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(clock_recovery_mm_ff_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(clock_recovery_mm_ff_sptr self, int i) -> long"""
        return _digital_swig.clock_recovery_mm_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(clock_recovery_mm_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(clock_recovery_mm_ff_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_input_buffers_full(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_output_buffers_full(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(clock_recovery_mm_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(clock_recovery_mm_ff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(clock_recovery_mm_ff_sptr self) -> float"""
        return _digital_swig.clock_recovery_mm_ff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(clock_recovery_mm_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(clock_recovery_mm_ff_sptr self)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(clock_recovery_mm_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.clock_recovery_mm_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(clock_recovery_mm_ff_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(clock_recovery_mm_ff_sptr self) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(clock_recovery_mm_ff_sptr self, int priority) -> int"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(clock_recovery_mm_ff_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(clock_recovery_mm_ff_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(clock_recovery_mm_ff_sptr self) -> io_signature_sptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(clock_recovery_mm_ff_sptr self) -> io_signature_sptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(clock_recovery_mm_ff_sptr self) -> long"""
        return _digital_swig.clock_recovery_mm_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(clock_recovery_mm_ff_sptr self) -> basic_block_sptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(clock_recovery_mm_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.clock_recovery_mm_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(clock_recovery_mm_ff_sptr self) -> std::string"""
        return _digital_swig.clock_recovery_mm_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(clock_recovery_mm_ff_sptr self, std::string name)"""
        return _digital_swig.clock_recovery_mm_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(clock_recovery_mm_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.clock_recovery_mm_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(clock_recovery_mm_ff_sptr self) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(clock_recovery_mm_ff_sptr self) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(clock_recovery_mm_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.clock_recovery_mm_ff_sptr_message_subscribers(self, *args, **kwargs)

clock_recovery_mm_ff_sptr_swigregister = _digital_swig.clock_recovery_mm_ff_sptr_swigregister
clock_recovery_mm_ff_sptr_swigregister(clock_recovery_mm_ff_sptr)

clock_recovery_mm_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
clock_recovery_mm_ff = clock_recovery_mm_ff.make;

class cma_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::cma_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::cma_equalizer_cc)> self) -> cma_equalizer_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::cma_equalizer_cc)> self, cma_equalizer_cc p) -> cma_equalizer_cc_sptr
        """
        this = _digital_swig.new_cma_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(cma_equalizer_cc_sptr self) -> cma_equalizer_cc"""
        return _digital_swig.cma_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_cma_equalizer_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(cma_equalizer_cc_sptr self, int num_taps, float modulus, float mu, int sps) -> cma_equalizer_cc_sptr

        Implements constant modulus adaptive filter on complex stream.

        The error value and tap update equations (for p=2) can be found in:

        D. Godard, "Self-Recovering Equalization and Carrier Tracking
        in Two-Dimensional Data Communication Systems," IEEE Transactions on Communications, Vol. 28, No. 11, pp. 1867 - 1875, 1980.

        Constructor Specific Documentation:

        Make a CMA Equalizer block

        Args:
            num_taps : Numer of taps in the equalizer (channel size)
            modulus : Modulus of the modulated signals
            mu : Gain of the update loop
            sps : Number of samples per symbol of the input signal
        """
        return _digital_swig.cma_equalizer_cc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(cma_equalizer_cc_sptr self, pmt_vector_cfloat taps)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(cma_equalizer_cc_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.cma_equalizer_cc_sptr_taps(self)

    def gain(self):
        """gain(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(cma_equalizer_cc_sptr self, float mu)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def modulus(self):
        """modulus(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_modulus(self)

    def set_modulus(self, *args, **kwargs):
        """set_modulus(cma_equalizer_cc_sptr self, float mod)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_modulus(self, *args, **kwargs)

    def history(self):
        """history(cma_equalizer_cc_sptr self) -> unsigned int"""
        return _digital_swig.cma_equalizer_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(cma_equalizer_cc_sptr self, int which, int delay)
        declare_sample_delay(cma_equalizer_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.cma_equalizer_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(cma_equalizer_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.cma_equalizer_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(cma_equalizer_cc_sptr self) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(cma_equalizer_cc_sptr self) -> double"""
        return _digital_swig.cma_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(cma_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.cma_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(cma_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.cma_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(cma_equalizer_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.cma_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(cma_equalizer_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.cma_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(cma_equalizer_cc_sptr self) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(cma_equalizer_cc_sptr self, int m)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(cma_equalizer_cc_sptr self)"""
        return _digital_swig.cma_equalizer_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(cma_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.cma_equalizer_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(cma_equalizer_cc_sptr self, int m)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(cma_equalizer_cc_sptr self) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(cma_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.cma_equalizer_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(cma_equalizer_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(cma_equalizer_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.cma_equalizer_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(cma_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.cma_equalizer_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(cma_equalizer_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(cma_equalizer_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.cma_equalizer_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(cma_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(cma_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(cma_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(cma_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(cma_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(cma_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(cma_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.cma_equalizer_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(cma_equalizer_cc_sptr self) -> float"""
        return _digital_swig.cma_equalizer_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(cma_equalizer_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(cma_equalizer_cc_sptr self)"""
        return _digital_swig.cma_equalizer_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(cma_equalizer_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.cma_equalizer_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(cma_equalizer_cc_sptr self) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(cma_equalizer_cc_sptr self) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(cma_equalizer_cc_sptr self, int priority) -> int"""
        return _digital_swig.cma_equalizer_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(cma_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.cma_equalizer_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(cma_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.cma_equalizer_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(cma_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.cma_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(cma_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.cma_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(cma_equalizer_cc_sptr self) -> long"""
        return _digital_swig.cma_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(cma_equalizer_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.cma_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(cma_equalizer_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.cma_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(cma_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.cma_equalizer_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(cma_equalizer_cc_sptr self, std::string name)"""
        return _digital_swig.cma_equalizer_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(cma_equalizer_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.cma_equalizer_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(cma_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.cma_equalizer_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(cma_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.cma_equalizer_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(cma_equalizer_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.cma_equalizer_cc_sptr_message_subscribers(self, *args, **kwargs)

cma_equalizer_cc_sptr_swigregister = _digital_swig.cma_equalizer_cc_sptr_swigregister
cma_equalizer_cc_sptr_swigregister(cma_equalizer_cc_sptr)

cma_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
cma_equalizer_cc = cma_equalizer_cc.make;

class constellation_decoder_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_decoder_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_decoder_cb)> self) -> constellation_decoder_cb_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_decoder_cb)> self, constellation_decoder_cb p) -> constellation_decoder_cb_sptr
        """
        this = _digital_swig.new_constellation_decoder_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_decoder_cb_sptr self) -> constellation_decoder_cb"""
        return _digital_swig.constellation_decoder_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_decoder_cb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_decoder_cb_sptr self, constellation_sptr constellation) -> constellation_decoder_cb_sptr

        Constellation Decoder.

        Decode a constellation's points from a complex space to (unpacked) bits based on the map of the  object.

        Constructor Specific Documentation:

        Make constellation decoder block.

        Args:
            constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.constellation_decoder_cb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(constellation_decoder_cb_sptr self) -> unsigned int"""
        return _digital_swig.constellation_decoder_cb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(constellation_decoder_cb_sptr self, int which, int delay)
        declare_sample_delay(constellation_decoder_cb_sptr self, unsigned int delay)
        """
        return _digital_swig.constellation_decoder_cb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(constellation_decoder_cb_sptr self, int which) -> unsigned int"""
        return _digital_swig.constellation_decoder_cb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(constellation_decoder_cb_sptr self) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(constellation_decoder_cb_sptr self) -> double"""
        return _digital_swig.constellation_decoder_cb_sptr_relative_rate(self)

    def start(self):
        """start(constellation_decoder_cb_sptr self) -> bool"""
        return _digital_swig.constellation_decoder_cb_sptr_start(self)

    def stop(self):
        """stop(constellation_decoder_cb_sptr self) -> bool"""
        return _digital_swig.constellation_decoder_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(constellation_decoder_cb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.constellation_decoder_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(constellation_decoder_cb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.constellation_decoder_cb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(constellation_decoder_cb_sptr self) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(constellation_decoder_cb_sptr self, int m)"""
        return _digital_swig.constellation_decoder_cb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(constellation_decoder_cb_sptr self)"""
        return _digital_swig.constellation_decoder_cb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(constellation_decoder_cb_sptr self) -> bool"""
        return _digital_swig.constellation_decoder_cb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(constellation_decoder_cb_sptr self, int m)"""
        return _digital_swig.constellation_decoder_cb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(constellation_decoder_cb_sptr self) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(constellation_decoder_cb_sptr self, int i) -> long"""
        return _digital_swig.constellation_decoder_cb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(constellation_decoder_cb_sptr self, long max_output_buffer)
        set_max_output_buffer(constellation_decoder_cb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.constellation_decoder_cb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(constellation_decoder_cb_sptr self, int i) -> long"""
        return _digital_swig.constellation_decoder_cb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(constellation_decoder_cb_sptr self, long min_output_buffer)
        set_min_output_buffer(constellation_decoder_cb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.constellation_decoder_cb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(constellation_decoder_cb_sptr self, int which) -> float
        pc_input_buffers_full(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(constellation_decoder_cb_sptr self, int which) -> float
        pc_input_buffers_full_avg(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(constellation_decoder_cb_sptr self, int which) -> float
        pc_input_buffers_full_var(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(constellation_decoder_cb_sptr self, int which) -> float
        pc_output_buffers_full(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(constellation_decoder_cb_sptr self, int which) -> float
        pc_output_buffers_full_avg(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(constellation_decoder_cb_sptr self, int which) -> float
        pc_output_buffers_full_var(constellation_decoder_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_decoder_cb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(constellation_decoder_cb_sptr self) -> float"""
        return _digital_swig.constellation_decoder_cb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(constellation_decoder_cb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.constellation_decoder_cb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(constellation_decoder_cb_sptr self)"""
        return _digital_swig.constellation_decoder_cb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(constellation_decoder_cb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.constellation_decoder_cb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(constellation_decoder_cb_sptr self) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(constellation_decoder_cb_sptr self) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(constellation_decoder_cb_sptr self, int priority) -> int"""
        return _digital_swig.constellation_decoder_cb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(constellation_decoder_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_decoder_cb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(constellation_decoder_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_decoder_cb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(constellation_decoder_cb_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_decoder_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(constellation_decoder_cb_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_decoder_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(constellation_decoder_cb_sptr self) -> long"""
        return _digital_swig.constellation_decoder_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(constellation_decoder_cb_sptr self) -> basic_block_sptr"""
        return _digital_swig.constellation_decoder_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(constellation_decoder_cb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.constellation_decoder_cb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(constellation_decoder_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_decoder_cb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(constellation_decoder_cb_sptr self, std::string name)"""
        return _digital_swig.constellation_decoder_cb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(constellation_decoder_cb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.constellation_decoder_cb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(constellation_decoder_cb_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_decoder_cb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(constellation_decoder_cb_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_decoder_cb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(constellation_decoder_cb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.constellation_decoder_cb_sptr_message_subscribers(self, *args, **kwargs)

constellation_decoder_cb_sptr_swigregister = _digital_swig.constellation_decoder_cb_sptr_swigregister
constellation_decoder_cb_sptr_swigregister(constellation_decoder_cb_sptr)

constellation_decoder_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
constellation_decoder_cb = constellation_decoder_cb.make;

class constellation_receiver_cb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_receiver_cb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_receiver_cb)> self) -> constellation_receiver_cb_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_receiver_cb)> self, constellation_receiver_cb p) -> constellation_receiver_cb_sptr
        """
        this = _digital_swig.new_constellation_receiver_cb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_receiver_cb_sptr self) -> constellation_receiver_cb"""
        return _digital_swig.constellation_receiver_cb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_receiver_cb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_receiver_cb_sptr self, constellation_sptr constellation, float loop_bw, float fmin, float fmax) -> constellation_receiver_cb_sptr

        This block makes hard decisions about the received symbols (using a constellation object) and also fine tunes phase synchronization.

        The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error.

        Constructor Specific Documentation:

        Constructs a constellation receiver that (phase/fine freq) synchronizes and decodes constellation points specified by a constellation object.

        Args:
            constellation : constellation of points for generic modulation
            loop_bw : Loop bandwidth of the Costas Loop (~ 2pi/100)
            fmin : minimum normalized frequency value the loop can achieve
            fmax : maximum normalized frequency value the loop can achieve
        """
        return _digital_swig.constellation_receiver_cb_sptr_make(self, *args, **kwargs)

    def phase_error_tracking(self, *args, **kwargs):
        """phase_error_tracking(constellation_receiver_cb_sptr self, float phase_error)"""
        return _digital_swig.constellation_receiver_cb_sptr_phase_error_tracking(self, *args, **kwargs)

    def history(self):
        """history(constellation_receiver_cb_sptr self) -> unsigned int"""
        return _digital_swig.constellation_receiver_cb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(constellation_receiver_cb_sptr self, int which, int delay)
        declare_sample_delay(constellation_receiver_cb_sptr self, unsigned int delay)
        """
        return _digital_swig.constellation_receiver_cb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(constellation_receiver_cb_sptr self, int which) -> unsigned int"""
        return _digital_swig.constellation_receiver_cb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(constellation_receiver_cb_sptr self) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(constellation_receiver_cb_sptr self) -> double"""
        return _digital_swig.constellation_receiver_cb_sptr_relative_rate(self)

    def start(self):
        """start(constellation_receiver_cb_sptr self) -> bool"""
        return _digital_swig.constellation_receiver_cb_sptr_start(self)

    def stop(self):
        """stop(constellation_receiver_cb_sptr self) -> bool"""
        return _digital_swig.constellation_receiver_cb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(constellation_receiver_cb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.constellation_receiver_cb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(constellation_receiver_cb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.constellation_receiver_cb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(constellation_receiver_cb_sptr self) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(constellation_receiver_cb_sptr self, int m)"""
        return _digital_swig.constellation_receiver_cb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(constellation_receiver_cb_sptr self)"""
        return _digital_swig.constellation_receiver_cb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(constellation_receiver_cb_sptr self) -> bool"""
        return _digital_swig.constellation_receiver_cb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(constellation_receiver_cb_sptr self, int m)"""
        return _digital_swig.constellation_receiver_cb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(constellation_receiver_cb_sptr self) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(constellation_receiver_cb_sptr self, int i) -> long"""
        return _digital_swig.constellation_receiver_cb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(constellation_receiver_cb_sptr self, long max_output_buffer)
        set_max_output_buffer(constellation_receiver_cb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.constellation_receiver_cb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(constellation_receiver_cb_sptr self, int i) -> long"""
        return _digital_swig.constellation_receiver_cb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(constellation_receiver_cb_sptr self, long min_output_buffer)
        set_min_output_buffer(constellation_receiver_cb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.constellation_receiver_cb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(constellation_receiver_cb_sptr self, int which) -> float
        pc_input_buffers_full(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(constellation_receiver_cb_sptr self, int which) -> float
        pc_input_buffers_full_avg(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(constellation_receiver_cb_sptr self, int which) -> float
        pc_input_buffers_full_var(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(constellation_receiver_cb_sptr self, int which) -> float
        pc_output_buffers_full(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(constellation_receiver_cb_sptr self, int which) -> float
        pc_output_buffers_full_avg(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(constellation_receiver_cb_sptr self, int which) -> float
        pc_output_buffers_full_var(constellation_receiver_cb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_receiver_cb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(constellation_receiver_cb_sptr self) -> float"""
        return _digital_swig.constellation_receiver_cb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(constellation_receiver_cb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.constellation_receiver_cb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(constellation_receiver_cb_sptr self)"""
        return _digital_swig.constellation_receiver_cb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(constellation_receiver_cb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.constellation_receiver_cb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(constellation_receiver_cb_sptr self) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(constellation_receiver_cb_sptr self) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(constellation_receiver_cb_sptr self, int priority) -> int"""
        return _digital_swig.constellation_receiver_cb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(constellation_receiver_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_receiver_cb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(constellation_receiver_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_receiver_cb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(constellation_receiver_cb_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_receiver_cb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(constellation_receiver_cb_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_receiver_cb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(constellation_receiver_cb_sptr self) -> long"""
        return _digital_swig.constellation_receiver_cb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(constellation_receiver_cb_sptr self) -> basic_block_sptr"""
        return _digital_swig.constellation_receiver_cb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(constellation_receiver_cb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.constellation_receiver_cb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(constellation_receiver_cb_sptr self) -> std::string"""
        return _digital_swig.constellation_receiver_cb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(constellation_receiver_cb_sptr self, std::string name)"""
        return _digital_swig.constellation_receiver_cb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(constellation_receiver_cb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.constellation_receiver_cb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(constellation_receiver_cb_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_receiver_cb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(constellation_receiver_cb_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_receiver_cb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(constellation_receiver_cb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.constellation_receiver_cb_sptr_message_subscribers(self, *args, **kwargs)

constellation_receiver_cb_sptr_swigregister = _digital_swig.constellation_receiver_cb_sptr_swigregister
constellation_receiver_cb_sptr_swigregister(constellation_receiver_cb_sptr)

constellation_receiver_cb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
constellation_receiver_cb = constellation_receiver_cb.make;

class constellation_soft_decoder_cf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_soft_decoder_cf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_soft_decoder_cf)> self) -> constellation_soft_decoder_cf_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_soft_decoder_cf)> self, constellation_soft_decoder_cf p) -> constellation_soft_decoder_cf_sptr
        """
        this = _digital_swig.new_constellation_soft_decoder_cf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_soft_decoder_cf_sptr self) -> constellation_soft_decoder_cf"""
        return _digital_swig.constellation_soft_decoder_cf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_soft_decoder_cf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_soft_decoder_cf_sptr self, constellation_sptr constellation) -> constellation_soft_decoder_cf_sptr

        Constellation Decoder.

        Decode a constellation's points from a complex space to soft bits based on the map and soft decision LUT of the  object.

        Constructor Specific Documentation:

        Make constellation decoder block.

        Args:
            constellation : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(constellation_soft_decoder_cf_sptr self) -> unsigned int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(constellation_soft_decoder_cf_sptr self, int which, int delay)
        declare_sample_delay(constellation_soft_decoder_cf_sptr self, unsigned int delay)
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(constellation_soft_decoder_cf_sptr self, int which) -> unsigned int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(constellation_soft_decoder_cf_sptr self) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(constellation_soft_decoder_cf_sptr self) -> double"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_relative_rate(self)

    def start(self):
        """start(constellation_soft_decoder_cf_sptr self) -> bool"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_start(self)

    def stop(self):
        """stop(constellation_soft_decoder_cf_sptr self) -> bool"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(constellation_soft_decoder_cf_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(constellation_soft_decoder_cf_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(constellation_soft_decoder_cf_sptr self) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(constellation_soft_decoder_cf_sptr self, int m)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(constellation_soft_decoder_cf_sptr self)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(constellation_soft_decoder_cf_sptr self) -> bool"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(constellation_soft_decoder_cf_sptr self, int m)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(constellation_soft_decoder_cf_sptr self) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(constellation_soft_decoder_cf_sptr self, int i) -> long"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(constellation_soft_decoder_cf_sptr self, long max_output_buffer)
        set_max_output_buffer(constellation_soft_decoder_cf_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(constellation_soft_decoder_cf_sptr self, int i) -> long"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(constellation_soft_decoder_cf_sptr self, long min_output_buffer)
        set_min_output_buffer(constellation_soft_decoder_cf_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_input_buffers_full(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_input_buffers_full_avg(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_input_buffers_full_var(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_output_buffers_full(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_output_buffers_full_avg(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(constellation_soft_decoder_cf_sptr self, int which) -> float
        pc_output_buffers_full_var(constellation_soft_decoder_cf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(constellation_soft_decoder_cf_sptr self) -> float"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(constellation_soft_decoder_cf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(constellation_soft_decoder_cf_sptr self)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(constellation_soft_decoder_cf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(constellation_soft_decoder_cf_sptr self) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(constellation_soft_decoder_cf_sptr self) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(constellation_soft_decoder_cf_sptr self, int priority) -> int"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(constellation_soft_decoder_cf_sptr self) -> std::string"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(constellation_soft_decoder_cf_sptr self) -> std::string"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(constellation_soft_decoder_cf_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(constellation_soft_decoder_cf_sptr self) -> io_signature_sptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(constellation_soft_decoder_cf_sptr self) -> long"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(constellation_soft_decoder_cf_sptr self) -> basic_block_sptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(constellation_soft_decoder_cf_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(constellation_soft_decoder_cf_sptr self) -> std::string"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(constellation_soft_decoder_cf_sptr self, std::string name)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(constellation_soft_decoder_cf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.constellation_soft_decoder_cf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(constellation_soft_decoder_cf_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(constellation_soft_decoder_cf_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(constellation_soft_decoder_cf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.constellation_soft_decoder_cf_sptr_message_subscribers(self, *args, **kwargs)

constellation_soft_decoder_cf_sptr_swigregister = _digital_swig.constellation_soft_decoder_cf_sptr_swigregister
constellation_soft_decoder_cf_sptr_swigregister(constellation_soft_decoder_cf_sptr)

constellation_soft_decoder_cf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
constellation_soft_decoder_cf = constellation_soft_decoder_cf.make;

class correlate_access_code_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::correlate_access_code_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_bb)> self) -> correlate_access_code_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_bb)> self, correlate_access_code_bb p) -> correlate_access_code_bb_sptr
        """
        this = _digital_swig.new_correlate_access_code_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(correlate_access_code_bb_sptr self) -> correlate_access_code_bb"""
        return _digital_swig.correlate_access_code_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(correlate_access_code_bb_sptr self, std::string const & access_code, int threshold) -> correlate_access_code_bb_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: stream of bits, 2 bits per output byte (data in LSB, flag in next higher bit)

        Each output byte contains two valid bits, the data bit, and the flag bit. The LSB (bit 0) is the data bit, and is the original input data, delayed 64 bits. Bit 1 is the flag bit and is 1 if the corresponding data bit is the first data bit following the access code. Otherwise the flag bit is 0.

        Constructor Specific Documentation:

        Make a correlate_access_code block.

        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
        """
        return _digital_swig.correlate_access_code_bb_sptr_make(self, *args, **kwargs)

    def set_access_code(self, *args, **kwargs):
        """
        set_access_code(correlate_access_code_bb_sptr self, std::string const & access_code) -> bool

        Set a new access code.
        """
        return _digital_swig.correlate_access_code_bb_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(correlate_access_code_bb_sptr self) -> unsigned int"""
        return _digital_swig.correlate_access_code_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(correlate_access_code_bb_sptr self, int which, int delay)
        declare_sample_delay(correlate_access_code_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.correlate_access_code_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(correlate_access_code_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.correlate_access_code_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(correlate_access_code_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(correlate_access_code_bb_sptr self) -> double"""
        return _digital_swig.correlate_access_code_bb_sptr_relative_rate(self)

    def start(self):
        """start(correlate_access_code_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_sptr_start(self)

    def stop(self):
        """stop(correlate_access_code_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(correlate_access_code_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.correlate_access_code_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(correlate_access_code_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.correlate_access_code_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(correlate_access_code_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(correlate_access_code_bb_sptr self, int m)"""
        return _digital_swig.correlate_access_code_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(correlate_access_code_bb_sptr self)"""
        return _digital_swig.correlate_access_code_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(correlate_access_code_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(correlate_access_code_bb_sptr self, int m)"""
        return _digital_swig.correlate_access_code_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(correlate_access_code_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(correlate_access_code_bb_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(correlate_access_code_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(correlate_access_code_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.correlate_access_code_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(correlate_access_code_bb_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(correlate_access_code_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(correlate_access_code_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.correlate_access_code_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(correlate_access_code_bb_sptr self, int which) -> float
        pc_input_buffers_full(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(correlate_access_code_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(correlate_access_code_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(correlate_access_code_bb_sptr self, int which) -> float
        pc_output_buffers_full(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(correlate_access_code_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(correlate_access_code_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(correlate_access_code_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(correlate_access_code_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(correlate_access_code_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.correlate_access_code_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(correlate_access_code_bb_sptr self)"""
        return _digital_swig.correlate_access_code_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(correlate_access_code_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.correlate_access_code_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(correlate_access_code_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(correlate_access_code_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(correlate_access_code_bb_sptr self, int priority) -> int"""
        return _digital_swig.correlate_access_code_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(correlate_access_code_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(correlate_access_code_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(correlate_access_code_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(correlate_access_code_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(correlate_access_code_bb_sptr self) -> long"""
        return _digital_swig.correlate_access_code_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(correlate_access_code_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.correlate_access_code_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(correlate_access_code_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.correlate_access_code_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(correlate_access_code_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(correlate_access_code_bb_sptr self, std::string name)"""
        return _digital_swig.correlate_access_code_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(correlate_access_code_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.correlate_access_code_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(correlate_access_code_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(correlate_access_code_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(correlate_access_code_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_sptr_message_subscribers(self, *args, **kwargs)

correlate_access_code_bb_sptr_swigregister = _digital_swig.correlate_access_code_bb_sptr_swigregister
correlate_access_code_bb_sptr_swigregister(correlate_access_code_bb_sptr)

correlate_access_code_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
correlate_access_code_bb = correlate_access_code_bb.make;

class correlate_access_code_tag_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::correlate_access_code_tag_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_tag_bb)> self) -> correlate_access_code_tag_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_tag_bb)> self, correlate_access_code_tag_bb p) -> correlate_access_code_tag_bb_sptr
        """
        this = _digital_swig.new_correlate_access_code_tag_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(correlate_access_code_tag_bb_sptr self) -> correlate_access_code_tag_bb"""
        return _digital_swig.correlate_access_code_tag_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_tag_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(correlate_access_code_tag_bb_sptr self, std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_tag_bb_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

        This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_make(self, *args, **kwargs)

    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_tag_bb_sptr self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(correlate_access_code_tag_bb_sptr self) -> unsigned int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(correlate_access_code_tag_bb_sptr self, int which, int delay)
        declare_sample_delay(correlate_access_code_tag_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(correlate_access_code_tag_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(correlate_access_code_tag_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(correlate_access_code_tag_bb_sptr self) -> double"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_relative_rate(self)

    def start(self):
        """start(correlate_access_code_tag_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_start(self)

    def stop(self):
        """stop(correlate_access_code_tag_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(correlate_access_code_tag_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(correlate_access_code_tag_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(correlate_access_code_tag_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(correlate_access_code_tag_bb_sptr self, int m)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(correlate_access_code_tag_bb_sptr self)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(correlate_access_code_tag_bb_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(correlate_access_code_tag_bb_sptr self, int m)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(correlate_access_code_tag_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(correlate_access_code_tag_bb_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(correlate_access_code_tag_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(correlate_access_code_tag_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(correlate_access_code_tag_bb_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(correlate_access_code_tag_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(correlate_access_code_tag_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_input_buffers_full(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_output_buffers_full(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(correlate_access_code_tag_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(correlate_access_code_tag_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(correlate_access_code_tag_bb_sptr self) -> float"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(correlate_access_code_tag_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(correlate_access_code_tag_bb_sptr self)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(correlate_access_code_tag_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(correlate_access_code_tag_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(correlate_access_code_tag_bb_sptr self) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(correlate_access_code_tag_bb_sptr self, int priority) -> int"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(correlate_access_code_tag_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(correlate_access_code_tag_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(correlate_access_code_tag_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(correlate_access_code_tag_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(correlate_access_code_tag_bb_sptr self) -> long"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(correlate_access_code_tag_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(correlate_access_code_tag_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(correlate_access_code_tag_bb_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(correlate_access_code_tag_bb_sptr self, std::string name)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(correlate_access_code_tag_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.correlate_access_code_tag_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(correlate_access_code_tag_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(correlate_access_code_tag_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(correlate_access_code_tag_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_tag_bb_sptr_message_subscribers(self, *args, **kwargs)

correlate_access_code_tag_bb_sptr_swigregister = _digital_swig.correlate_access_code_tag_bb_sptr_swigregister
correlate_access_code_tag_bb_sptr_swigregister(correlate_access_code_tag_bb_sptr)

correlate_access_code_tag_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
correlate_access_code_tag_bb = correlate_access_code_tag_bb.make;

class correlate_access_code_bb_ts_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::correlate_access_code_bb_ts)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_bb_ts)> self) -> correlate_access_code_bb_ts_sptr
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_bb_ts)> self, correlate_access_code_bb_ts p) -> correlate_access_code_bb_ts_sptr
        """
        this = _digital_swig.new_correlate_access_code_bb_ts_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(correlate_access_code_bb_ts_sptr self) -> correlate_access_code_bb_ts"""
        return _digital_swig.correlate_access_code_bb_ts_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_bb_ts_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(correlate_access_code_bb_ts_sptr self, std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_bb_ts_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of bits, 1 bit per input byte (data in LSB) output: unaltered stream of bits (plus tags)

        This block annotates the input stream with tags. The tags have key name [tag_name], specified in the constructor. Used for searching an input data stream for preambles, etc.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_make(self, *args, **kwargs)

    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_bb_ts_sptr self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_access_code(self, *args, **kwargs)

    def history(self):
        """history(correlate_access_code_bb_ts_sptr self) -> unsigned int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(correlate_access_code_bb_ts_sptr self, int which, int delay)
        declare_sample_delay(correlate_access_code_bb_ts_sptr self, unsigned int delay)
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(correlate_access_code_bb_ts_sptr self, int which) -> unsigned int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(correlate_access_code_bb_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(correlate_access_code_bb_ts_sptr self) -> double"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_relative_rate(self)

    def start(self):
        """start(correlate_access_code_bb_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_start(self)

    def stop(self):
        """stop(correlate_access_code_bb_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(correlate_access_code_bb_ts_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(correlate_access_code_bb_ts_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(correlate_access_code_bb_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(correlate_access_code_bb_ts_sptr self, int m)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(correlate_access_code_bb_ts_sptr self)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(correlate_access_code_bb_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(correlate_access_code_bb_ts_sptr self, int m)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(correlate_access_code_bb_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(correlate_access_code_bb_ts_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(correlate_access_code_bb_ts_sptr self, long max_output_buffer)
        set_max_output_buffer(correlate_access_code_bb_ts_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(correlate_access_code_bb_ts_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(correlate_access_code_bb_ts_sptr self, long min_output_buffer)
        set_min_output_buffer(correlate_access_code_bb_ts_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_input_buffers_full(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_input_buffers_full_avg(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_input_buffers_full_var(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_output_buffers_full(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_output_buffers_full_avg(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(correlate_access_code_bb_ts_sptr self, int which) -> float
        pc_output_buffers_full_var(correlate_access_code_bb_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(correlate_access_code_bb_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(correlate_access_code_bb_ts_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(correlate_access_code_bb_ts_sptr self)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(correlate_access_code_bb_ts_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(correlate_access_code_bb_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(correlate_access_code_bb_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(correlate_access_code_bb_ts_sptr self, int priority) -> int"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(correlate_access_code_bb_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_name(self)

    def symbol_name(self):
        """symbol_name(correlate_access_code_bb_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(correlate_access_code_bb_ts_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(correlate_access_code_bb_ts_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(correlate_access_code_bb_ts_sptr self) -> long"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(correlate_access_code_bb_ts_sptr self) -> basic_block_sptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(correlate_access_code_bb_ts_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(correlate_access_code_bb_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(correlate_access_code_bb_ts_sptr self, std::string name)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(correlate_access_code_bb_ts_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.correlate_access_code_bb_ts_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(correlate_access_code_bb_ts_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(correlate_access_code_bb_ts_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(correlate_access_code_bb_ts_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_bb_ts_sptr_message_subscribers(self, *args, **kwargs)

correlate_access_code_bb_ts_sptr_swigregister = _digital_swig.correlate_access_code_bb_ts_sptr_swigregister
correlate_access_code_bb_ts_sptr_swigregister(correlate_access_code_bb_ts_sptr)

correlate_access_code_bb_ts_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
correlate_access_code_bb_ts = correlate_access_code_bb_ts.make;

class correlate_access_code_ff_ts_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::correlate_access_code_ff_ts)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_ff_ts)> self) -> correlate_access_code_ff_ts_sptr
        __init__(boost::shared_ptr<(gr::digital::correlate_access_code_ff_ts)> self, correlate_access_code_ff_ts p) -> correlate_access_code_ff_ts_sptr
        """
        this = _digital_swig.new_correlate_access_code_ff_ts_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(correlate_access_code_ff_ts_sptr self) -> correlate_access_code_ff_ts"""
        return _digital_swig.correlate_access_code_ff_ts_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_correlate_access_code_ff_ts_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(correlate_access_code_ff_ts_sptr self, std::string const & access_code, int threshold, std::string const & tag_name) -> correlate_access_code_ff_ts_sptr

        Examine input for specified access code, one bit at a time.

        input: stream of floats (generally, soft decisions) output: unaltered stream of floats in a tagged stream

        This block searches for the given access code by slicing the soft decision symbol inputs. Once found, it expects the following 32 samples to contain a header that includes the frame length. It decodes the header to get the frame length in order to set up the the tagged stream key information.

        The output of this block is appropriate for use with tagged stream blocks.

        Constructor Specific Documentation:



        Args:
            access_code : is represented with 1 byte per bit, e.g., "010101010111000100"
            threshold : maximum number of bits that may be wrong
            tag_name : key of the tag inserted into the tag stream
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_make(self, *args, **kwargs)

    def set_access_code(self, *args, **kwargs):
        """set_access_code(correlate_access_code_ff_ts_sptr self, std::string const & access_code) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_access_code(self, *args, **kwargs)

    def access_code(self):
        """access_code(correlate_access_code_ff_ts_sptr self) -> unsigned long long"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_access_code(self)

    def history(self):
        """history(correlate_access_code_ff_ts_sptr self) -> unsigned int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(correlate_access_code_ff_ts_sptr self, int which, int delay)
        declare_sample_delay(correlate_access_code_ff_ts_sptr self, unsigned int delay)
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(correlate_access_code_ff_ts_sptr self, int which) -> unsigned int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(correlate_access_code_ff_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(correlate_access_code_ff_ts_sptr self) -> double"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_relative_rate(self)

    def start(self):
        """start(correlate_access_code_ff_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_start(self)

    def stop(self):
        """stop(correlate_access_code_ff_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(correlate_access_code_ff_ts_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(correlate_access_code_ff_ts_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(correlate_access_code_ff_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(correlate_access_code_ff_ts_sptr self, int m)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(correlate_access_code_ff_ts_sptr self)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(correlate_access_code_ff_ts_sptr self) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(correlate_access_code_ff_ts_sptr self, int m)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(correlate_access_code_ff_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(correlate_access_code_ff_ts_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(correlate_access_code_ff_ts_sptr self, long max_output_buffer)
        set_max_output_buffer(correlate_access_code_ff_ts_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(correlate_access_code_ff_ts_sptr self, int i) -> long"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(correlate_access_code_ff_ts_sptr self, long min_output_buffer)
        set_min_output_buffer(correlate_access_code_ff_ts_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_input_buffers_full(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_input_buffers_full_avg(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_input_buffers_full_var(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_output_buffers_full(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_output_buffers_full_avg(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(correlate_access_code_ff_ts_sptr self, int which) -> float
        pc_output_buffers_full_var(correlate_access_code_ff_ts_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(correlate_access_code_ff_ts_sptr self) -> float"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(correlate_access_code_ff_ts_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(correlate_access_code_ff_ts_sptr self)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(correlate_access_code_ff_ts_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(correlate_access_code_ff_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(correlate_access_code_ff_ts_sptr self) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(correlate_access_code_ff_ts_sptr self, int priority) -> int"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(correlate_access_code_ff_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_name(self)

    def symbol_name(self):
        """symbol_name(correlate_access_code_ff_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(correlate_access_code_ff_ts_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(correlate_access_code_ff_ts_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(correlate_access_code_ff_ts_sptr self) -> long"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(correlate_access_code_ff_ts_sptr self) -> basic_block_sptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(correlate_access_code_ff_ts_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(correlate_access_code_ff_ts_sptr self) -> std::string"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(correlate_access_code_ff_ts_sptr self, std::string name)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(correlate_access_code_ff_ts_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.correlate_access_code_ff_ts_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(correlate_access_code_ff_ts_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(correlate_access_code_ff_ts_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(correlate_access_code_ff_ts_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.correlate_access_code_ff_ts_sptr_message_subscribers(self, *args, **kwargs)

correlate_access_code_ff_ts_sptr_swigregister = _digital_swig.correlate_access_code_ff_ts_sptr_swigregister
correlate_access_code_ff_ts_sptr_swigregister(correlate_access_code_ff_ts_sptr)

correlate_access_code_ff_ts_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
correlate_access_code_ff_ts = correlate_access_code_ff_ts.make;

class correlate_and_sync_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::correlate_and_sync_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::correlate_and_sync_cc)> self) -> correlate_and_sync_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::correlate_and_sync_cc)> self, correlate_and_sync_cc p) -> correlate_and_sync_cc_sptr
        """
        this = _digital_swig.new_correlate_and_sync_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(correlate_and_sync_cc_sptr self) -> correlate_and_sync_cc"""
        return _digital_swig.correlate_and_sync_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_correlate_and_sync_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(correlate_and_sync_cc_sptr self, pmt_vector_cfloat symbols, pmt_vector_float filter, unsigned int sps, unsigned int nfilts=32) -> correlate_and_sync_cc_sptr

        Correlate to a preamble and send time/phase sync info.

        Input: 
        Output: 
        This block is designed to search for a preamble by correlation and uses the results of the correlation to get a time and phase offset estimate. These estimates are passed downstream as stream tags for use by follow-on synchronization blocks.

        The preamble is provided as a set of symbols along with a baseband matched filter which we use to create the filtered and upsampled symbol that we will receive over-the-air.

        The phase_est tag is used to adjust the phase estimation of any downstream synchronization blocks and is currently used by the gr::digital::costas_loop_cc block.

        The time_est tag is used to adjust the sampling timing estimation of any downstream synchronization blocks and is currently used by the gr::digital::pfb_clock_sync_ccf block.

        Constructor Specific Documentation:

        Make a block that correlates against the  vector and outputs a phase and symbol timing estimate.

        Args:
            symbols : Set of symbols to correlate against (e.g., a preamble).
            filter : Baseband matched filter (e.g., RRC)
            sps : Samples per symbol
            nfilts : Number of filters in the internal PFB
        """
        return _digital_swig.correlate_and_sync_cc_sptr_make(self, *args, **kwargs)

    def symbols(self):
        """symbols(correlate_and_sync_cc_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.correlate_and_sync_cc_sptr_symbols(self)

    def set_symbols(self, *args, **kwargs):
        """set_symbols(correlate_and_sync_cc_sptr self, pmt_vector_cfloat symbols)"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_symbols(self, *args, **kwargs)

    def history(self):
        """history(correlate_and_sync_cc_sptr self) -> unsigned int"""
        return _digital_swig.correlate_and_sync_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(correlate_and_sync_cc_sptr self, int which, int delay)
        declare_sample_delay(correlate_and_sync_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.correlate_and_sync_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(correlate_and_sync_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.correlate_and_sync_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(correlate_and_sync_cc_sptr self) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(correlate_and_sync_cc_sptr self) -> double"""
        return _digital_swig.correlate_and_sync_cc_sptr_relative_rate(self)

    def start(self):
        """start(correlate_and_sync_cc_sptr self) -> bool"""
        return _digital_swig.correlate_and_sync_cc_sptr_start(self)

    def stop(self):
        """stop(correlate_and_sync_cc_sptr self) -> bool"""
        return _digital_swig.correlate_and_sync_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(correlate_and_sync_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.correlate_and_sync_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(correlate_and_sync_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.correlate_and_sync_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(correlate_and_sync_cc_sptr self) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(correlate_and_sync_cc_sptr self, int m)"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(correlate_and_sync_cc_sptr self)"""
        return _digital_swig.correlate_and_sync_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(correlate_and_sync_cc_sptr self) -> bool"""
        return _digital_swig.correlate_and_sync_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(correlate_and_sync_cc_sptr self, int m)"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(correlate_and_sync_cc_sptr self) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(correlate_and_sync_cc_sptr self, int i) -> long"""
        return _digital_swig.correlate_and_sync_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(correlate_and_sync_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(correlate_and_sync_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.correlate_and_sync_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(correlate_and_sync_cc_sptr self, int i) -> long"""
        return _digital_swig.correlate_and_sync_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(correlate_and_sync_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(correlate_and_sync_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.correlate_and_sync_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(correlate_and_sync_cc_sptr self, int which) -> float
        pc_input_buffers_full(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(correlate_and_sync_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(correlate_and_sync_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(correlate_and_sync_cc_sptr self, int which) -> float
        pc_output_buffers_full(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(correlate_and_sync_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(correlate_and_sync_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(correlate_and_sync_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.correlate_and_sync_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(correlate_and_sync_cc_sptr self) -> float"""
        return _digital_swig.correlate_and_sync_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(correlate_and_sync_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(correlate_and_sync_cc_sptr self)"""
        return _digital_swig.correlate_and_sync_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(correlate_and_sync_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.correlate_and_sync_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(correlate_and_sync_cc_sptr self) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(correlate_and_sync_cc_sptr self) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(correlate_and_sync_cc_sptr self, int priority) -> int"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(correlate_and_sync_cc_sptr self) -> std::string"""
        return _digital_swig.correlate_and_sync_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(correlate_and_sync_cc_sptr self) -> std::string"""
        return _digital_swig.correlate_and_sync_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(correlate_and_sync_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(correlate_and_sync_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(correlate_and_sync_cc_sptr self) -> long"""
        return _digital_swig.correlate_and_sync_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(correlate_and_sync_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(correlate_and_sync_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.correlate_and_sync_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(correlate_and_sync_cc_sptr self) -> std::string"""
        return _digital_swig.correlate_and_sync_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(correlate_and_sync_cc_sptr self, std::string name)"""
        return _digital_swig.correlate_and_sync_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(correlate_and_sync_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.correlate_and_sync_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(correlate_and_sync_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(correlate_and_sync_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(correlate_and_sync_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.correlate_and_sync_cc_sptr_message_subscribers(self, *args, **kwargs)

correlate_and_sync_cc_sptr_swigregister = _digital_swig.correlate_and_sync_cc_sptr_swigregister
correlate_and_sync_cc_sptr_swigregister(correlate_and_sync_cc_sptr)

correlate_and_sync_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
correlate_and_sync_cc = correlate_and_sync_cc.make;

class costas_loop_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::costas_loop_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::costas_loop_cc)> self) -> costas_loop_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::costas_loop_cc)> self, costas_loop_cc p) -> costas_loop_cc_sptr
        """
        this = _digital_swig.new_costas_loop_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(costas_loop_cc_sptr self) -> costas_loop_cc"""
        return _digital_swig.costas_loop_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_costas_loop_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(costas_loop_cc_sptr self, float loop_bw, int order) -> costas_loop_cc_sptr

        A Costas loop carrier recovery module.

        The Costas loop locks to the center frequency of a signal and downconverts it to baseband.




        More details can be found online:

        J. Feigin, "Practical Costas loop design: Designing a simple
        and inexpensive BPSK Costas loop carrier recovery circuit," RF signal processing, pp. 20-36, 2002.



        The Costas loop can have two output streams:

        Constructor Specific Documentation:

        Make a Costas loop carrier recovery block.

        Args:
            loop_bw : internal 2nd order loop bandwidth (~ 2pi/100)
            order : the loop order, either 2, 4, or 8
        """
        return _digital_swig.costas_loop_cc_sptr_make(self, *args, **kwargs)

    def error(self):
        """
        error(costas_loop_cc_sptr self) -> float

        Returns the current value of the loop error.
        """
        return _digital_swig.costas_loop_cc_sptr_error(self)

    def history(self):
        """history(costas_loop_cc_sptr self) -> unsigned int"""
        return _digital_swig.costas_loop_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(costas_loop_cc_sptr self, int which, int delay)
        declare_sample_delay(costas_loop_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.costas_loop_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(costas_loop_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.costas_loop_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(costas_loop_cc_sptr self) -> int"""
        return _digital_swig.costas_loop_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(costas_loop_cc_sptr self) -> double"""
        return _digital_swig.costas_loop_cc_sptr_relative_rate(self)

    def start(self):
        """start(costas_loop_cc_sptr self) -> bool"""
        return _digital_swig.costas_loop_cc_sptr_start(self)

    def stop(self):
        """stop(costas_loop_cc_sptr self) -> bool"""
        return _digital_swig.costas_loop_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(costas_loop_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.costas_loop_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(costas_loop_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.costas_loop_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(costas_loop_cc_sptr self) -> int"""
        return _digital_swig.costas_loop_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(costas_loop_cc_sptr self, int m)"""
        return _digital_swig.costas_loop_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(costas_loop_cc_sptr self)"""
        return _digital_swig.costas_loop_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(costas_loop_cc_sptr self) -> bool"""
        return _digital_swig.costas_loop_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(costas_loop_cc_sptr self, int m)"""
        return _digital_swig.costas_loop_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(costas_loop_cc_sptr self) -> int"""
        return _digital_swig.costas_loop_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(costas_loop_cc_sptr self, int i) -> long"""
        return _digital_swig.costas_loop_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(costas_loop_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(costas_loop_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.costas_loop_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(costas_loop_cc_sptr self, int i) -> long"""
        return _digital_swig.costas_loop_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(costas_loop_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(costas_loop_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.costas_loop_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(costas_loop_cc_sptr self, int which) -> float
        pc_input_buffers_full(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(costas_loop_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(costas_loop_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(costas_loop_cc_sptr self, int which) -> float
        pc_output_buffers_full(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(costas_loop_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(costas_loop_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(costas_loop_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.costas_loop_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(costas_loop_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.costas_loop_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(costas_loop_cc_sptr self)"""
        return _digital_swig.costas_loop_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(costas_loop_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.costas_loop_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(costas_loop_cc_sptr self) -> int"""
        return _digital_swig.costas_loop_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(costas_loop_cc_sptr self) -> int"""
        return _digital_swig.costas_loop_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(costas_loop_cc_sptr self, int priority) -> int"""
        return _digital_swig.costas_loop_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(costas_loop_cc_sptr self) -> std::string"""
        return _digital_swig.costas_loop_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(costas_loop_cc_sptr self) -> std::string"""
        return _digital_swig.costas_loop_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(costas_loop_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.costas_loop_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(costas_loop_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.costas_loop_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(costas_loop_cc_sptr self) -> long"""
        return _digital_swig.costas_loop_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(costas_loop_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.costas_loop_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(costas_loop_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.costas_loop_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(costas_loop_cc_sptr self) -> std::string"""
        return _digital_swig.costas_loop_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(costas_loop_cc_sptr self, std::string name)"""
        return _digital_swig.costas_loop_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(costas_loop_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.costas_loop_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(costas_loop_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.costas_loop_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(costas_loop_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.costas_loop_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(costas_loop_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.costas_loop_cc_sptr_message_subscribers(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(costas_loop_cc_sptr self)"""
        return _digital_swig.costas_loop_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(costas_loop_cc_sptr self, float error)"""
        return _digital_swig.costas_loop_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(costas_loop_cc_sptr self)"""
        return _digital_swig.costas_loop_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(costas_loop_cc_sptr self)"""
        return _digital_swig.costas_loop_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(costas_loop_cc_sptr self, float bw)"""
        return _digital_swig.costas_loop_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(costas_loop_cc_sptr self, float df)"""
        return _digital_swig.costas_loop_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(costas_loop_cc_sptr self, float alpha)"""
        return _digital_swig.costas_loop_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(costas_loop_cc_sptr self, float beta)"""
        return _digital_swig.costas_loop_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(costas_loop_cc_sptr self, float freq)"""
        return _digital_swig.costas_loop_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(costas_loop_cc_sptr self, float phase)"""
        return _digital_swig.costas_loop_cc_sptr_set_phase(self, *args, **kwargs)

    def set_max_freq(self, *args, **kwargs):
        """set_max_freq(costas_loop_cc_sptr self, float freq)"""
        return _digital_swig.costas_loop_cc_sptr_set_max_freq(self, *args, **kwargs)

    def set_min_freq(self, *args, **kwargs):
        """set_min_freq(costas_loop_cc_sptr self, float freq)"""
        return _digital_swig.costas_loop_cc_sptr_set_min_freq(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_phase(self)

    def get_max_freq(self):
        """get_max_freq(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_max_freq(self)

    def get_min_freq(self):
        """get_min_freq(costas_loop_cc_sptr self) -> float"""
        return _digital_swig.costas_loop_cc_sptr_get_min_freq(self)

costas_loop_cc_sptr_swigregister = _digital_swig.costas_loop_cc_sptr_swigregister
costas_loop_cc_sptr_swigregister(costas_loop_cc_sptr)

costas_loop_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
costas_loop_cc = costas_loop_cc.make;

class crc32_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::crc32_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::crc32_bb)> self) -> crc32_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::crc32_bb)> self, crc32_bb p) -> crc32_bb_sptr
        """
        this = _digital_swig.new_crc32_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(crc32_bb_sptr self) -> crc32_bb"""
        return _digital_swig.crc32_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_crc32_bb_sptr
    __del__ = lambda self : None;
    def make(self, check=False, lengthtagname="packet_len"):
        """
        make(crc32_bb_sptr self, bool check=False, std::string const & lengthtagname="packet_len") -> crc32_bb_sptr

        Byte-stream CRC block.

        Input: stream of bytes, which form a packet. The first byte of the packet has a tag with key "length" and the value being the number of bytes in the packet.

        Output: The same bytes as incoming, but trailing a CRC32 of the packet. The tag is re-set to the new length.

        Constructor Specific Documentation:



        Args:
            check : Set to true if you want to check CRC, false to create CRC.
            lengthtagname : Length tag key
        """
        return _digital_swig.crc32_bb_sptr_make(self, check, lengthtagname)

    def history(self):
        """history(crc32_bb_sptr self) -> unsigned int"""
        return _digital_swig.crc32_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(crc32_bb_sptr self, int which, int delay)
        declare_sample_delay(crc32_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.crc32_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(crc32_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.crc32_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(crc32_bb_sptr self) -> int"""
        return _digital_swig.crc32_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(crc32_bb_sptr self) -> double"""
        return _digital_swig.crc32_bb_sptr_relative_rate(self)

    def start(self):
        """start(crc32_bb_sptr self) -> bool"""
        return _digital_swig.crc32_bb_sptr_start(self)

    def stop(self):
        """stop(crc32_bb_sptr self) -> bool"""
        return _digital_swig.crc32_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(crc32_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.crc32_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(crc32_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.crc32_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(crc32_bb_sptr self) -> int"""
        return _digital_swig.crc32_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(crc32_bb_sptr self, int m)"""
        return _digital_swig.crc32_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(crc32_bb_sptr self)"""
        return _digital_swig.crc32_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(crc32_bb_sptr self) -> bool"""
        return _digital_swig.crc32_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(crc32_bb_sptr self, int m)"""
        return _digital_swig.crc32_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(crc32_bb_sptr self) -> int"""
        return _digital_swig.crc32_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(crc32_bb_sptr self, int i) -> long"""
        return _digital_swig.crc32_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(crc32_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(crc32_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.crc32_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(crc32_bb_sptr self, int i) -> long"""
        return _digital_swig.crc32_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(crc32_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(crc32_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.crc32_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(crc32_bb_sptr self, int which) -> float
        pc_input_buffers_full(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(crc32_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(crc32_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(crc32_bb_sptr self, int which) -> float
        pc_output_buffers_full(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(crc32_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(crc32_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(crc32_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(crc32_bb_sptr self) -> float"""
        return _digital_swig.crc32_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(crc32_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.crc32_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(crc32_bb_sptr self)"""
        return _digital_swig.crc32_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(crc32_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.crc32_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(crc32_bb_sptr self) -> int"""
        return _digital_swig.crc32_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(crc32_bb_sptr self) -> int"""
        return _digital_swig.crc32_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(crc32_bb_sptr self, int priority) -> int"""
        return _digital_swig.crc32_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(crc32_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(crc32_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(crc32_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.crc32_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(crc32_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.crc32_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(crc32_bb_sptr self) -> long"""
        return _digital_swig.crc32_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(crc32_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.crc32_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(crc32_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.crc32_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(crc32_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(crc32_bb_sptr self, std::string name)"""
        return _digital_swig.crc32_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(crc32_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.crc32_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(crc32_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.crc32_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(crc32_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.crc32_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(crc32_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.crc32_bb_sptr_message_subscribers(self, *args, **kwargs)

crc32_bb_sptr_swigregister = _digital_swig.crc32_bb_sptr_swigregister
crc32_bb_sptr_swigregister(crc32_bb_sptr)

crc32_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
crc32_bb = crc32_bb.make;

class crc32_async_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::crc32_async_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::crc32_async_bb)> self) -> crc32_async_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::crc32_async_bb)> self, crc32_async_bb p) -> crc32_async_bb_sptr
        """
        this = _digital_swig.new_crc32_async_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(crc32_async_bb_sptr self) -> crc32_async_bb"""
        return _digital_swig.crc32_async_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_crc32_async_bb_sptr
    __del__ = lambda self : None;
    def make(self, check=False):
        """
        make(crc32_async_bb_sptr self, bool check=False) -> crc32_async_bb_sptr

        Byte-stream CRC block for async messages.

        Processes packets (as async PDU messages) for CRC32. The  parameter determines if the block acts to check and strip the CRC or to calculate and append the CRC32.

        The input PDU is expected to be a message of packet bytes.

        When using check mode, if the CRC passes, the output is a payload of the message with the CRC stripped, so the output will be 4 bytes smaller than the input.

        When using calculate mode (check == false), then the CRC is calculated on the PDU and appended to it. The output is then 4 bytes longer than the input.

        This block implements the CRC32 using the Boost crc_optimal class for 32-bit CRCs with the standard generator 0x04C11DB7.

        Constructor Specific Documentation:



        Args:
            check : Set to true if you want to check CRC, false to create CRC.
        """
        return _digital_swig.crc32_async_bb_sptr_make(self, check)

    def history(self):
        """history(crc32_async_bb_sptr self) -> unsigned int"""
        return _digital_swig.crc32_async_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(crc32_async_bb_sptr self, int which, int delay)
        declare_sample_delay(crc32_async_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.crc32_async_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(crc32_async_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.crc32_async_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(crc32_async_bb_sptr self) -> int"""
        return _digital_swig.crc32_async_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(crc32_async_bb_sptr self) -> double"""
        return _digital_swig.crc32_async_bb_sptr_relative_rate(self)

    def start(self):
        """start(crc32_async_bb_sptr self) -> bool"""
        return _digital_swig.crc32_async_bb_sptr_start(self)

    def stop(self):
        """stop(crc32_async_bb_sptr self) -> bool"""
        return _digital_swig.crc32_async_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(crc32_async_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.crc32_async_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(crc32_async_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.crc32_async_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(crc32_async_bb_sptr self) -> int"""
        return _digital_swig.crc32_async_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(crc32_async_bb_sptr self, int m)"""
        return _digital_swig.crc32_async_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(crc32_async_bb_sptr self)"""
        return _digital_swig.crc32_async_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(crc32_async_bb_sptr self) -> bool"""
        return _digital_swig.crc32_async_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(crc32_async_bb_sptr self, int m)"""
        return _digital_swig.crc32_async_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(crc32_async_bb_sptr self) -> int"""
        return _digital_swig.crc32_async_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(crc32_async_bb_sptr self, int i) -> long"""
        return _digital_swig.crc32_async_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(crc32_async_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(crc32_async_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.crc32_async_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(crc32_async_bb_sptr self, int i) -> long"""
        return _digital_swig.crc32_async_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(crc32_async_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(crc32_async_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.crc32_async_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(crc32_async_bb_sptr self, int which) -> float
        pc_input_buffers_full(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(crc32_async_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(crc32_async_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(crc32_async_bb_sptr self, int which) -> float
        pc_output_buffers_full(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(crc32_async_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(crc32_async_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(crc32_async_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.crc32_async_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(crc32_async_bb_sptr self) -> float"""
        return _digital_swig.crc32_async_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(crc32_async_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.crc32_async_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(crc32_async_bb_sptr self)"""
        return _digital_swig.crc32_async_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(crc32_async_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.crc32_async_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(crc32_async_bb_sptr self) -> int"""
        return _digital_swig.crc32_async_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(crc32_async_bb_sptr self) -> int"""
        return _digital_swig.crc32_async_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(crc32_async_bb_sptr self, int priority) -> int"""
        return _digital_swig.crc32_async_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(crc32_async_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_async_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(crc32_async_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_async_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(crc32_async_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.crc32_async_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(crc32_async_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.crc32_async_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(crc32_async_bb_sptr self) -> long"""
        return _digital_swig.crc32_async_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(crc32_async_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.crc32_async_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(crc32_async_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.crc32_async_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(crc32_async_bb_sptr self) -> std::string"""
        return _digital_swig.crc32_async_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(crc32_async_bb_sptr self, std::string name)"""
        return _digital_swig.crc32_async_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(crc32_async_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.crc32_async_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(crc32_async_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.crc32_async_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(crc32_async_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.crc32_async_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(crc32_async_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.crc32_async_bb_sptr_message_subscribers(self, *args, **kwargs)

crc32_async_bb_sptr_swigregister = _digital_swig.crc32_async_bb_sptr_swigregister
crc32_async_bb_sptr_swigregister(crc32_async_bb_sptr)

crc32_async_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
crc32_async_bb = crc32_async_bb.make;

class cpmmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::cpmmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::cpmmod_bc)> self) -> cpmmod_bc_sptr
        __init__(boost::shared_ptr<(gr::digital::cpmmod_bc)> self, cpmmod_bc p) -> cpmmod_bc_sptr
        """
        this = _digital_swig.new_cpmmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(cpmmod_bc_sptr self) -> cpmmod_bc"""
        return _digital_swig.cpmmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_cpmmod_bc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(cpmmod_bc_sptr self, gr::analog::cpm::cpm_type type, float h, int samples_per_sym, int L, double beta=0.3) -> cpmmod_bc_sptr

        Generic CPM modulator.

        Examples:


        The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

        Constructor Specific Documentation:

        Make CPM modulator block.

        Args:
            type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
            h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
            samples_per_sym : Samples per symbol.
            L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
            beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
        """
        return _digital_swig.cpmmod_bc_sptr_make(self, *args, **kwargs)

    def make_gmskmod_bc(self, samples_per_sym=2, L=4, beta=0.3):
        """
        make_gmskmod_bc(cpmmod_bc_sptr self, int samples_per_sym=2, int L=4, double beta=0.3) -> cpmmod_bc_sptr

        Make GMSK modulator block.

        The type is GAUSSIAN and the modulation index for GMSK is 0.5. This are populated automatically by this factory function.
        """
        return _digital_swig.cpmmod_bc_sptr_make_gmskmod_bc(self, samples_per_sym, L, beta)

    def taps(self):
        """
        taps(cpmmod_bc_sptr self) -> pmt_vector_float

        Return the phase response FIR taps.
        """
        return _digital_swig.cpmmod_bc_sptr_taps(self)

    def type(self):
        """
        type(cpmmod_bc_sptr self) -> int

        Return the type of CPM modulator.
        """
        return _digital_swig.cpmmod_bc_sptr_type(self)

    def index(self):
        """
        index(cpmmod_bc_sptr self) -> float

        Return the modulation index of the modulator.
        """
        return _digital_swig.cpmmod_bc_sptr_index(self)

    def samples_per_sym(self):
        """
        samples_per_sym(cpmmod_bc_sptr self) -> int

        Return the number of samples per symbol.
        """
        return _digital_swig.cpmmod_bc_sptr_samples_per_sym(self)

    def length(self):
        """
        length(cpmmod_bc_sptr self) -> int

        Return the length of the phase duration (in symbols)
        """
        return _digital_swig.cpmmod_bc_sptr_length(self)

    def beta(self):
        """
        beta(cpmmod_bc_sptr self) -> double

        Return the value of beta for the modulator.
        """
        return _digital_swig.cpmmod_bc_sptr_beta(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(cpmmod_bc_sptr self, basic_block_sptr block)
        primitive_connect(cpmmod_bc_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.cpmmod_bc_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(cpmmod_bc_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(cpmmod_bc_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.cpmmod_bc_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(cpmmod_bc_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(cpmmod_bc_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.cpmmod_bc_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(cpmmod_bc_sptr self, basic_block_sptr block)
        primitive_disconnect(cpmmod_bc_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.cpmmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(cpmmod_bc_sptr self)"""
        return _digital_swig.cpmmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(cpmmod_bc_sptr self)"""
        return _digital_swig.cpmmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(cpmmod_bc_sptr self)"""
        return _digital_swig.cpmmod_bc_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(cpmmod_bc_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.cpmmod_bc_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(cpmmod_bc_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.cpmmod_bc_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(cpmmod_bc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.cpmmod_bc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(cpmmod_bc_sptr self)"""
        return _digital_swig.cpmmod_bc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(cpmmod_bc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.cpmmod_bc_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(cpmmod_bc_sptr self) -> hier_block2_sptr"""
        return _digital_swig.cpmmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(cpmmod_bc_sptr self) -> std::string"""
        return _digital_swig.cpmmod_bc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(cpmmod_bc_sptr self) -> std::string"""
        return _digital_swig.cpmmod_bc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(cpmmod_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.cpmmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(cpmmod_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.cpmmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(cpmmod_bc_sptr self) -> long"""
        return _digital_swig.cpmmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(cpmmod_bc_sptr self) -> basic_block_sptr"""
        return _digital_swig.cpmmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(cpmmod_bc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.cpmmod_bc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(cpmmod_bc_sptr self) -> std::string"""
        return _digital_swig.cpmmod_bc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(cpmmod_bc_sptr self, std::string name)"""
        return _digital_swig.cpmmod_bc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(cpmmod_bc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.cpmmod_bc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(cpmmod_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.cpmmod_bc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(cpmmod_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.cpmmod_bc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(cpmmod_bc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.cpmmod_bc_sptr_message_subscribers(self, *args, **kwargs)

cpmmod_bc_sptr_swigregister = _digital_swig.cpmmod_bc_sptr_swigregister
cpmmod_bc_sptr_swigregister(cpmmod_bc_sptr)

cpmmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
cpmmod_bc = cpmmod_bc.make;

class descrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::descrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::descrambler_bb)> self) -> descrambler_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::descrambler_bb)> self, descrambler_bb p) -> descrambler_bb_sptr
        """
        this = _digital_swig.new_descrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(descrambler_bb_sptr self) -> descrambler_bb"""
        return _digital_swig.descrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_descrambler_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(descrambler_bb_sptr self, int mask, int seed, int len) -> descrambler_bb_sptr

        Descramber an input stream using an LFSR.

        Descramble an input stream using an LFSR. This block works on the LSB only of the input data stream, i.e., on an "unpacked
        binary" stream, and produces the same format on its output.

        Constructor Specific Documentation:

        Make a descrambler block.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
        """
        return _digital_swig.descrambler_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(descrambler_bb_sptr self) -> unsigned int"""
        return _digital_swig.descrambler_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(descrambler_bb_sptr self, int which, int delay)
        declare_sample_delay(descrambler_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.descrambler_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(descrambler_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.descrambler_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(descrambler_bb_sptr self) -> int"""
        return _digital_swig.descrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(descrambler_bb_sptr self) -> double"""
        return _digital_swig.descrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(descrambler_bb_sptr self) -> bool"""
        return _digital_swig.descrambler_bb_sptr_start(self)

    def stop(self):
        """stop(descrambler_bb_sptr self) -> bool"""
        return _digital_swig.descrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(descrambler_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.descrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(descrambler_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.descrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(descrambler_bb_sptr self) -> int"""
        return _digital_swig.descrambler_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(descrambler_bb_sptr self, int m)"""
        return _digital_swig.descrambler_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(descrambler_bb_sptr self)"""
        return _digital_swig.descrambler_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(descrambler_bb_sptr self) -> bool"""
        return _digital_swig.descrambler_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(descrambler_bb_sptr self, int m)"""
        return _digital_swig.descrambler_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(descrambler_bb_sptr self) -> int"""
        return _digital_swig.descrambler_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(descrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.descrambler_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(descrambler_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(descrambler_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.descrambler_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(descrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.descrambler_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(descrambler_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(descrambler_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.descrambler_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(descrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(descrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(descrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(descrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(descrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(descrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(descrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.descrambler_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(descrambler_bb_sptr self) -> float"""
        return _digital_swig.descrambler_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(descrambler_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.descrambler_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(descrambler_bb_sptr self)"""
        return _digital_swig.descrambler_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(descrambler_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.descrambler_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(descrambler_bb_sptr self) -> int"""
        return _digital_swig.descrambler_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(descrambler_bb_sptr self) -> int"""
        return _digital_swig.descrambler_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(descrambler_bb_sptr self, int priority) -> int"""
        return _digital_swig.descrambler_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(descrambler_bb_sptr self) -> std::string"""
        return _digital_swig.descrambler_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(descrambler_bb_sptr self) -> std::string"""
        return _digital_swig.descrambler_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(descrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.descrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(descrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.descrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(descrambler_bb_sptr self) -> long"""
        return _digital_swig.descrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(descrambler_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.descrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(descrambler_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.descrambler_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(descrambler_bb_sptr self) -> std::string"""
        return _digital_swig.descrambler_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(descrambler_bb_sptr self, std::string name)"""
        return _digital_swig.descrambler_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(descrambler_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.descrambler_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(descrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.descrambler_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(descrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.descrambler_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(descrambler_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.descrambler_bb_sptr_message_subscribers(self, *args, **kwargs)

descrambler_bb_sptr_swigregister = _digital_swig.descrambler_bb_sptr_swigregister
descrambler_bb_sptr_swigregister(descrambler_bb_sptr)

descrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
descrambler_bb = descrambler_bb.make;

class diff_decoder_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::diff_decoder_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::diff_decoder_bb)> self) -> diff_decoder_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::diff_decoder_bb)> self, diff_decoder_bb p) -> diff_decoder_bb_sptr
        """
        this = _digital_swig.new_diff_decoder_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(diff_decoder_bb_sptr self) -> diff_decoder_bb"""
        return _digital_swig.diff_decoder_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_diff_decoder_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(diff_decoder_bb_sptr self, unsigned int modulus) -> diff_decoder_bb_sptr

        Differential encoder: y[0] = (x[0] - x[-1]) % M.

        Uses current and previous symbols and the alphabet modulus to perform differential decoding.

        Constructor Specific Documentation:

        Make a differntial decoder block.

        Args:
            modulus : Modulus of code's alphabet
        """
        return _digital_swig.diff_decoder_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(diff_decoder_bb_sptr self) -> unsigned int"""
        return _digital_swig.diff_decoder_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(diff_decoder_bb_sptr self, int which, int delay)
        declare_sample_delay(diff_decoder_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.diff_decoder_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(diff_decoder_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.diff_decoder_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(diff_decoder_bb_sptr self) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(diff_decoder_bb_sptr self) -> double"""
        return _digital_swig.diff_decoder_bb_sptr_relative_rate(self)

    def start(self):
        """start(diff_decoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_decoder_bb_sptr_start(self)

    def stop(self):
        """stop(diff_decoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_decoder_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(diff_decoder_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.diff_decoder_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(diff_decoder_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.diff_decoder_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(diff_decoder_bb_sptr self) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(diff_decoder_bb_sptr self, int m)"""
        return _digital_swig.diff_decoder_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(diff_decoder_bb_sptr self)"""
        return _digital_swig.diff_decoder_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(diff_decoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_decoder_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(diff_decoder_bb_sptr self, int m)"""
        return _digital_swig.diff_decoder_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(diff_decoder_bb_sptr self) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(diff_decoder_bb_sptr self, int i) -> long"""
        return _digital_swig.diff_decoder_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(diff_decoder_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(diff_decoder_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.diff_decoder_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(diff_decoder_bb_sptr self, int i) -> long"""
        return _digital_swig.diff_decoder_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(diff_decoder_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(diff_decoder_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.diff_decoder_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(diff_decoder_bb_sptr self, int which) -> float
        pc_input_buffers_full(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(diff_decoder_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(diff_decoder_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(diff_decoder_bb_sptr self, int which) -> float
        pc_output_buffers_full(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(diff_decoder_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(diff_decoder_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(diff_decoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_decoder_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(diff_decoder_bb_sptr self) -> float"""
        return _digital_swig.diff_decoder_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(diff_decoder_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.diff_decoder_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(diff_decoder_bb_sptr self)"""
        return _digital_swig.diff_decoder_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(diff_decoder_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.diff_decoder_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(diff_decoder_bb_sptr self) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(diff_decoder_bb_sptr self) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(diff_decoder_bb_sptr self, int priority) -> int"""
        return _digital_swig.diff_decoder_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(diff_decoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_decoder_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(diff_decoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_decoder_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(diff_decoder_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_decoder_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(diff_decoder_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_decoder_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(diff_decoder_bb_sptr self) -> long"""
        return _digital_swig.diff_decoder_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(diff_decoder_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.diff_decoder_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(diff_decoder_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.diff_decoder_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(diff_decoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_decoder_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(diff_decoder_bb_sptr self, std::string name)"""
        return _digital_swig.diff_decoder_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(diff_decoder_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.diff_decoder_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(diff_decoder_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_decoder_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(diff_decoder_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_decoder_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(diff_decoder_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.diff_decoder_bb_sptr_message_subscribers(self, *args, **kwargs)

diff_decoder_bb_sptr_swigregister = _digital_swig.diff_decoder_bb_sptr_swigregister
diff_decoder_bb_sptr_swigregister(diff_decoder_bb_sptr)

diff_decoder_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
diff_decoder_bb = diff_decoder_bb.make;

class diff_encoder_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::diff_encoder_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::diff_encoder_bb)> self) -> diff_encoder_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::diff_encoder_bb)> self, diff_encoder_bb p) -> diff_encoder_bb_sptr
        """
        this = _digital_swig.new_diff_encoder_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(diff_encoder_bb_sptr self) -> diff_encoder_bb"""
        return _digital_swig.diff_encoder_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_diff_encoder_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(diff_encoder_bb_sptr self, unsigned int modulus) -> diff_encoder_bb_sptr

        Differential decoder: y[0] = (x[0] + y[-1]) % M.

        Uses current and previous symbols and the alphabet modulus to perform differential encoding.

        Constructor Specific Documentation:

        Make a differntial encoder block.

        Args:
            modulus : Modulus of code's alphabet
        """
        return _digital_swig.diff_encoder_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(diff_encoder_bb_sptr self) -> unsigned int"""
        return _digital_swig.diff_encoder_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(diff_encoder_bb_sptr self, int which, int delay)
        declare_sample_delay(diff_encoder_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.diff_encoder_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(diff_encoder_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.diff_encoder_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(diff_encoder_bb_sptr self) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(diff_encoder_bb_sptr self) -> double"""
        return _digital_swig.diff_encoder_bb_sptr_relative_rate(self)

    def start(self):
        """start(diff_encoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_encoder_bb_sptr_start(self)

    def stop(self):
        """stop(diff_encoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_encoder_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(diff_encoder_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.diff_encoder_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(diff_encoder_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.diff_encoder_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(diff_encoder_bb_sptr self) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(diff_encoder_bb_sptr self, int m)"""
        return _digital_swig.diff_encoder_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(diff_encoder_bb_sptr self)"""
        return _digital_swig.diff_encoder_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(diff_encoder_bb_sptr self) -> bool"""
        return _digital_swig.diff_encoder_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(diff_encoder_bb_sptr self, int m)"""
        return _digital_swig.diff_encoder_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(diff_encoder_bb_sptr self) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(diff_encoder_bb_sptr self, int i) -> long"""
        return _digital_swig.diff_encoder_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(diff_encoder_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(diff_encoder_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.diff_encoder_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(diff_encoder_bb_sptr self, int i) -> long"""
        return _digital_swig.diff_encoder_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(diff_encoder_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(diff_encoder_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.diff_encoder_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(diff_encoder_bb_sptr self, int which) -> float
        pc_input_buffers_full(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(diff_encoder_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(diff_encoder_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(diff_encoder_bb_sptr self, int which) -> float
        pc_output_buffers_full(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(diff_encoder_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(diff_encoder_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(diff_encoder_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_encoder_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(diff_encoder_bb_sptr self) -> float"""
        return _digital_swig.diff_encoder_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(diff_encoder_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.diff_encoder_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(diff_encoder_bb_sptr self)"""
        return _digital_swig.diff_encoder_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(diff_encoder_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.diff_encoder_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(diff_encoder_bb_sptr self) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(diff_encoder_bb_sptr self) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(diff_encoder_bb_sptr self, int priority) -> int"""
        return _digital_swig.diff_encoder_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(diff_encoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_encoder_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(diff_encoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_encoder_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(diff_encoder_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_encoder_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(diff_encoder_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_encoder_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(diff_encoder_bb_sptr self) -> long"""
        return _digital_swig.diff_encoder_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(diff_encoder_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.diff_encoder_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(diff_encoder_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.diff_encoder_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(diff_encoder_bb_sptr self) -> std::string"""
        return _digital_swig.diff_encoder_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(diff_encoder_bb_sptr self, std::string name)"""
        return _digital_swig.diff_encoder_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(diff_encoder_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.diff_encoder_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(diff_encoder_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_encoder_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(diff_encoder_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_encoder_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(diff_encoder_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.diff_encoder_bb_sptr_message_subscribers(self, *args, **kwargs)

diff_encoder_bb_sptr_swigregister = _digital_swig.diff_encoder_bb_sptr_swigregister
diff_encoder_bb_sptr_swigregister(diff_encoder_bb_sptr)

diff_encoder_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
diff_encoder_bb = diff_encoder_bb.make;

class diff_phasor_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::diff_phasor_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::diff_phasor_cc)> self) -> diff_phasor_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::diff_phasor_cc)> self, diff_phasor_cc p) -> diff_phasor_cc_sptr
        """
        this = _digital_swig.new_diff_phasor_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(diff_phasor_cc_sptr self) -> diff_phasor_cc"""
        return _digital_swig.diff_phasor_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_diff_phasor_cc_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(diff_phasor_cc_sptr self) -> diff_phasor_cc_sptr

        Differential decoding based on phase change.

        Uses the phase difference between two symbols to determine the output symbol:

        Constructor Specific Documentation:

        Make a differential phasor decoding block.
        """
        return _digital_swig.diff_phasor_cc_sptr_make(self)

    def history(self):
        """history(diff_phasor_cc_sptr self) -> unsigned int"""
        return _digital_swig.diff_phasor_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(diff_phasor_cc_sptr self, int which, int delay)
        declare_sample_delay(diff_phasor_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.diff_phasor_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(diff_phasor_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.diff_phasor_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(diff_phasor_cc_sptr self) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(diff_phasor_cc_sptr self) -> double"""
        return _digital_swig.diff_phasor_cc_sptr_relative_rate(self)

    def start(self):
        """start(diff_phasor_cc_sptr self) -> bool"""
        return _digital_swig.diff_phasor_cc_sptr_start(self)

    def stop(self):
        """stop(diff_phasor_cc_sptr self) -> bool"""
        return _digital_swig.diff_phasor_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(diff_phasor_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.diff_phasor_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(diff_phasor_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.diff_phasor_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(diff_phasor_cc_sptr self) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(diff_phasor_cc_sptr self, int m)"""
        return _digital_swig.diff_phasor_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(diff_phasor_cc_sptr self)"""
        return _digital_swig.diff_phasor_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(diff_phasor_cc_sptr self) -> bool"""
        return _digital_swig.diff_phasor_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(diff_phasor_cc_sptr self, int m)"""
        return _digital_swig.diff_phasor_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(diff_phasor_cc_sptr self) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(diff_phasor_cc_sptr self, int i) -> long"""
        return _digital_swig.diff_phasor_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(diff_phasor_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(diff_phasor_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.diff_phasor_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(diff_phasor_cc_sptr self, int i) -> long"""
        return _digital_swig.diff_phasor_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(diff_phasor_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(diff_phasor_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.diff_phasor_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(diff_phasor_cc_sptr self, int which) -> float
        pc_input_buffers_full(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(diff_phasor_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(diff_phasor_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(diff_phasor_cc_sptr self, int which) -> float
        pc_output_buffers_full(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(diff_phasor_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(diff_phasor_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(diff_phasor_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.diff_phasor_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(diff_phasor_cc_sptr self) -> float"""
        return _digital_swig.diff_phasor_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(diff_phasor_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.diff_phasor_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(diff_phasor_cc_sptr self)"""
        return _digital_swig.diff_phasor_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(diff_phasor_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.diff_phasor_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(diff_phasor_cc_sptr self) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(diff_phasor_cc_sptr self) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(diff_phasor_cc_sptr self, int priority) -> int"""
        return _digital_swig.diff_phasor_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(diff_phasor_cc_sptr self) -> std::string"""
        return _digital_swig.diff_phasor_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(diff_phasor_cc_sptr self) -> std::string"""
        return _digital_swig.diff_phasor_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(diff_phasor_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_phasor_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(diff_phasor_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.diff_phasor_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(diff_phasor_cc_sptr self) -> long"""
        return _digital_swig.diff_phasor_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(diff_phasor_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.diff_phasor_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(diff_phasor_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.diff_phasor_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(diff_phasor_cc_sptr self) -> std::string"""
        return _digital_swig.diff_phasor_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(diff_phasor_cc_sptr self, std::string name)"""
        return _digital_swig.diff_phasor_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(diff_phasor_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.diff_phasor_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(diff_phasor_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_phasor_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(diff_phasor_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.diff_phasor_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(diff_phasor_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.diff_phasor_cc_sptr_message_subscribers(self, *args, **kwargs)

diff_phasor_cc_sptr_swigregister = _digital_swig.diff_phasor_cc_sptr_swigregister
diff_phasor_cc_sptr_swigregister(diff_phasor_cc_sptr)

diff_phasor_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
diff_phasor_cc = diff_phasor_cc.make;

class fll_band_edge_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::fll_band_edge_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::fll_band_edge_cc)> self) -> fll_band_edge_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::fll_band_edge_cc)> self, fll_band_edge_cc p) -> fll_band_edge_cc_sptr
        """
        this = _digital_swig.new_fll_band_edge_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fll_band_edge_cc_sptr self) -> fll_band_edge_cc"""
        return _digital_swig.fll_band_edge_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_fll_band_edge_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(fll_band_edge_cc_sptr self, float samps_per_sym, float rolloff, int filter_size, float bandwidth) -> fll_band_edge_cc_sptr

        Frequency Lock Loop using band-edge filters.

        The frequency lock loop derives a band-edge filter that covers the upper and lower bandwidths of a digitally-modulated signal. The bandwidth range is determined by the excess bandwidth (e.g., rolloff factor) of the modulated signal. The placement in frequency of the band-edges is determined by the oversampling ratio (number of samples per symbol) and the excess bandwidth. The size of the filters should be fairly large so as to average over a number of symbols.

        The FLL works by filtering the upper and lower band edges into x_u(t) and x_l(t), respectively. These are combined to form cc(t) = x_u(t) + x_l(t) and ss(t) = x_u(t) - x_l(t). Combining these to form the signal e(t) = Re{cc(t) 	imes ss(t)^*} (where ^* is the complex conjugate) provides an error signal at the DC term that is directly proportional to the carrier frequency. We then make a second-order loop using the error signal that is the running average of e(t).

        In practice, the above equation can be simplified by just comparing the absolute value squared of the output of both filters: abs(x_l(t))^2 - abs(x_u(t))^2 = norm(x_l(t)) - norm(x_u(t)).

        In theory, the band-edge filter is the derivative of the matched filter in frequency, (H_be(f) = frac{H(f)}{df}). In practice, this comes down to a quarter sine wave at the point of the matched filter's rolloff (if it's a raised-cosine, the derivative of a cosine is a sine). Extend this sine by another quarter wave to make a half wave around the band-edges is equivalent in time to the sum of two sinc functions. The baseband filter fot the band edges is therefore derived from this sum of sincs. The band edge filters are then just the baseband signal modulated to the correct place in frequency. All of these calculations are done in the 'design_filter' function.

        Note: We use FIR filters here because the filters have to have a flat phase response over the entire frequency range to allow their comparisons to be valid.

        It is very important that the band edge filters be the derivatives of the pulse shaping filter, and that they be linear phase. Otherwise, the variance of the error will be very large.

        Constructor Specific Documentation:

        Make an FLL block.

        Args:
            samps_per_sym : (float) number of samples per symbol
            rolloff : (float) Rolloff (excess bandwidth) of signal filter
            filter_size : (int) number of filter taps to generate
            bandwidth : (float) Loop bandwidth
        """
        return _digital_swig.fll_band_edge_cc_sptr_make(self, *args, **kwargs)

    def set_samples_per_symbol(self, *args, **kwargs):
        """
        set_samples_per_symbol(fll_band_edge_cc_sptr self, float sps)

        Set the number of samples per symbol.

        Set's the number of samples per symbol the system should use. This value is uesd to calculate the filter taps and will force a recalculation.
        """
        return _digital_swig.fll_band_edge_cc_sptr_set_samples_per_symbol(self, *args, **kwargs)

    def set_rolloff(self, *args, **kwargs):
        """
        set_rolloff(fll_band_edge_cc_sptr self, float rolloff)

        Set the rolloff factor of the shaping filter.

        This sets the rolloff factor that is used in the pulse shaping filter and is used to calculate the filter taps. Changing this will force a recalculation of the filter taps.

        This should be the same value that is used in the transmitter's pulse shaping filter. It must be between 0 and 1 and is usually between 0.2 and 0.5 (where 0.22 and 0.35 are commonly used values).
        """
        return _digital_swig.fll_band_edge_cc_sptr_set_rolloff(self, *args, **kwargs)

    def set_filter_size(self, *args, **kwargs):
        """
        set_filter_size(fll_band_edge_cc_sptr self, int filter_size)

        Set the number of taps in the filter.

        This sets the number of taps in the band-edge filters. Setting this will force a recalculation of the filter taps.

        This should be about the same number of taps used in the transmitter's shaping filter and also not very large. A large number of taps will result in a large delay between input and frequency estimation, and so will not be as accurate. Between 30 and 70 taps is usual.
        """
        return _digital_swig.fll_band_edge_cc_sptr_set_filter_size(self, *args, **kwargs)

    def samples_per_symbol(self):
        """
        samples_per_symbol(fll_band_edge_cc_sptr self) -> float

        Returns the number of sampler per symbol used for the filter.
        """
        return _digital_swig.fll_band_edge_cc_sptr_samples_per_symbol(self)

    def rolloff(self):
        """
        rolloff(fll_band_edge_cc_sptr self) -> float

        Returns the rolloff factor used for the filter.
        """
        return _digital_swig.fll_band_edge_cc_sptr_rolloff(self)

    def filter_size(self):
        """
        filter_size(fll_band_edge_cc_sptr self) -> int

        Returns the number of taps of the filter.
        """
        return _digital_swig.fll_band_edge_cc_sptr_filter_size(self)

    def print_taps(self):
        """
        print_taps(fll_band_edge_cc_sptr self)

        Print the taps to screen.
        """
        return _digital_swig.fll_band_edge_cc_sptr_print_taps(self)

    def history(self):
        """history(fll_band_edge_cc_sptr self) -> unsigned int"""
        return _digital_swig.fll_band_edge_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(fll_band_edge_cc_sptr self, int which, int delay)
        declare_sample_delay(fll_band_edge_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.fll_band_edge_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(fll_band_edge_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.fll_band_edge_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(fll_band_edge_cc_sptr self) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(fll_band_edge_cc_sptr self) -> double"""
        return _digital_swig.fll_band_edge_cc_sptr_relative_rate(self)

    def start(self):
        """start(fll_band_edge_cc_sptr self) -> bool"""
        return _digital_swig.fll_band_edge_cc_sptr_start(self)

    def stop(self):
        """stop(fll_band_edge_cc_sptr self) -> bool"""
        return _digital_swig.fll_band_edge_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(fll_band_edge_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.fll_band_edge_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(fll_band_edge_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.fll_band_edge_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(fll_band_edge_cc_sptr self) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(fll_band_edge_cc_sptr self, int m)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(fll_band_edge_cc_sptr self)"""
        return _digital_swig.fll_band_edge_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(fll_band_edge_cc_sptr self) -> bool"""
        return _digital_swig.fll_band_edge_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(fll_band_edge_cc_sptr self, int m)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(fll_band_edge_cc_sptr self) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(fll_band_edge_cc_sptr self, int i) -> long"""
        return _digital_swig.fll_band_edge_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(fll_band_edge_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(fll_band_edge_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.fll_band_edge_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(fll_band_edge_cc_sptr self, int i) -> long"""
        return _digital_swig.fll_band_edge_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(fll_band_edge_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(fll_band_edge_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.fll_band_edge_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(fll_band_edge_cc_sptr self, int which) -> float
        pc_input_buffers_full(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(fll_band_edge_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(fll_band_edge_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(fll_band_edge_cc_sptr self, int which) -> float
        pc_output_buffers_full(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(fll_band_edge_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(fll_band_edge_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(fll_band_edge_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.fll_band_edge_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(fll_band_edge_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(fll_band_edge_cc_sptr self)"""
        return _digital_swig.fll_band_edge_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(fll_band_edge_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.fll_band_edge_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(fll_band_edge_cc_sptr self) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(fll_band_edge_cc_sptr self) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(fll_band_edge_cc_sptr self, int priority) -> int"""
        return _digital_swig.fll_band_edge_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(fll_band_edge_cc_sptr self) -> std::string"""
        return _digital_swig.fll_band_edge_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(fll_band_edge_cc_sptr self) -> std::string"""
        return _digital_swig.fll_band_edge_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(fll_band_edge_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.fll_band_edge_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(fll_band_edge_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.fll_band_edge_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(fll_band_edge_cc_sptr self) -> long"""
        return _digital_swig.fll_band_edge_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(fll_band_edge_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.fll_band_edge_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(fll_band_edge_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.fll_band_edge_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(fll_band_edge_cc_sptr self) -> std::string"""
        return _digital_swig.fll_band_edge_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(fll_band_edge_cc_sptr self, std::string name)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(fll_band_edge_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.fll_band_edge_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(fll_band_edge_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.fll_band_edge_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(fll_band_edge_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.fll_band_edge_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(fll_band_edge_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.fll_band_edge_cc_sptr_message_subscribers(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(fll_band_edge_cc_sptr self)"""
        return _digital_swig.fll_band_edge_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(fll_band_edge_cc_sptr self, float error)"""
        return _digital_swig.fll_band_edge_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(fll_band_edge_cc_sptr self)"""
        return _digital_swig.fll_band_edge_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(fll_band_edge_cc_sptr self)"""
        return _digital_swig.fll_band_edge_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(fll_band_edge_cc_sptr self, float bw)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(fll_band_edge_cc_sptr self, float df)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(fll_band_edge_cc_sptr self, float alpha)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(fll_band_edge_cc_sptr self, float beta)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(fll_band_edge_cc_sptr self, float freq)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(fll_band_edge_cc_sptr self, float phase)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_phase(self, *args, **kwargs)

    def set_max_freq(self, *args, **kwargs):
        """set_max_freq(fll_band_edge_cc_sptr self, float freq)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_max_freq(self, *args, **kwargs)

    def set_min_freq(self, *args, **kwargs):
        """set_min_freq(fll_band_edge_cc_sptr self, float freq)"""
        return _digital_swig.fll_band_edge_cc_sptr_set_min_freq(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_phase(self)

    def get_max_freq(self):
        """get_max_freq(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_max_freq(self)

    def get_min_freq(self):
        """get_min_freq(fll_band_edge_cc_sptr self) -> float"""
        return _digital_swig.fll_band_edge_cc_sptr_get_min_freq(self)

fll_band_edge_cc_sptr_swigregister = _digital_swig.fll_band_edge_cc_sptr_swigregister
fll_band_edge_cc_sptr_swigregister(fll_band_edge_cc_sptr)

fll_band_edge_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
fll_band_edge_cc = fll_band_edge_cc.make;

class framer_sink_1_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::framer_sink_1)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::framer_sink_1)> self) -> framer_sink_1_sptr
        __init__(boost::shared_ptr<(gr::digital::framer_sink_1)> self, framer_sink_1 p) -> framer_sink_1_sptr
        """
        this = _digital_swig.new_framer_sink_1_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(framer_sink_1_sptr self) -> framer_sink_1"""
        return _digital_swig.framer_sink_1_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_framer_sink_1_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(framer_sink_1_sptr self, msg_queue_sptr target_queue) -> framer_sink_1_sptr

        Given a stream of bits and access_code flags, assemble packets.

        input: stream of bytes from digital_correlate_access_code_bb output: none. Pushes assembled packet into target queue

        The framer expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

        The input data consists of bytes that have two bits used. Bit 0, the LSB, contains the data bit. Bit 1 if set, indicates that the corresponding bit is the the first bit of the packet. That is, this bit is the first one after the access code.

        Constructor Specific Documentation:

        Make a framer_sink_1 block.

        Args:
            target_queue : The message queue where frames go.
        """
        return _digital_swig.framer_sink_1_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(framer_sink_1_sptr self) -> unsigned int"""
        return _digital_swig.framer_sink_1_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(framer_sink_1_sptr self, int which, int delay)
        declare_sample_delay(framer_sink_1_sptr self, unsigned int delay)
        """
        return _digital_swig.framer_sink_1_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(framer_sink_1_sptr self, int which) -> unsigned int"""
        return _digital_swig.framer_sink_1_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(framer_sink_1_sptr self) -> int"""
        return _digital_swig.framer_sink_1_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(framer_sink_1_sptr self) -> double"""
        return _digital_swig.framer_sink_1_sptr_relative_rate(self)

    def start(self):
        """start(framer_sink_1_sptr self) -> bool"""
        return _digital_swig.framer_sink_1_sptr_start(self)

    def stop(self):
        """stop(framer_sink_1_sptr self) -> bool"""
        return _digital_swig.framer_sink_1_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(framer_sink_1_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.framer_sink_1_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(framer_sink_1_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.framer_sink_1_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(framer_sink_1_sptr self) -> int"""
        return _digital_swig.framer_sink_1_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(framer_sink_1_sptr self, int m)"""
        return _digital_swig.framer_sink_1_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(framer_sink_1_sptr self)"""
        return _digital_swig.framer_sink_1_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(framer_sink_1_sptr self) -> bool"""
        return _digital_swig.framer_sink_1_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(framer_sink_1_sptr self, int m)"""
        return _digital_swig.framer_sink_1_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(framer_sink_1_sptr self) -> int"""
        return _digital_swig.framer_sink_1_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(framer_sink_1_sptr self, int i) -> long"""
        return _digital_swig.framer_sink_1_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(framer_sink_1_sptr self, long max_output_buffer)
        set_max_output_buffer(framer_sink_1_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.framer_sink_1_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(framer_sink_1_sptr self, int i) -> long"""
        return _digital_swig.framer_sink_1_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(framer_sink_1_sptr self, long min_output_buffer)
        set_min_output_buffer(framer_sink_1_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.framer_sink_1_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(framer_sink_1_sptr self, int which) -> float
        pc_input_buffers_full(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(framer_sink_1_sptr self, int which) -> float
        pc_input_buffers_full_avg(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(framer_sink_1_sptr self, int which) -> float
        pc_input_buffers_full_var(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(framer_sink_1_sptr self, int which) -> float
        pc_output_buffers_full(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(framer_sink_1_sptr self, int which) -> float
        pc_output_buffers_full_avg(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(framer_sink_1_sptr self, int which) -> float
        pc_output_buffers_full_var(framer_sink_1_sptr self) -> pmt_vector_float
        """
        return _digital_swig.framer_sink_1_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(framer_sink_1_sptr self) -> float"""
        return _digital_swig.framer_sink_1_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(framer_sink_1_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.framer_sink_1_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(framer_sink_1_sptr self)"""
        return _digital_swig.framer_sink_1_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(framer_sink_1_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.framer_sink_1_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(framer_sink_1_sptr self) -> int"""
        return _digital_swig.framer_sink_1_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(framer_sink_1_sptr self) -> int"""
        return _digital_swig.framer_sink_1_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(framer_sink_1_sptr self, int priority) -> int"""
        return _digital_swig.framer_sink_1_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(framer_sink_1_sptr self) -> std::string"""
        return _digital_swig.framer_sink_1_sptr_name(self)

    def symbol_name(self):
        """symbol_name(framer_sink_1_sptr self) -> std::string"""
        return _digital_swig.framer_sink_1_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(framer_sink_1_sptr self) -> io_signature_sptr"""
        return _digital_swig.framer_sink_1_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(framer_sink_1_sptr self) -> io_signature_sptr"""
        return _digital_swig.framer_sink_1_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(framer_sink_1_sptr self) -> long"""
        return _digital_swig.framer_sink_1_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(framer_sink_1_sptr self) -> basic_block_sptr"""
        return _digital_swig.framer_sink_1_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(framer_sink_1_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.framer_sink_1_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(framer_sink_1_sptr self) -> std::string"""
        return _digital_swig.framer_sink_1_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(framer_sink_1_sptr self, std::string name)"""
        return _digital_swig.framer_sink_1_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(framer_sink_1_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.framer_sink_1_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(framer_sink_1_sptr self) -> swig_int_ptr"""
        return _digital_swig.framer_sink_1_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(framer_sink_1_sptr self) -> swig_int_ptr"""
        return _digital_swig.framer_sink_1_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(framer_sink_1_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.framer_sink_1_sptr_message_subscribers(self, *args, **kwargs)

framer_sink_1_sptr_swigregister = _digital_swig.framer_sink_1_sptr_swigregister
framer_sink_1_sptr_swigregister(framer_sink_1_sptr)

framer_sink_1_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
framer_sink_1 = framer_sink_1.make;

class glfsr_source_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::glfsr_source_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::glfsr_source_b)> self) -> glfsr_source_b_sptr
        __init__(boost::shared_ptr<(gr::digital::glfsr_source_b)> self, glfsr_source_b p) -> glfsr_source_b_sptr
        """
        this = _digital_swig.new_glfsr_source_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(glfsr_source_b_sptr self) -> glfsr_source_b"""
        return _digital_swig.glfsr_source_b_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_glfsr_source_b_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(glfsr_source_b_sptr self, int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_b_sptr

        Galois LFSR pseudo-random source.

        Constructor Specific Documentation:

        Make a Galois LFSR pseudo-random source block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            repeat : Set to repeat sequence.
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.glfsr_source_b_sptr_make(self, *args, **kwargs)

    def period(self):
        """period(glfsr_source_b_sptr self) -> unsigned int"""
        return _digital_swig.glfsr_source_b_sptr_period(self)

    def mask(self):
        """mask(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_mask(self)

    def history(self):
        """history(glfsr_source_b_sptr self) -> unsigned int"""
        return _digital_swig.glfsr_source_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(glfsr_source_b_sptr self, int which, int delay)
        declare_sample_delay(glfsr_source_b_sptr self, unsigned int delay)
        """
        return _digital_swig.glfsr_source_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(glfsr_source_b_sptr self, int which) -> unsigned int"""
        return _digital_swig.glfsr_source_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(glfsr_source_b_sptr self) -> double"""
        return _digital_swig.glfsr_source_b_sptr_relative_rate(self)

    def start(self):
        """start(glfsr_source_b_sptr self) -> bool"""
        return _digital_swig.glfsr_source_b_sptr_start(self)

    def stop(self):
        """stop(glfsr_source_b_sptr self) -> bool"""
        return _digital_swig.glfsr_source_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(glfsr_source_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.glfsr_source_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(glfsr_source_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.glfsr_source_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(glfsr_source_b_sptr self, int m)"""
        return _digital_swig.glfsr_source_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(glfsr_source_b_sptr self)"""
        return _digital_swig.glfsr_source_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(glfsr_source_b_sptr self) -> bool"""
        return _digital_swig.glfsr_source_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(glfsr_source_b_sptr self, int m)"""
        return _digital_swig.glfsr_source_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(glfsr_source_b_sptr self, int i) -> long"""
        return _digital_swig.glfsr_source_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(glfsr_source_b_sptr self, long max_output_buffer)
        set_max_output_buffer(glfsr_source_b_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.glfsr_source_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(glfsr_source_b_sptr self, int i) -> long"""
        return _digital_swig.glfsr_source_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(glfsr_source_b_sptr self, long min_output_buffer)
        set_min_output_buffer(glfsr_source_b_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.glfsr_source_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(glfsr_source_b_sptr self, int which) -> float
        pc_input_buffers_full(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(glfsr_source_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(glfsr_source_b_sptr self, int which) -> float
        pc_input_buffers_full_var(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(glfsr_source_b_sptr self, int which) -> float
        pc_output_buffers_full(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(glfsr_source_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(glfsr_source_b_sptr self, int which) -> float
        pc_output_buffers_full_var(glfsr_source_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(glfsr_source_b_sptr self) -> float"""
        return _digital_swig.glfsr_source_b_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(glfsr_source_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.glfsr_source_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(glfsr_source_b_sptr self)"""
        return _digital_swig.glfsr_source_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(glfsr_source_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.glfsr_source_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(glfsr_source_b_sptr self) -> int"""
        return _digital_swig.glfsr_source_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(glfsr_source_b_sptr self, int priority) -> int"""
        return _digital_swig.glfsr_source_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(glfsr_source_b_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(glfsr_source_b_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(glfsr_source_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.glfsr_source_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(glfsr_source_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.glfsr_source_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(glfsr_source_b_sptr self) -> long"""
        return _digital_swig.glfsr_source_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(glfsr_source_b_sptr self) -> basic_block_sptr"""
        return _digital_swig.glfsr_source_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(glfsr_source_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.glfsr_source_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(glfsr_source_b_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(glfsr_source_b_sptr self, std::string name)"""
        return _digital_swig.glfsr_source_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(glfsr_source_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.glfsr_source_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(glfsr_source_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(glfsr_source_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(glfsr_source_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_b_sptr_message_subscribers(self, *args, **kwargs)

glfsr_source_b_sptr_swigregister = _digital_swig.glfsr_source_b_sptr_swigregister
glfsr_source_b_sptr_swigregister(glfsr_source_b_sptr)

glfsr_source_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
glfsr_source_b = glfsr_source_b.make;

class glfsr_source_f_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::glfsr_source_f)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::glfsr_source_f)> self) -> glfsr_source_f_sptr
        __init__(boost::shared_ptr<(gr::digital::glfsr_source_f)> self, glfsr_source_f p) -> glfsr_source_f_sptr
        """
        this = _digital_swig.new_glfsr_source_f_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(glfsr_source_f_sptr self) -> glfsr_source_f"""
        return _digital_swig.glfsr_source_f_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_glfsr_source_f_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(glfsr_source_f_sptr self, int degree, bool repeat=True, int mask=0, int seed=1) -> glfsr_source_f_sptr

        Galois LFSR pseudo-random source generating float outputs -1.0 - 1.0.

        Constructor Specific Documentation:

        Make a Galois LFSR pseudo-random source block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            repeat : Set to repeat sequence.
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.glfsr_source_f_sptr_make(self, *args, **kwargs)

    def period(self):
        """period(glfsr_source_f_sptr self) -> unsigned int"""
        return _digital_swig.glfsr_source_f_sptr_period(self)

    def mask(self):
        """mask(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_mask(self)

    def history(self):
        """history(glfsr_source_f_sptr self) -> unsigned int"""
        return _digital_swig.glfsr_source_f_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(glfsr_source_f_sptr self, int which, int delay)
        declare_sample_delay(glfsr_source_f_sptr self, unsigned int delay)
        """
        return _digital_swig.glfsr_source_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(glfsr_source_f_sptr self, int which) -> unsigned int"""
        return _digital_swig.glfsr_source_f_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(glfsr_source_f_sptr self) -> double"""
        return _digital_swig.glfsr_source_f_sptr_relative_rate(self)

    def start(self):
        """start(glfsr_source_f_sptr self) -> bool"""
        return _digital_swig.glfsr_source_f_sptr_start(self)

    def stop(self):
        """stop(glfsr_source_f_sptr self) -> bool"""
        return _digital_swig.glfsr_source_f_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(glfsr_source_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.glfsr_source_f_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(glfsr_source_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.glfsr_source_f_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(glfsr_source_f_sptr self, int m)"""
        return _digital_swig.glfsr_source_f_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(glfsr_source_f_sptr self)"""
        return _digital_swig.glfsr_source_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(glfsr_source_f_sptr self) -> bool"""
        return _digital_swig.glfsr_source_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(glfsr_source_f_sptr self, int m)"""
        return _digital_swig.glfsr_source_f_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(glfsr_source_f_sptr self, int i) -> long"""
        return _digital_swig.glfsr_source_f_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(glfsr_source_f_sptr self, long max_output_buffer)
        set_max_output_buffer(glfsr_source_f_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.glfsr_source_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(glfsr_source_f_sptr self, int i) -> long"""
        return _digital_swig.glfsr_source_f_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(glfsr_source_f_sptr self, long min_output_buffer)
        set_min_output_buffer(glfsr_source_f_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.glfsr_source_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(glfsr_source_f_sptr self, int which) -> float
        pc_input_buffers_full(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(glfsr_source_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(glfsr_source_f_sptr self, int which) -> float
        pc_input_buffers_full_var(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(glfsr_source_f_sptr self, int which) -> float
        pc_output_buffers_full(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(glfsr_source_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(glfsr_source_f_sptr self, int which) -> float
        pc_output_buffers_full_var(glfsr_source_f_sptr self) -> pmt_vector_float
        """
        return _digital_swig.glfsr_source_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(glfsr_source_f_sptr self) -> float"""
        return _digital_swig.glfsr_source_f_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(glfsr_source_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.glfsr_source_f_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(glfsr_source_f_sptr self)"""
        return _digital_swig.glfsr_source_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(glfsr_source_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.glfsr_source_f_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(glfsr_source_f_sptr self) -> int"""
        return _digital_swig.glfsr_source_f_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(glfsr_source_f_sptr self, int priority) -> int"""
        return _digital_swig.glfsr_source_f_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(glfsr_source_f_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_f_sptr_name(self)

    def symbol_name(self):
        """symbol_name(glfsr_source_f_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_f_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(glfsr_source_f_sptr self) -> io_signature_sptr"""
        return _digital_swig.glfsr_source_f_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(glfsr_source_f_sptr self) -> io_signature_sptr"""
        return _digital_swig.glfsr_source_f_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(glfsr_source_f_sptr self) -> long"""
        return _digital_swig.glfsr_source_f_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(glfsr_source_f_sptr self) -> basic_block_sptr"""
        return _digital_swig.glfsr_source_f_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(glfsr_source_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.glfsr_source_f_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(glfsr_source_f_sptr self) -> std::string"""
        return _digital_swig.glfsr_source_f_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(glfsr_source_f_sptr self, std::string name)"""
        return _digital_swig.glfsr_source_f_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(glfsr_source_f_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.glfsr_source_f_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(glfsr_source_f_sptr self) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_f_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(glfsr_source_f_sptr self) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_f_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(glfsr_source_f_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.glfsr_source_f_sptr_message_subscribers(self, *args, **kwargs)

glfsr_source_f_sptr_swigregister = _digital_swig.glfsr_source_f_sptr_swigregister
glfsr_source_f_sptr_swigregister(glfsr_source_f_sptr)

glfsr_source_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
glfsr_source_f = glfsr_source_f.make;

class hdlc_deframer_bp_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::hdlc_deframer_bp)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::hdlc_deframer_bp)> self) -> hdlc_deframer_bp_sptr
        __init__(boost::shared_ptr<(gr::digital::hdlc_deframer_bp)> self, hdlc_deframer_bp p) -> hdlc_deframer_bp_sptr
        """
        this = _digital_swig.new_hdlc_deframer_bp_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(hdlc_deframer_bp_sptr self) -> hdlc_deframer_bp"""
        return _digital_swig.hdlc_deframer_bp_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_hdlc_deframer_bp_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(hdlc_deframer_bp_sptr self, int length_min, int length_max) -> hdlc_deframer_bp_sptr

        HDLC deframer which takes in unpacked bits, and outputs PDU binary blobs. Frames which do not pass CRC are rejected.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of digital::hdlc_deframer.

        Args:
            length_min : Minimum frame size (default: 32)
            length_max : Maximum frame size (default: 500)
        """
        return _digital_swig.hdlc_deframer_bp_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(hdlc_deframer_bp_sptr self) -> unsigned int"""
        return _digital_swig.hdlc_deframer_bp_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(hdlc_deframer_bp_sptr self, int which, int delay)
        declare_sample_delay(hdlc_deframer_bp_sptr self, unsigned int delay)
        """
        return _digital_swig.hdlc_deframer_bp_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(hdlc_deframer_bp_sptr self, int which) -> unsigned int"""
        return _digital_swig.hdlc_deframer_bp_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(hdlc_deframer_bp_sptr self) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(hdlc_deframer_bp_sptr self) -> double"""
        return _digital_swig.hdlc_deframer_bp_sptr_relative_rate(self)

    def start(self):
        """start(hdlc_deframer_bp_sptr self) -> bool"""
        return _digital_swig.hdlc_deframer_bp_sptr_start(self)

    def stop(self):
        """stop(hdlc_deframer_bp_sptr self) -> bool"""
        return _digital_swig.hdlc_deframer_bp_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(hdlc_deframer_bp_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.hdlc_deframer_bp_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(hdlc_deframer_bp_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.hdlc_deframer_bp_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(hdlc_deframer_bp_sptr self) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(hdlc_deframer_bp_sptr self, int m)"""
        return _digital_swig.hdlc_deframer_bp_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(hdlc_deframer_bp_sptr self)"""
        return _digital_swig.hdlc_deframer_bp_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(hdlc_deframer_bp_sptr self) -> bool"""
        return _digital_swig.hdlc_deframer_bp_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(hdlc_deframer_bp_sptr self, int m)"""
        return _digital_swig.hdlc_deframer_bp_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(hdlc_deframer_bp_sptr self) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(hdlc_deframer_bp_sptr self, int i) -> long"""
        return _digital_swig.hdlc_deframer_bp_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(hdlc_deframer_bp_sptr self, long max_output_buffer)
        set_max_output_buffer(hdlc_deframer_bp_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.hdlc_deframer_bp_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(hdlc_deframer_bp_sptr self, int i) -> long"""
        return _digital_swig.hdlc_deframer_bp_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(hdlc_deframer_bp_sptr self, long min_output_buffer)
        set_min_output_buffer(hdlc_deframer_bp_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.hdlc_deframer_bp_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(hdlc_deframer_bp_sptr self, int which) -> float
        pc_input_buffers_full(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(hdlc_deframer_bp_sptr self, int which) -> float
        pc_input_buffers_full_avg(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(hdlc_deframer_bp_sptr self, int which) -> float
        pc_input_buffers_full_var(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(hdlc_deframer_bp_sptr self, int which) -> float
        pc_output_buffers_full(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(hdlc_deframer_bp_sptr self, int which) -> float
        pc_output_buffers_full_avg(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(hdlc_deframer_bp_sptr self, int which) -> float
        pc_output_buffers_full_var(hdlc_deframer_bp_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_deframer_bp_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(hdlc_deframer_bp_sptr self) -> float"""
        return _digital_swig.hdlc_deframer_bp_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(hdlc_deframer_bp_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.hdlc_deframer_bp_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(hdlc_deframer_bp_sptr self)"""
        return _digital_swig.hdlc_deframer_bp_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(hdlc_deframer_bp_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.hdlc_deframer_bp_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(hdlc_deframer_bp_sptr self) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(hdlc_deframer_bp_sptr self) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(hdlc_deframer_bp_sptr self, int priority) -> int"""
        return _digital_swig.hdlc_deframer_bp_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(hdlc_deframer_bp_sptr self) -> std::string"""
        return _digital_swig.hdlc_deframer_bp_sptr_name(self)

    def symbol_name(self):
        """symbol_name(hdlc_deframer_bp_sptr self) -> std::string"""
        return _digital_swig.hdlc_deframer_bp_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(hdlc_deframer_bp_sptr self) -> io_signature_sptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(hdlc_deframer_bp_sptr self) -> io_signature_sptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(hdlc_deframer_bp_sptr self) -> long"""
        return _digital_swig.hdlc_deframer_bp_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(hdlc_deframer_bp_sptr self) -> basic_block_sptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(hdlc_deframer_bp_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.hdlc_deframer_bp_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(hdlc_deframer_bp_sptr self) -> std::string"""
        return _digital_swig.hdlc_deframer_bp_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(hdlc_deframer_bp_sptr self, std::string name)"""
        return _digital_swig.hdlc_deframer_bp_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(hdlc_deframer_bp_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.hdlc_deframer_bp_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(hdlc_deframer_bp_sptr self) -> swig_int_ptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(hdlc_deframer_bp_sptr self) -> swig_int_ptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(hdlc_deframer_bp_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.hdlc_deframer_bp_sptr_message_subscribers(self, *args, **kwargs)

hdlc_deframer_bp_sptr_swigregister = _digital_swig.hdlc_deframer_bp_sptr_swigregister
hdlc_deframer_bp_sptr_swigregister(hdlc_deframer_bp_sptr)

hdlc_deframer_bp_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
hdlc_deframer_bp = hdlc_deframer_bp.make;

class hdlc_framer_pb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::hdlc_framer_pb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::hdlc_framer_pb)> self) -> hdlc_framer_pb_sptr
        __init__(boost::shared_ptr<(gr::digital::hdlc_framer_pb)> self, hdlc_framer_pb p) -> hdlc_framer_pb_sptr
        """
        this = _digital_swig.new_hdlc_framer_pb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(hdlc_framer_pb_sptr self) -> hdlc_framer_pb"""
        return _digital_swig.hdlc_framer_pb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_hdlc_framer_pb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(hdlc_framer_pb_sptr self, std::string const frame_tag_name) -> hdlc_framer_pb_sptr

        HDLC framer which takes in PMT binary blobs and outputs HDLC frames as unpacked bits, with CRC and bit stuffing added. The first sample of the frame is tagged with the tag frame_tag_name and includes a length field for tagged_stream use.

        This block outputs one whole frame at a time; if there is not enough output buffer space to fit a frame, it is pushed onto a queue. As a result flowgraphs which only run for a finite number of samples may not receive all frames in the queue, due to the scheduler's granularity. For flowgraphs that stream continuously (anything using a USRP) this should not be an issue.

        Constructor Specific Documentation:

        Return a shared_ptr to a new instance of digital::hdlc_framer.

        Args:
            frame_tag_name : The tag to add to the first sample of each frame.
        """
        return _digital_swig.hdlc_framer_pb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(hdlc_framer_pb_sptr self) -> unsigned int"""
        return _digital_swig.hdlc_framer_pb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(hdlc_framer_pb_sptr self, int which, int delay)
        declare_sample_delay(hdlc_framer_pb_sptr self, unsigned int delay)
        """
        return _digital_swig.hdlc_framer_pb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(hdlc_framer_pb_sptr self, int which) -> unsigned int"""
        return _digital_swig.hdlc_framer_pb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(hdlc_framer_pb_sptr self) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(hdlc_framer_pb_sptr self) -> double"""
        return _digital_swig.hdlc_framer_pb_sptr_relative_rate(self)

    def start(self):
        """start(hdlc_framer_pb_sptr self) -> bool"""
        return _digital_swig.hdlc_framer_pb_sptr_start(self)

    def stop(self):
        """stop(hdlc_framer_pb_sptr self) -> bool"""
        return _digital_swig.hdlc_framer_pb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(hdlc_framer_pb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.hdlc_framer_pb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(hdlc_framer_pb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.hdlc_framer_pb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(hdlc_framer_pb_sptr self) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(hdlc_framer_pb_sptr self, int m)"""
        return _digital_swig.hdlc_framer_pb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(hdlc_framer_pb_sptr self)"""
        return _digital_swig.hdlc_framer_pb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(hdlc_framer_pb_sptr self) -> bool"""
        return _digital_swig.hdlc_framer_pb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(hdlc_framer_pb_sptr self, int m)"""
        return _digital_swig.hdlc_framer_pb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(hdlc_framer_pb_sptr self) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(hdlc_framer_pb_sptr self, int i) -> long"""
        return _digital_swig.hdlc_framer_pb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(hdlc_framer_pb_sptr self, long max_output_buffer)
        set_max_output_buffer(hdlc_framer_pb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.hdlc_framer_pb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(hdlc_framer_pb_sptr self, int i) -> long"""
        return _digital_swig.hdlc_framer_pb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(hdlc_framer_pb_sptr self, long min_output_buffer)
        set_min_output_buffer(hdlc_framer_pb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.hdlc_framer_pb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(hdlc_framer_pb_sptr self, int which) -> float
        pc_input_buffers_full(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(hdlc_framer_pb_sptr self, int which) -> float
        pc_input_buffers_full_avg(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(hdlc_framer_pb_sptr self, int which) -> float
        pc_input_buffers_full_var(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(hdlc_framer_pb_sptr self, int which) -> float
        pc_output_buffers_full(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(hdlc_framer_pb_sptr self, int which) -> float
        pc_output_buffers_full_avg(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(hdlc_framer_pb_sptr self, int which) -> float
        pc_output_buffers_full_var(hdlc_framer_pb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.hdlc_framer_pb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(hdlc_framer_pb_sptr self) -> float"""
        return _digital_swig.hdlc_framer_pb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(hdlc_framer_pb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.hdlc_framer_pb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(hdlc_framer_pb_sptr self)"""
        return _digital_swig.hdlc_framer_pb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(hdlc_framer_pb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.hdlc_framer_pb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(hdlc_framer_pb_sptr self) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(hdlc_framer_pb_sptr self) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(hdlc_framer_pb_sptr self, int priority) -> int"""
        return _digital_swig.hdlc_framer_pb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(hdlc_framer_pb_sptr self) -> std::string"""
        return _digital_swig.hdlc_framer_pb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(hdlc_framer_pb_sptr self) -> std::string"""
        return _digital_swig.hdlc_framer_pb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(hdlc_framer_pb_sptr self) -> io_signature_sptr"""
        return _digital_swig.hdlc_framer_pb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(hdlc_framer_pb_sptr self) -> io_signature_sptr"""
        return _digital_swig.hdlc_framer_pb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(hdlc_framer_pb_sptr self) -> long"""
        return _digital_swig.hdlc_framer_pb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(hdlc_framer_pb_sptr self) -> basic_block_sptr"""
        return _digital_swig.hdlc_framer_pb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(hdlc_framer_pb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.hdlc_framer_pb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(hdlc_framer_pb_sptr self) -> std::string"""
        return _digital_swig.hdlc_framer_pb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(hdlc_framer_pb_sptr self, std::string name)"""
        return _digital_swig.hdlc_framer_pb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(hdlc_framer_pb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.hdlc_framer_pb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(hdlc_framer_pb_sptr self) -> swig_int_ptr"""
        return _digital_swig.hdlc_framer_pb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(hdlc_framer_pb_sptr self) -> swig_int_ptr"""
        return _digital_swig.hdlc_framer_pb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(hdlc_framer_pb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.hdlc_framer_pb_sptr_message_subscribers(self, *args, **kwargs)

hdlc_framer_pb_sptr_swigregister = _digital_swig.hdlc_framer_pb_sptr_swigregister
hdlc_framer_pb_sptr_swigregister(hdlc_framer_pb_sptr)

hdlc_framer_pb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
hdlc_framer_pb = hdlc_framer_pb.make;

class header_payload_demux_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::header_payload_demux)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::header_payload_demux)> self) -> header_payload_demux_sptr
        __init__(boost::shared_ptr<(gr::digital::header_payload_demux)> self, header_payload_demux p) -> header_payload_demux_sptr
        """
        this = _digital_swig.new_header_payload_demux_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(header_payload_demux_sptr self) -> header_payload_demux"""
        return _digital_swig.header_payload_demux_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_header_payload_demux_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(header_payload_demux_sptr self, int header_len, int items_per_symbol, int guard_interval=0, std::string const & length_tag_key="frame_len", 
            std::string const & trigger_tag_key="", bool output_symbols=False, 
            size_t itemsize=sizeof(gr_complex), std::string const & timing_tag_key="", 
            double const samp_rate=1.0, std::vector< std::string,std::allocator< std::string > > const & special_tags=std::vector< std::string >()) -> header_payload_demux_sptr

        Header/Payload demuxer.

        This block is designed to handle packets from a bursty transmission. Input 0 takes a continuous transmission of samples. If used, input 1 is a trigger signal. In this case, a 1 on input 1 is a trigger. Otherwise, a tag with the key specified in  is used as a trigger (its value is irrelevant).

        Until a trigger signal is detected, all samples are dropped onto the floor. Once a trigger is detected, a total of  items are copied to output 0. The block then stalls until it receives a message on the message port . The message must be a PMT dictionary; all key/value pairs are copied as tags to the first item of the payload (which is assumed to be the first item after the header). The value corresponding to the key specified in  is read and taken as the payload length. The payload, together with the header data as tags, is then copied to output 1.

        If specified,  items are discarded before every symbol. This is useful for demuxing bursts of OFDM signals.

        Any tags on the input stream are copied to the corresponding output  they're on an item that is propagated. Note that a tag on the header items is copied to the header stream; that means the header-parsing block must handle these tags if they should go on the payload. A special case are tags on items that make up the guard interval. These are copied to the first item of the following symbol. If a tag is situated very close to the end of the payload, it might be unclear if it belongs to this packet or the following. In this case, the tag might be propagated twice.

        Tags outside of packets are generally discarded. If this information is important, there are two additional mechanisms to preserve the tags:

        Constructor Specific Documentation:



        Args:
            header_len : Number of symbols per header
            items_per_symbol : Number of items per symbol
            guard_interval : Number of items between two consecutive symbols
            length_tag_key : Key of the frame length tag
            trigger_tag_key : Key of the trigger tag
            output_symbols : Output symbols (true) or items (false)?
            itemsize : Item size (bytes per item)
            timing_tag_key : The name of the tag with timing information, usually 'rx_time' or empty (this means timing info is discarded)
            samp_rate : Sampling rate at the input. Necessary to calculate the rx time of packets.
            special_tags : A vector of strings denoting tags which shall be preserved.
        """
        return _digital_swig.header_payload_demux_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(header_payload_demux_sptr self) -> unsigned int"""
        return _digital_swig.header_payload_demux_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(header_payload_demux_sptr self, int which, int delay)
        declare_sample_delay(header_payload_demux_sptr self, unsigned int delay)
        """
        return _digital_swig.header_payload_demux_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(header_payload_demux_sptr self, int which) -> unsigned int"""
        return _digital_swig.header_payload_demux_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(header_payload_demux_sptr self) -> int"""
        return _digital_swig.header_payload_demux_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(header_payload_demux_sptr self) -> double"""
        return _digital_swig.header_payload_demux_sptr_relative_rate(self)

    def start(self):
        """start(header_payload_demux_sptr self) -> bool"""
        return _digital_swig.header_payload_demux_sptr_start(self)

    def stop(self):
        """stop(header_payload_demux_sptr self) -> bool"""
        return _digital_swig.header_payload_demux_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(header_payload_demux_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.header_payload_demux_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(header_payload_demux_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.header_payload_demux_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(header_payload_demux_sptr self) -> int"""
        return _digital_swig.header_payload_demux_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(header_payload_demux_sptr self, int m)"""
        return _digital_swig.header_payload_demux_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(header_payload_demux_sptr self)"""
        return _digital_swig.header_payload_demux_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(header_payload_demux_sptr self) -> bool"""
        return _digital_swig.header_payload_demux_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(header_payload_demux_sptr self, int m)"""
        return _digital_swig.header_payload_demux_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(header_payload_demux_sptr self) -> int"""
        return _digital_swig.header_payload_demux_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(header_payload_demux_sptr self, int i) -> long"""
        return _digital_swig.header_payload_demux_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(header_payload_demux_sptr self, long max_output_buffer)
        set_max_output_buffer(header_payload_demux_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.header_payload_demux_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(header_payload_demux_sptr self, int i) -> long"""
        return _digital_swig.header_payload_demux_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(header_payload_demux_sptr self, long min_output_buffer)
        set_min_output_buffer(header_payload_demux_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.header_payload_demux_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full_avg(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(header_payload_demux_sptr self, int which) -> float
        pc_input_buffers_full_var(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full_avg(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(header_payload_demux_sptr self, int which) -> float
        pc_output_buffers_full_var(header_payload_demux_sptr self) -> pmt_vector_float
        """
        return _digital_swig.header_payload_demux_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(header_payload_demux_sptr self) -> float"""
        return _digital_swig.header_payload_demux_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(header_payload_demux_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.header_payload_demux_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(header_payload_demux_sptr self)"""
        return _digital_swig.header_payload_demux_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(header_payload_demux_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.header_payload_demux_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(header_payload_demux_sptr self) -> int"""
        return _digital_swig.header_payload_demux_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(header_payload_demux_sptr self) -> int"""
        return _digital_swig.header_payload_demux_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(header_payload_demux_sptr self, int priority) -> int"""
        return _digital_swig.header_payload_demux_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(header_payload_demux_sptr self) -> std::string"""
        return _digital_swig.header_payload_demux_sptr_name(self)

    def symbol_name(self):
        """symbol_name(header_payload_demux_sptr self) -> std::string"""
        return _digital_swig.header_payload_demux_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(header_payload_demux_sptr self) -> io_signature_sptr"""
        return _digital_swig.header_payload_demux_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(header_payload_demux_sptr self) -> io_signature_sptr"""
        return _digital_swig.header_payload_demux_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(header_payload_demux_sptr self) -> long"""
        return _digital_swig.header_payload_demux_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(header_payload_demux_sptr self) -> basic_block_sptr"""
        return _digital_swig.header_payload_demux_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(header_payload_demux_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.header_payload_demux_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(header_payload_demux_sptr self) -> std::string"""
        return _digital_swig.header_payload_demux_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(header_payload_demux_sptr self, std::string name)"""
        return _digital_swig.header_payload_demux_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(header_payload_demux_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.header_payload_demux_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(header_payload_demux_sptr self) -> swig_int_ptr"""
        return _digital_swig.header_payload_demux_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(header_payload_demux_sptr self) -> swig_int_ptr"""
        return _digital_swig.header_payload_demux_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(header_payload_demux_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.header_payload_demux_sptr_message_subscribers(self, *args, **kwargs)

header_payload_demux_sptr_swigregister = _digital_swig.header_payload_demux_sptr_swigregister
header_payload_demux_sptr_swigregister(header_payload_demux_sptr)

header_payload_demux_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
header_payload_demux = header_payload_demux.make;

class kurtotic_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::kurtotic_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::kurtotic_equalizer_cc)> self) -> kurtotic_equalizer_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::kurtotic_equalizer_cc)> self, kurtotic_equalizer_cc p) -> kurtotic_equalizer_cc_sptr
        """
        this = _digital_swig.new_kurtotic_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(kurtotic_equalizer_cc_sptr self) -> kurtotic_equalizer_cc"""
        return _digital_swig.kurtotic_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_kurtotic_equalizer_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(kurtotic_equalizer_cc_sptr self, int num_taps, float mu) -> kurtotic_equalizer_cc_sptr

        Implements a kurtosis-based adaptive equalizer on complex stream.

        Warning: This block does not yet work.

        "Y. Guo, J. Zhao, Y. Sun, "Sign kurtosis maximization based blind equalization algorithm," IEEE Conf. on Control, Automation,
        Robotics and Vision, Vol. 3, Dec. 2004, pp. 2052 - 2057."

        Constructor Specific Documentation:



        Args:
            num_taps : 
            mu : 
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_make(self, *args, **kwargs)

    def gain(self):
        """gain(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(kurtotic_equalizer_cc_sptr self, float mu)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def history(self):
        """history(kurtotic_equalizer_cc_sptr self) -> unsigned int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(kurtotic_equalizer_cc_sptr self, int which, int delay)
        declare_sample_delay(kurtotic_equalizer_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(kurtotic_equalizer_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(kurtotic_equalizer_cc_sptr self) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(kurtotic_equalizer_cc_sptr self) -> double"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(kurtotic_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(kurtotic_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(kurtotic_equalizer_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(kurtotic_equalizer_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(kurtotic_equalizer_cc_sptr self) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(kurtotic_equalizer_cc_sptr self, int m)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(kurtotic_equalizer_cc_sptr self)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(kurtotic_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(kurtotic_equalizer_cc_sptr self, int m)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(kurtotic_equalizer_cc_sptr self) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(kurtotic_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(kurtotic_equalizer_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(kurtotic_equalizer_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(kurtotic_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(kurtotic_equalizer_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(kurtotic_equalizer_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(kurtotic_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(kurtotic_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(kurtotic_equalizer_cc_sptr self) -> float"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(kurtotic_equalizer_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(kurtotic_equalizer_cc_sptr self)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(kurtotic_equalizer_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(kurtotic_equalizer_cc_sptr self) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(kurtotic_equalizer_cc_sptr self) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(kurtotic_equalizer_cc_sptr self, int priority) -> int"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(kurtotic_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(kurtotic_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(kurtotic_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(kurtotic_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(kurtotic_equalizer_cc_sptr self) -> long"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(kurtotic_equalizer_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(kurtotic_equalizer_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(kurtotic_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(kurtotic_equalizer_cc_sptr self, std::string name)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(kurtotic_equalizer_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.kurtotic_equalizer_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(kurtotic_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(kurtotic_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(kurtotic_equalizer_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.kurtotic_equalizer_cc_sptr_message_subscribers(self, *args, **kwargs)

kurtotic_equalizer_cc_sptr_swigregister = _digital_swig.kurtotic_equalizer_cc_sptr_swigregister
kurtotic_equalizer_cc_sptr_swigregister(kurtotic_equalizer_cc_sptr)

kurtotic_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
kurtotic_equalizer_cc = kurtotic_equalizer_cc.make;

class lms_dd_equalizer_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::lms_dd_equalizer_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::lms_dd_equalizer_cc)> self) -> lms_dd_equalizer_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::lms_dd_equalizer_cc)> self, lms_dd_equalizer_cc p) -> lms_dd_equalizer_cc_sptr
        """
        this = _digital_swig.new_lms_dd_equalizer_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(lms_dd_equalizer_cc_sptr self) -> lms_dd_equalizer_cc"""
        return _digital_swig.lms_dd_equalizer_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_lms_dd_equalizer_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(lms_dd_equalizer_cc_sptr self, int num_taps, float mu, int sps, constellation_sptr cnst) -> lms_dd_equalizer_cc_sptr

        Least-Mean-Square Decision Directed Equalizer (complex in/out)

        This block implements an LMS-based decision-directed equalizer. It uses a set of weights, w, to correlate against the inputs, u, and a decisions is then made from this output. The error in the decision is used to update the weight vector.

        y[n] = conj(w[n]) u[n] d[n] = decision(y[n]) e[n] = d[n] - y[n] w[n+1] = w[n] + mu u[n] conj(e[n])

        Where mu is a gain value (between 0 and 1 and usualy small, around 0.001 - 0.01.

        This block uses the digital_constellation object for making the decision from y[n]. Create the constellation object for whatever constellation is to be used and pass in the object. In Python, you can use something like:

        self.constellation = digital.constellation_qpsk()

        To create a QPSK constellation (see the digital_constellation block for more details as to what constellations are available or how to create your own). You then pass the object to this block as an sptr, or using "self.constellation.base()".

        The theory for this algorithm can be found in Chapter 9 of: S. Haykin, Adaptive Filter Theory, Upper Saddle River, NJ: Prentice Hall, 1996.

        Constructor Specific Documentation:

        Make an LMS decision-directed equalizer

        Args:
            num_taps : Numer of taps in the equalizer (channel size)
            mu : Gain of the update loop
            sps : Number of samples per symbol of the input signal
            cnst : A constellation derived from class 'constellation'. Use base() method to get a shared pointer to this base class type.
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_make(self, *args, **kwargs)

    def set_taps(self, *args, **kwargs):
        """set_taps(lms_dd_equalizer_cc_sptr self, pmt_vector_cfloat taps)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """taps(lms_dd_equalizer_cc_sptr self) -> pmt_vector_cfloat"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_taps(self)

    def gain(self):
        """gain(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_gain(self)

    def set_gain(self, *args, **kwargs):
        """set_gain(lms_dd_equalizer_cc_sptr self, float mu)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_gain(self, *args, **kwargs)

    def history(self):
        """history(lms_dd_equalizer_cc_sptr self) -> unsigned int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(lms_dd_equalizer_cc_sptr self, int which, int delay)
        declare_sample_delay(lms_dd_equalizer_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(lms_dd_equalizer_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(lms_dd_equalizer_cc_sptr self) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(lms_dd_equalizer_cc_sptr self) -> double"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_relative_rate(self)

    def start(self):
        """start(lms_dd_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_start(self)

    def stop(self):
        """stop(lms_dd_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(lms_dd_equalizer_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(lms_dd_equalizer_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(lms_dd_equalizer_cc_sptr self) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(lms_dd_equalizer_cc_sptr self, int m)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(lms_dd_equalizer_cc_sptr self)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(lms_dd_equalizer_cc_sptr self) -> bool"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(lms_dd_equalizer_cc_sptr self, int m)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(lms_dd_equalizer_cc_sptr self) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(lms_dd_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(lms_dd_equalizer_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(lms_dd_equalizer_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(lms_dd_equalizer_cc_sptr self, int i) -> long"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(lms_dd_equalizer_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(lms_dd_equalizer_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(lms_dd_equalizer_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(lms_dd_equalizer_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(lms_dd_equalizer_cc_sptr self) -> float"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(lms_dd_equalizer_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(lms_dd_equalizer_cc_sptr self)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(lms_dd_equalizer_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(lms_dd_equalizer_cc_sptr self) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(lms_dd_equalizer_cc_sptr self) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(lms_dd_equalizer_cc_sptr self, int priority) -> int"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(lms_dd_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(lms_dd_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(lms_dd_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(lms_dd_equalizer_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(lms_dd_equalizer_cc_sptr self) -> long"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(lms_dd_equalizer_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(lms_dd_equalizer_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(lms_dd_equalizer_cc_sptr self) -> std::string"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(lms_dd_equalizer_cc_sptr self, std::string name)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(lms_dd_equalizer_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.lms_dd_equalizer_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(lms_dd_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(lms_dd_equalizer_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(lms_dd_equalizer_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.lms_dd_equalizer_cc_sptr_message_subscribers(self, *args, **kwargs)

lms_dd_equalizer_cc_sptr_swigregister = _digital_swig.lms_dd_equalizer_cc_sptr_swigregister
lms_dd_equalizer_cc_sptr_swigregister(lms_dd_equalizer_cc_sptr)

lms_dd_equalizer_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
lms_dd_equalizer_cc = lms_dd_equalizer_cc.make;

class map_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::map_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::map_bb)> self) -> map_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::map_bb)> self, map_bb p) -> map_bb_sptr
        """
        this = _digital_swig.new_map_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(map_bb_sptr self) -> map_bb"""
        return _digital_swig.map_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_map_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(map_bb_sptr self, std::vector< int,std::allocator< int > > const & map) -> map_bb_sptr

        output[i] = map[input[i]]

        This block maps an incoming signal to the value in the map. The block expects that the incoming signal has a maximum value of len(map)-1.

        -> output[i] = map[input[i]]

        Constructor Specific Documentation:

        Make a map block.

        Args:
            map : a vector of integers that maps x to map[x].
        """
        return _digital_swig.map_bb_sptr_make(self, *args, **kwargs)

    def set_map(self, *args, **kwargs):
        """set_map(map_bb_sptr self, std::vector< int,std::allocator< int > > const & map)"""
        return _digital_swig.map_bb_sptr_set_map(self, *args, **kwargs)

    def map(self):
        """
        map(map_bb_sptr self) -> std::vector< int,std::allocator< int > >

        Apply  element-wise to the elements of list and returns a list of the results, in order.

        must be a list. The dynamic order in which  is applied to the elements of  is unspecified.
        """
        return _digital_swig.map_bb_sptr_map(self)

    def history(self):
        """history(map_bb_sptr self) -> unsigned int"""
        return _digital_swig.map_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(map_bb_sptr self, int which, int delay)
        declare_sample_delay(map_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.map_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(map_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.map_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(map_bb_sptr self) -> int"""
        return _digital_swig.map_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(map_bb_sptr self) -> double"""
        return _digital_swig.map_bb_sptr_relative_rate(self)

    def start(self):
        """start(map_bb_sptr self) -> bool"""
        return _digital_swig.map_bb_sptr_start(self)

    def stop(self):
        """stop(map_bb_sptr self) -> bool"""
        return _digital_swig.map_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(map_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.map_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(map_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.map_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(map_bb_sptr self) -> int"""
        return _digital_swig.map_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(map_bb_sptr self, int m)"""
        return _digital_swig.map_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(map_bb_sptr self)"""
        return _digital_swig.map_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(map_bb_sptr self) -> bool"""
        return _digital_swig.map_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(map_bb_sptr self, int m)"""
        return _digital_swig.map_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(map_bb_sptr self) -> int"""
        return _digital_swig.map_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(map_bb_sptr self, int i) -> long"""
        return _digital_swig.map_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(map_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(map_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.map_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(map_bb_sptr self, int i) -> long"""
        return _digital_swig.map_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(map_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(map_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.map_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(map_bb_sptr self, int which) -> float
        pc_input_buffers_full(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(map_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(map_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(map_bb_sptr self, int which) -> float
        pc_output_buffers_full(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(map_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(map_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(map_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.map_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(map_bb_sptr self) -> float"""
        return _digital_swig.map_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(map_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.map_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(map_bb_sptr self)"""
        return _digital_swig.map_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(map_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.map_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(map_bb_sptr self) -> int"""
        return _digital_swig.map_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(map_bb_sptr self) -> int"""
        return _digital_swig.map_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(map_bb_sptr self, int priority) -> int"""
        return _digital_swig.map_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(map_bb_sptr self) -> std::string"""
        return _digital_swig.map_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(map_bb_sptr self) -> std::string"""
        return _digital_swig.map_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(map_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.map_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(map_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.map_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(map_bb_sptr self) -> long"""
        return _digital_swig.map_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(map_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.map_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(map_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.map_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(map_bb_sptr self) -> std::string"""
        return _digital_swig.map_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(map_bb_sptr self, std::string name)"""
        return _digital_swig.map_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(map_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.map_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(map_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.map_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(map_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.map_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(map_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.map_bb_sptr_message_subscribers(self, *args, **kwargs)

map_bb_sptr_swigregister = _digital_swig.map_bb_sptr_swigregister
map_bb_sptr_swigregister(map_bb_sptr)

map_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
map_bb = map_bb.make;

class mpsk_receiver_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::mpsk_receiver_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::mpsk_receiver_cc)> self) -> mpsk_receiver_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::mpsk_receiver_cc)> self, mpsk_receiver_cc p) -> mpsk_receiver_cc_sptr
        """
        this = _digital_swig.new_mpsk_receiver_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(mpsk_receiver_cc_sptr self) -> mpsk_receiver_cc"""
        return _digital_swig.mpsk_receiver_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_mpsk_receiver_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(mpsk_receiver_cc_sptr self, unsigned int M, float theta, float loop_bw, float fmin, float fmax, float mu, float gain_mu, 
            float omega, float gain_omega, float omega_rel) -> mpsk_receiver_cc_sptr

        This block takes care of receiving M-PSK modulated signals through phase, frequency, and symbol synchronization.

        It performs carrier frequency and phase locking as well as symbol timing recovery. It works with (D)BPSK, (D)QPSK, and (D)8PSK as tested currently. It should also work for OQPSK and PI/4 DQPSK.

        The phase and frequency synchronization are based on a Costas loop that finds the error of the incoming signal point compared to its nearest constellation point. The frequency and phase of the NCO are updated according to this error. There are optimized phase error detectors for BPSK and QPSK, but 8PSK is done using a brute-force computation of the constellation points to find the minimum.

        The symbol synchronization is done using a modified Mueller and Muller circuit from the paper:

        "G. R. Danesfahani, T. G. Jeans, "Optimisation of modified Mueller and Muller algorithm," Electronics Letters, Vol. 31, no. 13, 22
        June 1995, pp. 1032 - 1033."

        This circuit interpolates the downconverted sample (using the NCO developed by the Costas loop) every mu samples, then it finds the sampling error based on this and the past symbols and the decision made on the samples. Like the phase error detector, there are optimized decision algorithms for BPSK and QPKS, but 8PSK uses another brute force computation against all possible symbols. The modifications to the M&M used here reduce self-noise.

        Constructor Specific Documentation:

        Make a M-PSK receiver block.

        The constructor also chooses which phase detector and decision maker to use in the work loop based on the value of M.

        Args:
            M : modulation order of the M-PSK modulation
            theta : any constant phase rotation from the real axis of the constellation
            loop_bw : Loop bandwidth to set gains of phase/freq tracking loop
            fmin : minimum normalized frequency value the loop can achieve
            fmax : maximum normalized frequency value the loop can achieve
            mu : initial parameter for the interpolator [0,1]
            gain_mu : gain parameter of the M&M error signal to adjust mu (~0.05)
            omega : initial value for the number of symbols between samples (~number of samples/symbol)
            gain_omega : gain parameter to adjust omega based on the error (~omega^2/4)
            omega_rel : sets the maximum (omega*(1+omega_rel)) and minimum (omega*(1+omega_rel)) omega (~0.005)
        """
        return _digital_swig.mpsk_receiver_cc_sptr_make(self, *args, **kwargs)

    def modulation_order(self):
        """
        modulation_order(mpsk_receiver_cc_sptr self) -> float

        Returns the modulation order (M) currently set.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_modulation_order(self)

    def theta(self):
        """
        theta(mpsk_receiver_cc_sptr self) -> float

        Returns current value of theta.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_theta(self)

    def mu(self):
        """
        mu(mpsk_receiver_cc_sptr self) -> float

        Returns current value of mu.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_mu(self)

    def omega(self):
        """
        omega(mpsk_receiver_cc_sptr self) -> float

        Returns current value of omega.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_omega(self)

    def gain_mu(self):
        """
        gain_mu(mpsk_receiver_cc_sptr self) -> float

        Returns mu gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_gain_mu(self)

    def gain_omega(self):
        """
        gain_omega(mpsk_receiver_cc_sptr self) -> float

        Returns omega gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_gain_omega(self)

    def gain_omega_rel(self):
        """
        gain_omega_rel(mpsk_receiver_cc_sptr self) -> float

        Returns the relative omega limit.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_gain_omega_rel(self)

    def set_modulation_order(self, *args, **kwargs):
        """
        set_modulation_order(mpsk_receiver_cc_sptr self, unsigned int M)

        Sets the modulation order (M) currently.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_modulation_order(self, *args, **kwargs)

    def set_theta(self, *args, **kwargs):
        """
        set_theta(mpsk_receiver_cc_sptr self, float theta)

        Sets value of theta.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_theta(self, *args, **kwargs)

    def set_mu(self, *args, **kwargs):
        """
        set_mu(mpsk_receiver_cc_sptr self, float mu)

        Sets value of mu.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_mu(self, *args, **kwargs)

    def set_omega(self, *args, **kwargs):
        """
        set_omega(mpsk_receiver_cc_sptr self, float omega)

        Sets value of omega and its min and max values.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_omega(self, *args, **kwargs)

    def set_gain_mu(self, *args, **kwargs):
        """
        set_gain_mu(mpsk_receiver_cc_sptr self, float gain_mu)

        Sets value for mu gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_gain_mu(self, *args, **kwargs)

    def set_gain_omega(self, *args, **kwargs):
        """
        set_gain_omega(mpsk_receiver_cc_sptr self, float gain_omega)

        Sets value for omega gain factor.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_gain_omega(self, *args, **kwargs)

    def set_gain_omega_rel(self, *args, **kwargs):
        """
        set_gain_omega_rel(mpsk_receiver_cc_sptr self, float omega_rel)

        Sets the relative omega limit and resets omega min/max values.
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_gain_omega_rel(self, *args, **kwargs)

    def history(self):
        """history(mpsk_receiver_cc_sptr self) -> unsigned int"""
        return _digital_swig.mpsk_receiver_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(mpsk_receiver_cc_sptr self, int which, int delay)
        declare_sample_delay(mpsk_receiver_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.mpsk_receiver_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(mpsk_receiver_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.mpsk_receiver_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(mpsk_receiver_cc_sptr self) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(mpsk_receiver_cc_sptr self) -> double"""
        return _digital_swig.mpsk_receiver_cc_sptr_relative_rate(self)

    def start(self):
        """start(mpsk_receiver_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_receiver_cc_sptr_start(self)

    def stop(self):
        """stop(mpsk_receiver_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_receiver_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(mpsk_receiver_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.mpsk_receiver_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(mpsk_receiver_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.mpsk_receiver_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(mpsk_receiver_cc_sptr self) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(mpsk_receiver_cc_sptr self, int m)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(mpsk_receiver_cc_sptr self)"""
        return _digital_swig.mpsk_receiver_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(mpsk_receiver_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_receiver_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(mpsk_receiver_cc_sptr self, int m)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(mpsk_receiver_cc_sptr self) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(mpsk_receiver_cc_sptr self, int i) -> long"""
        return _digital_swig.mpsk_receiver_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(mpsk_receiver_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(mpsk_receiver_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(mpsk_receiver_cc_sptr self, int i) -> long"""
        return _digital_swig.mpsk_receiver_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(mpsk_receiver_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(mpsk_receiver_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.mpsk_receiver_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(mpsk_receiver_cc_sptr self, int which) -> float
        pc_input_buffers_full(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(mpsk_receiver_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(mpsk_receiver_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(mpsk_receiver_cc_sptr self, int which) -> float
        pc_output_buffers_full(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(mpsk_receiver_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(mpsk_receiver_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(mpsk_receiver_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_receiver_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(mpsk_receiver_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(mpsk_receiver_cc_sptr self)"""
        return _digital_swig.mpsk_receiver_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(mpsk_receiver_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.mpsk_receiver_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(mpsk_receiver_cc_sptr self) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(mpsk_receiver_cc_sptr self) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(mpsk_receiver_cc_sptr self, int priority) -> int"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(mpsk_receiver_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_receiver_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(mpsk_receiver_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_receiver_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(mpsk_receiver_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(mpsk_receiver_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(mpsk_receiver_cc_sptr self) -> long"""
        return _digital_swig.mpsk_receiver_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(mpsk_receiver_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(mpsk_receiver_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.mpsk_receiver_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(mpsk_receiver_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_receiver_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(mpsk_receiver_cc_sptr self, std::string name)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(mpsk_receiver_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.mpsk_receiver_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(mpsk_receiver_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(mpsk_receiver_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(mpsk_receiver_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.mpsk_receiver_cc_sptr_message_subscribers(self, *args, **kwargs)

    def update_gains(self):
        """update_gains(mpsk_receiver_cc_sptr self)"""
        return _digital_swig.mpsk_receiver_cc_sptr_update_gains(self)

    def advance_loop(self, *args, **kwargs):
        """advance_loop(mpsk_receiver_cc_sptr self, float error)"""
        return _digital_swig.mpsk_receiver_cc_sptr_advance_loop(self, *args, **kwargs)

    def phase_wrap(self):
        """phase_wrap(mpsk_receiver_cc_sptr self)"""
        return _digital_swig.mpsk_receiver_cc_sptr_phase_wrap(self)

    def frequency_limit(self):
        """frequency_limit(mpsk_receiver_cc_sptr self)"""
        return _digital_swig.mpsk_receiver_cc_sptr_frequency_limit(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """set_loop_bandwidth(mpsk_receiver_cc_sptr self, float bw)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """set_damping_factor(mpsk_receiver_cc_sptr self, float df)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """set_alpha(mpsk_receiver_cc_sptr self, float alpha)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """set_beta(mpsk_receiver_cc_sptr self, float beta)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_beta(self, *args, **kwargs)

    def set_frequency(self, *args, **kwargs):
        """set_frequency(mpsk_receiver_cc_sptr self, float freq)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_frequency(self, *args, **kwargs)

    def set_phase(self, *args, **kwargs):
        """set_phase(mpsk_receiver_cc_sptr self, float phase)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_phase(self, *args, **kwargs)

    def set_max_freq(self, *args, **kwargs):
        """set_max_freq(mpsk_receiver_cc_sptr self, float freq)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_max_freq(self, *args, **kwargs)

    def set_min_freq(self, *args, **kwargs):
        """set_min_freq(mpsk_receiver_cc_sptr self, float freq)"""
        return _digital_swig.mpsk_receiver_cc_sptr_set_min_freq(self, *args, **kwargs)

    def get_loop_bandwidth(self):
        """get_loop_bandwidth(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_loop_bandwidth(self)

    def get_damping_factor(self):
        """get_damping_factor(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_damping_factor(self)

    def get_alpha(self):
        """get_alpha(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_alpha(self)

    def get_beta(self):
        """get_beta(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_beta(self)

    def get_frequency(self):
        """get_frequency(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_frequency(self)

    def get_phase(self):
        """get_phase(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_phase(self)

    def get_max_freq(self):
        """get_max_freq(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_max_freq(self)

    def get_min_freq(self):
        """get_min_freq(mpsk_receiver_cc_sptr self) -> float"""
        return _digital_swig.mpsk_receiver_cc_sptr_get_min_freq(self)

mpsk_receiver_cc_sptr_swigregister = _digital_swig.mpsk_receiver_cc_sptr_swigregister
mpsk_receiver_cc_sptr_swigregister(mpsk_receiver_cc_sptr)

mpsk_receiver_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
mpsk_receiver_cc = mpsk_receiver_cc.make;

class mpsk_snr_est_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::mpsk_snr_est_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::mpsk_snr_est_cc)> self) -> mpsk_snr_est_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::mpsk_snr_est_cc)> self, mpsk_snr_est_cc p) -> mpsk_snr_est_cc_sptr
        """
        this = _digital_swig.new_mpsk_snr_est_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(mpsk_snr_est_cc_sptr self) -> mpsk_snr_est_cc"""
        return _digital_swig.mpsk_snr_est_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_mpsk_snr_est_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(mpsk_snr_est_cc_sptr self, gr::digital::snr_est_type_t type, int tag_nsamples=10000, double alpha=0.001) -> mpsk_snr_est_cc_sptr

        A block for computing SNR of a signal.

        This block can be used to monitor and retrieve estimations of the signal SNR. It is designed to work in a flowgraph and passes all incoming data along to its output.

        The block is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

        Constructor Specific Documentation:

        Factory function returning shared pointer of this class

        Args:
            type : the type of estimator to use gr::digital::snr_est_type_t "snr_est_type_t" for details about the available types
            tag_nsamples : after this many samples, a tag containing the SNR (key='snr') will be sent
            alpha : the update rate of internal running average calculations
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_make(self, *args, **kwargs)

    def snr(self):
        """
        snr(mpsk_snr_est_cc_sptr self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_snr(self)

    def type(self):
        """
        type(mpsk_snr_est_cc_sptr self) -> gr::digital::snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_type(self)

    def tag_nsample(self):
        """
        tag_nsample(mpsk_snr_est_cc_sptr self) -> int

        Return how many samples between SNR tags.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_tag_nsample(self)

    def alpha(self):
        """
        alpha(mpsk_snr_est_cc_sptr self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(mpsk_snr_est_cc_sptr self, gr::digital::snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_set_type(self, *args, **kwargs)

    def set_tag_nsample(self, *args, **kwargs):
        """
        set_tag_nsample(mpsk_snr_est_cc_sptr self, int n)

        Set the number of samples between SNR tags.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_set_tag_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(mpsk_snr_est_cc_sptr self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(mpsk_snr_est_cc_sptr self) -> unsigned int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(mpsk_snr_est_cc_sptr self, int which, int delay)
        declare_sample_delay(mpsk_snr_est_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(mpsk_snr_est_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(mpsk_snr_est_cc_sptr self) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(mpsk_snr_est_cc_sptr self) -> double"""
        return _digital_swig.mpsk_snr_est_cc_sptr_relative_rate(self)

    def start(self):
        """start(mpsk_snr_est_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_snr_est_cc_sptr_start(self)

    def stop(self):
        """stop(mpsk_snr_est_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_snr_est_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(mpsk_snr_est_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.mpsk_snr_est_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(mpsk_snr_est_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.mpsk_snr_est_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(mpsk_snr_est_cc_sptr self) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(mpsk_snr_est_cc_sptr self, int m)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(mpsk_snr_est_cc_sptr self)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(mpsk_snr_est_cc_sptr self) -> bool"""
        return _digital_swig.mpsk_snr_est_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(mpsk_snr_est_cc_sptr self, int m)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(mpsk_snr_est_cc_sptr self) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(mpsk_snr_est_cc_sptr self, int i) -> long"""
        return _digital_swig.mpsk_snr_est_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(mpsk_snr_est_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(mpsk_snr_est_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(mpsk_snr_est_cc_sptr self, int i) -> long"""
        return _digital_swig.mpsk_snr_est_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(mpsk_snr_est_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(mpsk_snr_est_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_input_buffers_full(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_output_buffers_full(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(mpsk_snr_est_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(mpsk_snr_est_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(mpsk_snr_est_cc_sptr self) -> float"""
        return _digital_swig.mpsk_snr_est_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(mpsk_snr_est_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(mpsk_snr_est_cc_sptr self)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(mpsk_snr_est_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.mpsk_snr_est_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(mpsk_snr_est_cc_sptr self) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(mpsk_snr_est_cc_sptr self) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(mpsk_snr_est_cc_sptr self, int priority) -> int"""
        return _digital_swig.mpsk_snr_est_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(mpsk_snr_est_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_snr_est_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(mpsk_snr_est_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_snr_est_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(mpsk_snr_est_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(mpsk_snr_est_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(mpsk_snr_est_cc_sptr self) -> long"""
        return _digital_swig.mpsk_snr_est_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(mpsk_snr_est_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(mpsk_snr_est_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.mpsk_snr_est_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(mpsk_snr_est_cc_sptr self) -> std::string"""
        return _digital_swig.mpsk_snr_est_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(mpsk_snr_est_cc_sptr self, std::string name)"""
        return _digital_swig.mpsk_snr_est_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(mpsk_snr_est_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.mpsk_snr_est_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(mpsk_snr_est_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(mpsk_snr_est_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(mpsk_snr_est_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.mpsk_snr_est_cc_sptr_message_subscribers(self, *args, **kwargs)

mpsk_snr_est_cc_sptr_swigregister = _digital_swig.mpsk_snr_est_cc_sptr_swigregister
mpsk_snr_est_cc_sptr_swigregister(mpsk_snr_est_cc_sptr)

mpsk_snr_est_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
mpsk_snr_est_cc = mpsk_snr_est_cc.make;

class ofdm_carrier_allocator_cvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_carrier_allocator_cvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_carrier_allocator_cvc)> self) -> ofdm_carrier_allocator_cvc_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_carrier_allocator_cvc)> self, ofdm_carrier_allocator_cvc p) -> ofdm_carrier_allocator_cvc_sptr
        """
        this = _digital_swig.new_ofdm_carrier_allocator_cvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_carrier_allocator_cvc_sptr self) -> ofdm_carrier_allocator_cvc"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_carrier_allocator_cvc_sptr
    __del__ = lambda self : None;
    def len_tag_key(self):
        """len_tag_key(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_len_tag_key(self)

    def fft_len(self):
        """fft_len(ofdm_carrier_allocator_cvc_sptr self) -> int const"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_fft_len(self)

    def occupied_carriers(self):
        """occupied_carriers(ofdm_carrier_allocator_cvc_sptr self) -> std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > >"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_occupied_carriers(self)

    def make(self, *args, **kwargs):
        """
        make(ofdm_carrier_allocator_cvc_sptr self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers, 
            gr_vector_vector_complexf pilot_symbols, 
            gr_vector_vector_complexf sync_words, 
            std::string const & len_tag_key="packet_len", 
            bool const output_is_shifted=True) -> ofdm_carrier_allocator_cvc_sptr

        Create frequency domain OFDM symbols from complex values, add pilots.

        This block turns a stream of complex, scalar modulation symbols into vectors which are the input for an IFFT in an OFDM transmitter. It also supports the possibility of placing pilot symbols onto the carriers.

        The carriers can be allocated freely, if a carrier is not allocated, it is set to zero. This allows doing OFDMA-style carrier allocations.

        Input: A tagged stream of complex scalars. The first item must have a tag containing the number of complex symbols in this frame. Output: A tagged stream of complex vectors of length fft_len. This can directly be connected to an FFT block. Make sure to set this block to 'reverse' for the IFFT. If  is true, the FFT block must activate FFT shifting, otherwise, set shifting to false. If given, sync words are prepended to the output. Note that sync words are prepended verbatim, make sure they are shifted (or not).

        Carrier indexes are always such that index 0 is the DC carrier (note: you should not allocate this carrier). The carriers below the DC carrier are either indexed with negative numbers, or with indexes larger than . Index -1 and index  both identify the carrier below the DC carrier.

        There are some basic checks in place during initialization which check that the carrier allocation table is valid. However, it is possible to overwrite data symbols with pilot symbols, or provide a carrier allocation that has mismatching pilot symbol positions and -values.

        Tags are propagated such that a tag on an incoming complex symbol is mapped to the corresponding OFDM symbol. There is one exception: If a tag is on the first OFDM symbol, it is assumed that this tag should stay there, so it is moved to the front even if a sync word is included (any other tags will never be attached to the sync word). This allows tags to control the transmit timing to pass through in the correct position.

        Constructor Specific Documentation:



        Args:
            fft_len : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            sync_words : 
            len_tag_key : 
            output_is_shifted : 
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_carrier_allocator_cvc_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_carrier_allocator_cvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_carrier_allocator_cvc_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_carrier_allocator_cvc_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_carrier_allocator_cvc_sptr self) -> double"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_carrier_allocator_cvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_carrier_allocator_cvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self, int m)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> bool"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_carrier_allocator_cvc_sptr self, int m)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_carrier_allocator_cvc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_carrier_allocator_cvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_carrier_allocator_cvc_sptr self) -> float"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_carrier_allocator_cvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_carrier_allocator_cvc_sptr self)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_carrier_allocator_cvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_carrier_allocator_cvc_sptr self) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_carrier_allocator_cvc_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_carrier_allocator_cvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_carrier_allocator_cvc_sptr self) -> long"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_carrier_allocator_cvc_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_carrier_allocator_cvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_carrier_allocator_cvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_carrier_allocator_cvc_sptr self, std::string name)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_carrier_allocator_cvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_carrier_allocator_cvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_carrier_allocator_cvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_carrier_allocator_cvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_carrier_allocator_cvc_sptr_swigregister = _digital_swig.ofdm_carrier_allocator_cvc_sptr_swigregister
ofdm_carrier_allocator_cvc_sptr_swigregister(ofdm_carrier_allocator_cvc_sptr)

ofdm_carrier_allocator_cvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_carrier_allocator_cvc = ofdm_carrier_allocator_cvc.make;

class ofdm_chanest_vcvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_chanest_vcvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_chanest_vcvc)> self) -> ofdm_chanest_vcvc_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_chanest_vcvc)> self, ofdm_chanest_vcvc p) -> ofdm_chanest_vcvc_sptr
        """
        this = _digital_swig.new_ofdm_chanest_vcvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_chanest_vcvc_sptr self) -> ofdm_chanest_vcvc"""
        return _digital_swig.ofdm_chanest_vcvc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_chanest_vcvc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_chanest_vcvc_sptr self, pmt_vector_cfloat sync_symbol1, pmt_vector_cfloat sync_symbol2, int n_data_symbols, 
            int eq_noise_red_len=0, int max_carr_offset=-1, bool force_one_sync_symbol=False) -> ofdm_chanest_vcvc_sptr

        Estimate channel and coarse frequency offset for OFDM from preambles

        Input: OFDM symbols (in frequency domain). The first one (or two) symbols are expected to be synchronisation symbols, which are used to estimate the coarse freq offset and the initial equalizer taps (these symbols are removed from the stream). The following  are passed through unmodified (the actual equalisation must be done elsewhere). Output: The data symbols, without the synchronisation symbols. The first data symbol passed through has two tags: 'ofdm_sync_carr_offset' (integer), the coarse frequency offset as number of carriers, and 'ofdm_sync_eq_taps' (complex vector). Any tags attached to the synchronisation symbols are attached to the first data symbol. All other tags are propagated as expected.

        Note: The vector on ofdm_sync_eq_taps is already frequency-corrected, whereas the rest is not.

        This block assumes the frequency offset is even (i.e. an integer multiple of 2).

        [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997. [2] K.D. Kammeyer, "Nachrichtenuebertragung," Chapter. 16.3.2.

        Constructor Specific Documentation:



        Args:
            sync_symbol1 : First synchronisation symbol in the frequency domain. Its length must be the FFT length. For Schmidl & Cox synchronisation, every second sub-carrier has to be zero.
            sync_symbol2 : Second synchronisation symbol in the frequency domain. Must be equal to the FFT length, or zero length if only one synchronisation symbol is used. Using this symbol is how synchronisation is described in [1]. Leaving this empty forces us to interpolate the equalizer taps. If you are using an unusual sub-carrier configuration (e.g. because of OFDMA), this sync symbol is used to identify the active sub-carriers. If you only have one synchronisation symbol, set the active sub-carriers to a non-zero value in here, and also set  parameter to true.
            n_data_symbols : The number of data symbols following each set of synchronisation symbols. Must be at least 1.
            eq_noise_red_len : If non-zero, noise reduction for the equalizer taps is done according to [2]. In this case, it is the channel influence time in number of samples. A good value is usually the length of the cyclic prefix.
            max_carr_offset : Limit the number of sub-carriers the frequency offset can maximally be. Leave this zero to try all possibilities.
            force_one_sync_symbol : See .
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_chanest_vcvc_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_chanest_vcvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_chanest_vcvc_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_chanest_vcvc_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_chanest_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_chanest_vcvc_sptr self) -> double"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_chanest_vcvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_chanest_vcvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_chanest_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_chanest_vcvc_sptr self, int m)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_chanest_vcvc_sptr self)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_chanest_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_chanest_vcvc_sptr self, int m)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_chanest_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_chanest_vcvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_chanest_vcvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_chanest_vcvc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_chanest_vcvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_chanest_vcvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_chanest_vcvc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_chanest_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_chanest_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_chanest_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_chanest_vcvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_chanest_vcvc_sptr self)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_chanest_vcvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_chanest_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_chanest_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_chanest_vcvc_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_chanest_vcvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_chanest_vcvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_chanest_vcvc_sptr self) -> long"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_chanest_vcvc_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_chanest_vcvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_chanest_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_chanest_vcvc_sptr self, std::string name)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_chanest_vcvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_chanest_vcvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_chanest_vcvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_chanest_vcvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_chanest_vcvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_chanest_vcvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_chanest_vcvc_sptr_swigregister = _digital_swig.ofdm_chanest_vcvc_sptr_swigregister
ofdm_chanest_vcvc_sptr_swigregister(ofdm_chanest_vcvc_sptr)

ofdm_chanest_vcvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_chanest_vcvc = ofdm_chanest_vcvc.make;

class ofdm_cyclic_prefixer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_cyclic_prefixer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_cyclic_prefixer)> self) -> ofdm_cyclic_prefixer_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_cyclic_prefixer)> self, ofdm_cyclic_prefixer p) -> ofdm_cyclic_prefixer_sptr
        """
        this = _digital_swig.new_ofdm_cyclic_prefixer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_cyclic_prefixer_sptr self) -> ofdm_cyclic_prefixer"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_cyclic_prefixer_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_cyclic_prefixer_sptr self, size_t input_size, size_t output_size, int rolloff_len=0, std::string const & len_tag_key="") -> ofdm_cyclic_prefixer_sptr

        Adds a cyclic prefix and performs pulse shaping on OFDM symbols.

        Input: OFDM symbols (in the time domain, i.e. after the IFFT). Optionally, entire frames can be processed. In this case,  must be specified which holds the key of the tag that denotes how many OFDM symbols are in a frame. Output: A stream of (scalar) complex symbols, which include the cyclic prefix and the pulse shaping. Note: If complete frames are processed, and  is greater than zero, the final OFDM symbol is followed by the delay line of the pulse shaping.

        The pulse shape is a raised cosine in the time domain.

        Constructor Specific Documentation:



        Args:
            input_size : FFT length (i.e. length of the OFDM symbols)
            output_size : FFT length + cyclic prefix length (in samples)
            rolloff_len : Length of the rolloff flank in samples
            len_tag_key : For framed processing the key of the length tag
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_cyclic_prefixer_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_cyclic_prefixer_sptr self, int which, int delay)
        declare_sample_delay(ofdm_cyclic_prefixer_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_cyclic_prefixer_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_cyclic_prefixer_sptr self) -> double"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_start(self)

    def stop(self):
        """stop(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_cyclic_prefixer_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_cyclic_prefixer_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_cyclic_prefixer_sptr self, int m)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_cyclic_prefixer_sptr self)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_cyclic_prefixer_sptr self) -> bool"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_cyclic_prefixer_sptr self, int m)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_cyclic_prefixer_sptr self, int i) -> long"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_cyclic_prefixer_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_cyclic_prefixer_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_cyclic_prefixer_sptr self, int i) -> long"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_cyclic_prefixer_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_cyclic_prefixer_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_cyclic_prefixer_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_cyclic_prefixer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_cyclic_prefixer_sptr self) -> float"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_cyclic_prefixer_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_cyclic_prefixer_sptr self)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_cyclic_prefixer_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_cyclic_prefixer_sptr self) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_cyclic_prefixer_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_cyclic_prefixer_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_cyclic_prefixer_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_cyclic_prefixer_sptr self) -> long"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_cyclic_prefixer_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_cyclic_prefixer_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_cyclic_prefixer_sptr self) -> std::string"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_cyclic_prefixer_sptr self, std::string name)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_cyclic_prefixer_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_cyclic_prefixer_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_cyclic_prefixer_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_cyclic_prefixer_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_cyclic_prefixer_sptr_message_subscribers(self, *args, **kwargs)

ofdm_cyclic_prefixer_sptr_swigregister = _digital_swig.ofdm_cyclic_prefixer_sptr_swigregister
ofdm_cyclic_prefixer_sptr_swigregister(ofdm_cyclic_prefixer_sptr)

ofdm_cyclic_prefixer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_cyclic_prefixer = ofdm_cyclic_prefixer.make;

class ofdm_frame_acquisition_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_frame_acquisition)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_acquisition)> self) -> ofdm_frame_acquisition_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_acquisition)> self, ofdm_frame_acquisition p) -> ofdm_frame_acquisition_sptr
        """
        this = _digital_swig.new_ofdm_frame_acquisition_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_frame_acquisition_sptr self) -> ofdm_frame_acquisition"""
        return _digital_swig.ofdm_frame_acquisition_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_frame_acquisition_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_frame_acquisition_sptr self, unsigned int occupied_carriers, unsigned int fft_length, unsigned int cplen, pmt_vector_cfloat known_symbol, 
            unsigned int max_fft_shift_len=4) -> ofdm_frame_acquisition_sptr

        take a vector of complex constellation points in from an FFT and performs a correlation and equalization.

        This block takes the output of an FFT of a received OFDM symbol and finds the start of a frame based on two known symbols. It also looks at the surrounding bins in the FFT output for the correlation in case there is a large frequency shift in the data. This block assumes that the fine frequency shift has already been corrected and that the samples fall in the middle of one FFT bin.

        It then uses one of those known symbols to estimate the channel response over all subcarriers and does a simple 1-tap equalization on all subcarriers. This corrects for the phase and amplitude distortion caused by the channel.

        Constructor Specific Documentation:

        Make an OFDM correlator and equalizer.

        Args:
            occupied_carriers : The number of subcarriers with data in the received symbol
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
            cplen : The length of the cycle prefix
            known_symbol : A vector of complex numbers representing a known symbol at the start of a frame (usually a BPSK PN sequence)
            max_fft_shift_len : Set's the maximum distance you can look between bins for correlation
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_make(self, *args, **kwargs)

    def snr(self):
        """
        snr(ofdm_frame_acquisition_sptr self) -> float

        Return an estimate of the SNR of the channel.
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_snr(self)

    def history(self):
        """history(ofdm_frame_acquisition_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_frame_acquisition_sptr self, int which, int delay)
        declare_sample_delay(ofdm_frame_acquisition_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_frame_acquisition_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_frame_acquisition_sptr self) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_frame_acquisition_sptr self) -> double"""
        return _digital_swig.ofdm_frame_acquisition_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_frame_acquisition_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_acquisition_sptr_start(self)

    def stop(self):
        """stop(ofdm_frame_acquisition_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_acquisition_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_frame_acquisition_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_frame_acquisition_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_frame_acquisition_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_frame_acquisition_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_frame_acquisition_sptr self) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_frame_acquisition_sptr self, int m)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_frame_acquisition_sptr self)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_frame_acquisition_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_acquisition_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_frame_acquisition_sptr self, int m)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_frame_acquisition_sptr self) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_frame_acquisition_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_acquisition_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_frame_acquisition_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_frame_acquisition_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_frame_acquisition_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_acquisition_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_frame_acquisition_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_frame_acquisition_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_frame_acquisition_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_frame_acquisition_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_frame_acquisition_sptr self) -> float"""
        return _digital_swig.ofdm_frame_acquisition_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_frame_acquisition_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_frame_acquisition_sptr self)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_frame_acquisition_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_frame_acquisition_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_frame_acquisition_sptr self) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_frame_acquisition_sptr self) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_frame_acquisition_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_frame_acquisition_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_frame_acquisition_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_acquisition_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_frame_acquisition_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_acquisition_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_frame_acquisition_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_frame_acquisition_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_frame_acquisition_sptr self) -> long"""
        return _digital_swig.ofdm_frame_acquisition_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_frame_acquisition_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_frame_acquisition_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_frame_acquisition_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_frame_acquisition_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_acquisition_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_frame_acquisition_sptr self, std::string name)"""
        return _digital_swig.ofdm_frame_acquisition_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_frame_acquisition_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_frame_acquisition_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_frame_acquisition_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_frame_acquisition_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_frame_acquisition_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_acquisition_sptr_message_subscribers(self, *args, **kwargs)

ofdm_frame_acquisition_sptr_swigregister = _digital_swig.ofdm_frame_acquisition_sptr_swigregister
ofdm_frame_acquisition_sptr_swigregister(ofdm_frame_acquisition_sptr)

ofdm_frame_acquisition_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_frame_acquisition = ofdm_frame_acquisition.make;

class ofdm_frame_equalizer_vcvc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_frame_equalizer_vcvc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_equalizer_vcvc)> self) -> ofdm_frame_equalizer_vcvc_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_equalizer_vcvc)> self, ofdm_frame_equalizer_vcvc p) -> ofdm_frame_equalizer_vcvc_sptr
        """
        this = _digital_swig.new_ofdm_frame_equalizer_vcvc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_frame_equalizer_vcvc_sptr self) -> ofdm_frame_equalizer_vcvc"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_frame_equalizer_vcvc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_frame_equalizer_vcvc_sptr self, ofdm_equalizer_base_sptr equalizer, int cp_len, std::string const & len_tag_key="frame_len", 
            bool propagate_channel_state=False, int fixed_frame_len=0) -> ofdm_frame_equalizer_vcvc_sptr

        OFDM frame equalizer.

        Performs equalization in one or two dimensions on a tagged OFDM frame.

        This does two things: First, it removes the coarse carrier offset. If a tag is found on the first item with the key 'ofdm_sync_carr_offset', this is interpreted as the coarse frequency offset in number of carriers. Next, it performs equalization in one or two dimensions on a tagged OFDM frame. The actual equalization is done by a ofdm_frame_equalizer object, outside of the block.

        Note that the tag with the coarse carrier offset is not removed. Blocks downstream from this block must not attempt to also correct this offset.

        Input: a tagged series of OFDM symbols. Output: The same as the input, but equalized and frequency-corrected.

        Constructor Specific Documentation:



        Args:
            equalizer : The equalizer object that will do the actual work
            cp_len : Length of the cyclic prefix in samples (required to correct the frequency offset)
            len_tag_key : Length tag key
            propagate_channel_state : If true, the channel state after the last symbol will be added to the first symbol as a tag
            fixed_frame_len : Set if the frame length is fixed throughout, helps with book keeping.
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_frame_equalizer_vcvc_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_frame_equalizer_vcvc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_frame_equalizer_vcvc_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_frame_equalizer_vcvc_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_frame_equalizer_vcvc_sptr self) -> double"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_start(self)

    def stop(self):
        """stop(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_frame_equalizer_vcvc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_frame_equalizer_vcvc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self, int m)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_frame_equalizer_vcvc_sptr self, int m)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_frame_equalizer_vcvc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_frame_equalizer_vcvc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_frame_equalizer_vcvc_sptr self) -> float"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_frame_equalizer_vcvc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_frame_equalizer_vcvc_sptr self)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_frame_equalizer_vcvc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_frame_equalizer_vcvc_sptr self) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_frame_equalizer_vcvc_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_frame_equalizer_vcvc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_frame_equalizer_vcvc_sptr self) -> long"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_frame_equalizer_vcvc_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_frame_equalizer_vcvc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_frame_equalizer_vcvc_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_frame_equalizer_vcvc_sptr self, std::string name)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_frame_equalizer_vcvc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_frame_equalizer_vcvc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_equalizer_vcvc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_frame_equalizer_vcvc_sptr_swigregister = _digital_swig.ofdm_frame_equalizer_vcvc_sptr_swigregister
ofdm_frame_equalizer_vcvc_sptr_swigregister(ofdm_frame_equalizer_vcvc_sptr)

ofdm_frame_equalizer_vcvc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_frame_equalizer_vcvc = ofdm_frame_equalizer_vcvc.make;

class ofdm_frame_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_frame_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_sink)> self) -> ofdm_frame_sink_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_frame_sink)> self, ofdm_frame_sink p) -> ofdm_frame_sink_sptr
        """
        this = _digital_swig.new_ofdm_frame_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_frame_sink_sptr self) -> ofdm_frame_sink"""
        return _digital_swig.ofdm_frame_sink_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_frame_sink_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_frame_sink_sptr self, pmt_vector_cfloat sym_position, std::vector< char,std::allocator< char > > const & sym_value_out, 
            msg_queue_sptr target_queue, int occupied_tones, float phase_gain=0.25, 
            float freq_gain=0.25*0.25/4) -> ofdm_frame_sink_sptr

        Takes an OFDM symbol in, demaps it into bits of 0's and 1's, packs them into packets, and sends to to a message queue sink.

        NOTE: The mod input parameter simply chooses a pre-defined demapper/slicer. Eventually, we want to be able to pass in a reference to an object to do the demapping and slicing for a given modulation type.

        Constructor Specific Documentation:

        Make an OFDM frame sink block.

        Args:
            sym_position : vector of OFDM carrier symbols in complex space
            sym_value_out : vector of bit mapped from the complex symbol space
            target_queue : message queue for the packets to go into
            occupied_tones : The number of subcarriers with data in the received symbol
            phase_gain : gain of the phase tracking loop
            freq_gain : gain of the frequency tracking loop
        """
        return _digital_swig.ofdm_frame_sink_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_frame_sink_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_frame_sink_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_frame_sink_sptr self, int which, int delay)
        declare_sample_delay(ofdm_frame_sink_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_frame_sink_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_frame_sink_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_frame_sink_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_frame_sink_sptr self) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_frame_sink_sptr self) -> double"""
        return _digital_swig.ofdm_frame_sink_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_frame_sink_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_sink_sptr_start(self)

    def stop(self):
        """stop(ofdm_frame_sink_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_frame_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_frame_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_frame_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_frame_sink_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_frame_sink_sptr self) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_frame_sink_sptr self, int m)"""
        return _digital_swig.ofdm_frame_sink_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_frame_sink_sptr self)"""
        return _digital_swig.ofdm_frame_sink_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_frame_sink_sptr self) -> bool"""
        return _digital_swig.ofdm_frame_sink_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_frame_sink_sptr self, int m)"""
        return _digital_swig.ofdm_frame_sink_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_frame_sink_sptr self) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_frame_sink_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_sink_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_frame_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_frame_sink_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_frame_sink_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_frame_sink_sptr self, int i) -> long"""
        return _digital_swig.ofdm_frame_sink_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_frame_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_frame_sink_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_frame_sink_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_frame_sink_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_frame_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_frame_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_frame_sink_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_frame_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_frame_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_frame_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_frame_sink_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_frame_sink_sptr self) -> float"""
        return _digital_swig.ofdm_frame_sink_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_frame_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_frame_sink_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_frame_sink_sptr self)"""
        return _digital_swig.ofdm_frame_sink_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_frame_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_frame_sink_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_frame_sink_sptr self) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_frame_sink_sptr self) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_frame_sink_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_frame_sink_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_frame_sink_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_sink_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_frame_sink_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_sink_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_frame_sink_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_frame_sink_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_frame_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_frame_sink_sptr self) -> long"""
        return _digital_swig.ofdm_frame_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_frame_sink_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_frame_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_frame_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_frame_sink_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_frame_sink_sptr self) -> std::string"""
        return _digital_swig.ofdm_frame_sink_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_frame_sink_sptr self, std::string name)"""
        return _digital_swig.ofdm_frame_sink_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_frame_sink_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_frame_sink_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_frame_sink_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_sink_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_frame_sink_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_sink_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_frame_sink_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_frame_sink_sptr_message_subscribers(self, *args, **kwargs)

ofdm_frame_sink_sptr_swigregister = _digital_swig.ofdm_frame_sink_sptr_swigregister
ofdm_frame_sink_sptr_swigregister(ofdm_frame_sink_sptr)

ofdm_frame_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_frame_sink = ofdm_frame_sink.make;

class ofdm_insert_preamble_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_insert_preamble)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_insert_preamble)> self) -> ofdm_insert_preamble_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_insert_preamble)> self, ofdm_insert_preamble p) -> ofdm_insert_preamble_sptr
        """
        this = _digital_swig.new_ofdm_insert_preamble_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_insert_preamble_sptr self) -> ofdm_insert_preamble"""
        return _digital_swig.ofdm_insert_preamble_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_insert_preamble_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_insert_preamble_sptr self, int fft_length, gr_vector_vector_complexf preamble) -> ofdm_insert_preamble_sptr

        insert "pre-modulated" preamble symbols before each payload.

        Constructor Specific Documentation:

        Make an OFDM preamble inserter block.

        Args:
            fft_length : length of each symbol in samples.
            preamble : vector of symbols that represent the pre-modulated preamble.
        """
        return _digital_swig.ofdm_insert_preamble_sptr_make(self, *args, **kwargs)

    def enter_preamble(self):
        """enter_preamble(ofdm_insert_preamble_sptr self)"""
        return _digital_swig.ofdm_insert_preamble_sptr_enter_preamble(self)

    def history(self):
        """history(ofdm_insert_preamble_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_insert_preamble_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_insert_preamble_sptr self, int which, int delay)
        declare_sample_delay(ofdm_insert_preamble_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_insert_preamble_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_insert_preamble_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_insert_preamble_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_insert_preamble_sptr self) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_insert_preamble_sptr self) -> double"""
        return _digital_swig.ofdm_insert_preamble_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_insert_preamble_sptr self) -> bool"""
        return _digital_swig.ofdm_insert_preamble_sptr_start(self)

    def stop(self):
        """stop(ofdm_insert_preamble_sptr self) -> bool"""
        return _digital_swig.ofdm_insert_preamble_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_insert_preamble_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_insert_preamble_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_insert_preamble_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_insert_preamble_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_insert_preamble_sptr self) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_insert_preamble_sptr self, int m)"""
        return _digital_swig.ofdm_insert_preamble_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_insert_preamble_sptr self)"""
        return _digital_swig.ofdm_insert_preamble_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_insert_preamble_sptr self) -> bool"""
        return _digital_swig.ofdm_insert_preamble_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_insert_preamble_sptr self, int m)"""
        return _digital_swig.ofdm_insert_preamble_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_insert_preamble_sptr self) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_insert_preamble_sptr self, int i) -> long"""
        return _digital_swig.ofdm_insert_preamble_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_insert_preamble_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_insert_preamble_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_insert_preamble_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_insert_preamble_sptr self, int i) -> long"""
        return _digital_swig.ofdm_insert_preamble_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_insert_preamble_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_insert_preamble_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_insert_preamble_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_insert_preamble_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_insert_preamble_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_insert_preamble_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_insert_preamble_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_insert_preamble_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_insert_preamble_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_insert_preamble_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_insert_preamble_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_insert_preamble_sptr self) -> float"""
        return _digital_swig.ofdm_insert_preamble_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_insert_preamble_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_insert_preamble_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_insert_preamble_sptr self)"""
        return _digital_swig.ofdm_insert_preamble_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_insert_preamble_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_insert_preamble_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_insert_preamble_sptr self) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_insert_preamble_sptr self) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_insert_preamble_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_insert_preamble_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_insert_preamble_sptr self) -> std::string"""
        return _digital_swig.ofdm_insert_preamble_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_insert_preamble_sptr self) -> std::string"""
        return _digital_swig.ofdm_insert_preamble_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_insert_preamble_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_insert_preamble_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_insert_preamble_sptr self) -> long"""
        return _digital_swig.ofdm_insert_preamble_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_insert_preamble_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_insert_preamble_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_insert_preamble_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_insert_preamble_sptr self) -> std::string"""
        return _digital_swig.ofdm_insert_preamble_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_insert_preamble_sptr self, std::string name)"""
        return _digital_swig.ofdm_insert_preamble_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_insert_preamble_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_insert_preamble_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_insert_preamble_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_insert_preamble_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_insert_preamble_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_insert_preamble_sptr_message_subscribers(self, *args, **kwargs)

ofdm_insert_preamble_sptr_swigregister = _digital_swig.ofdm_insert_preamble_sptr_swigregister
ofdm_insert_preamble_sptr_swigregister(ofdm_insert_preamble_sptr)

ofdm_insert_preamble_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_insert_preamble = ofdm_insert_preamble.make;

class ofdm_mapper_bcv_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_mapper_bcv)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_mapper_bcv)> self) -> ofdm_mapper_bcv_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_mapper_bcv)> self, ofdm_mapper_bcv p) -> ofdm_mapper_bcv_sptr
        """
        this = _digital_swig.new_ofdm_mapper_bcv_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_mapper_bcv_sptr self) -> ofdm_mapper_bcv"""
        return _digital_swig.ofdm_mapper_bcv_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_mapper_bcv_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_mapper_bcv_sptr self, pmt_vector_cfloat constellation, unsigned int msgq_limit, unsigned int occupied_carriers, 
            unsigned int fft_length) -> ofdm_mapper_bcv_sptr

        take a stream of bytes in and map to a vector of complex constellation points suitable for IFFT input to be used in an ofdm modulator.

        Abstract class must be subclassed with specific mapping.

        Constructor Specific Documentation:

        Make an OFDM mapper block.

        Args:
            constellation : vector of OFDM carrier symbols in complex space
            msgq_limit : limit on number of messages the queue can store
            occupied_carriers : The number of subcarriers with data in the received symbol
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_make(self, *args, **kwargs)

    def msgq(self):
        """msgq(ofdm_mapper_bcv_sptr self) -> msg_queue_sptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_msgq(self)

    def history(self):
        """history(ofdm_mapper_bcv_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_mapper_bcv_sptr self, int which, int delay)
        declare_sample_delay(ofdm_mapper_bcv_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_mapper_bcv_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_mapper_bcv_sptr self) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_mapper_bcv_sptr self) -> double"""
        return _digital_swig.ofdm_mapper_bcv_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_mapper_bcv_sptr self) -> bool"""
        return _digital_swig.ofdm_mapper_bcv_sptr_start(self)

    def stop(self):
        """stop(ofdm_mapper_bcv_sptr self) -> bool"""
        return _digital_swig.ofdm_mapper_bcv_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_mapper_bcv_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_mapper_bcv_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_mapper_bcv_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_mapper_bcv_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_mapper_bcv_sptr self) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_mapper_bcv_sptr self, int m)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_mapper_bcv_sptr self)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_mapper_bcv_sptr self) -> bool"""
        return _digital_swig.ofdm_mapper_bcv_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_mapper_bcv_sptr self, int m)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_mapper_bcv_sptr self) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_mapper_bcv_sptr self, int i) -> long"""
        return _digital_swig.ofdm_mapper_bcv_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_mapper_bcv_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_mapper_bcv_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_mapper_bcv_sptr self, int i) -> long"""
        return _digital_swig.ofdm_mapper_bcv_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_mapper_bcv_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_mapper_bcv_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_mapper_bcv_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_mapper_bcv_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_mapper_bcv_sptr self) -> float"""
        return _digital_swig.ofdm_mapper_bcv_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_mapper_bcv_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_mapper_bcv_sptr self)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_mapper_bcv_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_mapper_bcv_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_mapper_bcv_sptr self) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_mapper_bcv_sptr self) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_mapper_bcv_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_mapper_bcv_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_mapper_bcv_sptr self) -> std::string"""
        return _digital_swig.ofdm_mapper_bcv_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_mapper_bcv_sptr self) -> std::string"""
        return _digital_swig.ofdm_mapper_bcv_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_mapper_bcv_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_mapper_bcv_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_mapper_bcv_sptr self) -> long"""
        return _digital_swig.ofdm_mapper_bcv_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_mapper_bcv_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_mapper_bcv_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_mapper_bcv_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_mapper_bcv_sptr self) -> std::string"""
        return _digital_swig.ofdm_mapper_bcv_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_mapper_bcv_sptr self, std::string name)"""
        return _digital_swig.ofdm_mapper_bcv_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_mapper_bcv_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_mapper_bcv_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_mapper_bcv_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_mapper_bcv_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_mapper_bcv_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_mapper_bcv_sptr_message_subscribers(self, *args, **kwargs)

ofdm_mapper_bcv_sptr_swigregister = _digital_swig.ofdm_mapper_bcv_sptr_swigregister
ofdm_mapper_bcv_sptr_swigregister(ofdm_mapper_bcv_sptr)

ofdm_mapper_bcv_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_mapper_bcv = ofdm_mapper_bcv.make;

class ofdm_sampler_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_sampler)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_sampler)> self) -> ofdm_sampler_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_sampler)> self, ofdm_sampler p) -> ofdm_sampler_sptr
        """
        this = _digital_swig.new_ofdm_sampler_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_sampler_sptr self) -> ofdm_sampler"""
        return _digital_swig.ofdm_sampler_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_sampler_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_sampler_sptr self, unsigned int fft_length, unsigned int symbol_length, unsigned int timeout=1000) -> ofdm_sampler_sptr

        does the rest of the OFDM stuff

        Constructor Specific Documentation:

        Make an OFDM sampler block.

        Args:
            fft_length : The size of the FFT vector (occupied_carriers + unused carriers)
            symbol_length : Length of the full symbol (fft_length + CP length)
            timeout : timeout in samples when we stop looking for a symbol after initial ack.
        """
        return _digital_swig.ofdm_sampler_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ofdm_sampler_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_sampler_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_sampler_sptr self, int which, int delay)
        declare_sample_delay(ofdm_sampler_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_sampler_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_sampler_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_sampler_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_sampler_sptr self) -> int"""
        return _digital_swig.ofdm_sampler_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_sampler_sptr self) -> double"""
        return _digital_swig.ofdm_sampler_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_sampler_sptr self) -> bool"""
        return _digital_swig.ofdm_sampler_sptr_start(self)

    def stop(self):
        """stop(ofdm_sampler_sptr self) -> bool"""
        return _digital_swig.ofdm_sampler_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_sampler_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_sampler_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_sampler_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_sampler_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_sampler_sptr self) -> int"""
        return _digital_swig.ofdm_sampler_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_sampler_sptr self, int m)"""
        return _digital_swig.ofdm_sampler_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_sampler_sptr self)"""
        return _digital_swig.ofdm_sampler_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_sampler_sptr self) -> bool"""
        return _digital_swig.ofdm_sampler_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_sampler_sptr self, int m)"""
        return _digital_swig.ofdm_sampler_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_sampler_sptr self) -> int"""
        return _digital_swig.ofdm_sampler_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_sampler_sptr self, int i) -> long"""
        return _digital_swig.ofdm_sampler_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_sampler_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_sampler_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_sampler_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_sampler_sptr self, int i) -> long"""
        return _digital_swig.ofdm_sampler_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_sampler_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_sampler_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_sampler_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_sampler_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_sampler_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_sampler_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_sampler_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_sampler_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_sampler_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_sampler_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_sampler_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_sampler_sptr self) -> float"""
        return _digital_swig.ofdm_sampler_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_sampler_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_sampler_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_sampler_sptr self)"""
        return _digital_swig.ofdm_sampler_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_sampler_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_sampler_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_sampler_sptr self) -> int"""
        return _digital_swig.ofdm_sampler_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_sampler_sptr self) -> int"""
        return _digital_swig.ofdm_sampler_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_sampler_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_sampler_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_sampler_sptr self) -> std::string"""
        return _digital_swig.ofdm_sampler_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_sampler_sptr self) -> std::string"""
        return _digital_swig.ofdm_sampler_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_sampler_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_sampler_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_sampler_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_sampler_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_sampler_sptr self) -> long"""
        return _digital_swig.ofdm_sampler_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_sampler_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_sampler_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_sampler_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_sampler_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_sampler_sptr self) -> std::string"""
        return _digital_swig.ofdm_sampler_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_sampler_sptr self, std::string name)"""
        return _digital_swig.ofdm_sampler_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_sampler_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_sampler_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_sampler_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_sampler_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_sampler_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_sampler_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_sampler_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_sampler_sptr_message_subscribers(self, *args, **kwargs)

ofdm_sampler_sptr_swigregister = _digital_swig.ofdm_sampler_sptr_swigregister
ofdm_sampler_sptr_swigregister(ofdm_sampler_sptr)

ofdm_sampler_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_sampler = ofdm_sampler.make;

class ofdm_serializer_vcc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_serializer_vcc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_serializer_vcc)> self) -> ofdm_serializer_vcc_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_serializer_vcc)> self, ofdm_serializer_vcc p) -> ofdm_serializer_vcc_sptr
        """
        this = _digital_swig.new_ofdm_serializer_vcc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_serializer_vcc_sptr self) -> ofdm_serializer_vcc"""
        return _digital_swig.ofdm_serializer_vcc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_serializer_vcc_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(ofdm_serializer_vcc_sptr self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            std::string const & len_tag_key="frame_len", 
            std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", 
            bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr
        make(ofdm_serializer_vcc_sptr self, ofdm_carrier_allocator_cvc_sptr allocator, std::string const & packet_len_tag_key="", 
            int symbols_skipped=0, std::string const & carr_offset_key="", bool input_is_shifted=True) -> ofdm_serializer_vcc_sptr

        Serializes complex modulations symbols from OFDM sub-carriers.

        This is the inverse block to the carrier_allocator_cvc. It outputs the complex data symbols as a tagged stream, discarding the pilot symbols.

        If given, two different tags are parsed: The first key () specifies the number of OFDM symbols in the frame at the input. The second key () specifies the number of complex symbols that are coded into this frame. If given, this second key is then used at the output, otherwise,  is used. If both are given, the packet length specifies the maximum number of output items, and the frame length specifies the exact number of consumed input items.

        It is possible to correct a carrier offset in this function by passing another tag with said offset.

        Input: Complex vectors of length  Output: Complex scalars, in the same order as specified in occupied_carriers.

        Constructor Specific Documentation:



        Args:
            fft_len : FFT length
            occupied_carriers : See ofdm_carrier_allocator_cvc.
            len_tag_key : The key of the tag identifying the length of the input frame in OFDM symbols.
            packet_len_tag_key : The key of the tag identifying the number of complex symbols in this packet.
            symbols_skipped : If the first symbol is not allocated as in [0], set this
            carr_offset_key : When this block should correct a carrier offset, specify the tag key of the offset here (not necessary if following an ofdm_frame_equalizer_vcvc)
            input_is_shifted : If the input has the DC carrier on index 0 (i.e. it is not FFT shifted), set this to false
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_make(self, *args)

    def history(self):
        """history(ofdm_serializer_vcc_sptr self) -> unsigned int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ofdm_serializer_vcc_sptr self, int which, int delay)
        declare_sample_delay(ofdm_serializer_vcc_sptr self, unsigned int delay)
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ofdm_serializer_vcc_sptr self, int which) -> unsigned int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ofdm_serializer_vcc_sptr self) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ofdm_serializer_vcc_sptr self) -> double"""
        return _digital_swig.ofdm_serializer_vcc_sptr_relative_rate(self)

    def start(self):
        """start(ofdm_serializer_vcc_sptr self) -> bool"""
        return _digital_swig.ofdm_serializer_vcc_sptr_start(self)

    def stop(self):
        """stop(ofdm_serializer_vcc_sptr self) -> bool"""
        return _digital_swig.ofdm_serializer_vcc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ofdm_serializer_vcc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.ofdm_serializer_vcc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ofdm_serializer_vcc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.ofdm_serializer_vcc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ofdm_serializer_vcc_sptr self) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ofdm_serializer_vcc_sptr self, int m)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ofdm_serializer_vcc_sptr self)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ofdm_serializer_vcc_sptr self) -> bool"""
        return _digital_swig.ofdm_serializer_vcc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ofdm_serializer_vcc_sptr self, int m)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ofdm_serializer_vcc_sptr self) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ofdm_serializer_vcc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_serializer_vcc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ofdm_serializer_vcc_sptr self, long max_output_buffer)
        set_max_output_buffer(ofdm_serializer_vcc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ofdm_serializer_vcc_sptr self, int i) -> long"""
        return _digital_swig.ofdm_serializer_vcc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ofdm_serializer_vcc_sptr self, long min_output_buffer)
        set_min_output_buffer(ofdm_serializer_vcc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full_avg(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_input_buffers_full_var(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full_avg(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ofdm_serializer_vcc_sptr self, int which) -> float
        pc_output_buffers_full_var(ofdm_serializer_vcc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ofdm_serializer_vcc_sptr self) -> float"""
        return _digital_swig.ofdm_serializer_vcc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_serializer_vcc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_serializer_vcc_sptr self)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_serializer_vcc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_serializer_vcc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ofdm_serializer_vcc_sptr self) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ofdm_serializer_vcc_sptr self) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ofdm_serializer_vcc_sptr self, int priority) -> int"""
        return _digital_swig.ofdm_serializer_vcc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _digital_swig.ofdm_serializer_vcc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _digital_swig.ofdm_serializer_vcc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_serializer_vcc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_serializer_vcc_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_serializer_vcc_sptr self) -> long"""
        return _digital_swig.ofdm_serializer_vcc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_serializer_vcc_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_serializer_vcc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_serializer_vcc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_serializer_vcc_sptr self) -> std::string"""
        return _digital_swig.ofdm_serializer_vcc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_serializer_vcc_sptr self, std::string name)"""
        return _digital_swig.ofdm_serializer_vcc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_serializer_vcc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_serializer_vcc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_serializer_vcc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_serializer_vcc_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_serializer_vcc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_serializer_vcc_sptr_message_subscribers(self, *args, **kwargs)

ofdm_serializer_vcc_sptr_swigregister = _digital_swig.ofdm_serializer_vcc_sptr_swigregister
ofdm_serializer_vcc_sptr_swigregister(ofdm_serializer_vcc_sptr)

ofdm_serializer_vcc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_serializer_vcc = ofdm_serializer_vcc.make;

class ofdm_sync_sc_cfb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_sync_sc_cfb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_sync_sc_cfb)> self) -> ofdm_sync_sc_cfb_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_sync_sc_cfb)> self, ofdm_sync_sc_cfb p) -> ofdm_sync_sc_cfb_sptr
        """
        this = _digital_swig.new_ofdm_sync_sc_cfb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_sync_sc_cfb_sptr self) -> ofdm_sync_sc_cfb"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_sync_sc_cfb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_sync_sc_cfb_sptr self, int fft_len, int cp_len, bool use_even_carriers=False) -> ofdm_sync_sc_cfb_sptr

        Schmidl & Cox synchronisation for OFDM.

        Input: complex samples. Output 0: Fine frequency offset, scaled by the OFDM symbol duration. This is  in [1]. The normalized frequency offset is then 2.0*output0/fft_len. Output 1: Beginning of the first OFDM symbol after the first (doubled) OFDM symbol. The beginning is marked with a 1 (it's 0 everywhere else).

        The evaluation of the coarse frequency offset is  done in this block. Also, the initial equalizer taps are not calculated here.

        Note that we use a different normalization factor in the timing metric than the authors do in their original work[1]. If the timing metric (8) is  we calculate the normalization as  i.e., we estimate the energy from  half-symbols. This avoids spurious detects at the end of a burst, when the energy level suddenly drops.

        [1] Schmidl, T.M. and Cox, D.C., "Robust frequency and timing synchronization for OFDM", Communications, IEEE Transactions on, 1997.

        Constructor Specific Documentation:



        Args:
            fft_len : FFT length
            cp_len : Length of the guard interval (cyclic prefix) in samples
            use_even_carriers : If true, the carriers in the sync preamble are occupied such that the even carriers are used (0, 2, 4, ...). If you use all carriers, that would include the DC carrier, so be careful.
        """
        return _digital_swig.ofdm_sync_sc_cfb_sptr_make(self, *args, **kwargs)

    def primitive_connect(self, *args):
        """
        primitive_connect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr block)
        primitive_connect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr block)
        primitive_disconnect(ofdm_sync_sc_cfb_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(ofdm_sync_sc_cfb_sptr self)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_disconnect_all(self)

    def lock(self):
        """lock(ofdm_sync_sc_cfb_sptr self)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_lock(self)

    def unlock(self):
        """unlock(ofdm_sync_sc_cfb_sptr self)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(ofdm_sync_sc_cfb_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(ofdm_sync_sc_cfb_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ofdm_sync_sc_cfb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ofdm_sync_sc_cfb_sptr self)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ofdm_sync_sc_cfb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(ofdm_sync_sc_cfb_sptr self) -> hier_block2_sptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_to_hier_block2(self)

    def name(self):
        """name(ofdm_sync_sc_cfb_sptr self) -> std::string"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ofdm_sync_sc_cfb_sptr self) -> std::string"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ofdm_sync_sc_cfb_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ofdm_sync_sc_cfb_sptr self) -> io_signature_sptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ofdm_sync_sc_cfb_sptr self) -> long"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ofdm_sync_sc_cfb_sptr self) -> basic_block_sptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ofdm_sync_sc_cfb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ofdm_sync_sc_cfb_sptr self) -> std::string"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ofdm_sync_sc_cfb_sptr self, std::string name)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ofdm_sync_sc_cfb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ofdm_sync_sc_cfb_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ofdm_sync_sc_cfb_sptr self) -> swig_int_ptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ofdm_sync_sc_cfb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.ofdm_sync_sc_cfb_sptr_message_subscribers(self, *args, **kwargs)

ofdm_sync_sc_cfb_sptr_swigregister = _digital_swig.ofdm_sync_sc_cfb_sptr_swigregister
ofdm_sync_sc_cfb_sptr_swigregister(ofdm_sync_sc_cfb_sptr)

ofdm_sync_sc_cfb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ofdm_sync_sc_cfb = ofdm_sync_sc_cfb.make;

class packet_headergenerator_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::packet_headergenerator_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::packet_headergenerator_bb)> self) -> packet_headergenerator_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::packet_headergenerator_bb)> self, packet_headergenerator_bb p) -> packet_headergenerator_bb_sptr
        """
        this = _digital_swig.new_packet_headergenerator_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_headergenerator_bb_sptr self) -> packet_headergenerator_bb"""
        return _digital_swig.packet_headergenerator_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_packet_headergenerator_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(packet_headergenerator_bb_sptr self, packet_header_default_sptr header_formatter, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr
        make(packet_headergenerator_bb_sptr self, long header_len, std::string const & len_tag_key="packet_len") -> packet_headergenerator_bb_sptr

        Generates a header for a tagged, streamed packet.

        Input: A tagged stream. This is consumed entirely, it is not appended to the output stream. Output: An tagged stream containing the header. The details on the header are set in a header formatter object (of type packet_header_default or a subclass thereof). If only a number of bits is specified, a default header is generated (see packet_header_default).

        Constructor Specific Documentation:



        Args:
            header_formatter : 
            len_tag_key : 
        """
        return _digital_swig.packet_headergenerator_bb_sptr_make(self, *args)

    def history(self):
        """history(packet_headergenerator_bb_sptr self) -> unsigned int"""
        return _digital_swig.packet_headergenerator_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(packet_headergenerator_bb_sptr self, int which, int delay)
        declare_sample_delay(packet_headergenerator_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.packet_headergenerator_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(packet_headergenerator_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.packet_headergenerator_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(packet_headergenerator_bb_sptr self) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(packet_headergenerator_bb_sptr self) -> double"""
        return _digital_swig.packet_headergenerator_bb_sptr_relative_rate(self)

    def start(self):
        """start(packet_headergenerator_bb_sptr self) -> bool"""
        return _digital_swig.packet_headergenerator_bb_sptr_start(self)

    def stop(self):
        """stop(packet_headergenerator_bb_sptr self) -> bool"""
        return _digital_swig.packet_headergenerator_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(packet_headergenerator_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.packet_headergenerator_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(packet_headergenerator_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.packet_headergenerator_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(packet_headergenerator_bb_sptr self) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(packet_headergenerator_bb_sptr self, int m)"""
        return _digital_swig.packet_headergenerator_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(packet_headergenerator_bb_sptr self)"""
        return _digital_swig.packet_headergenerator_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(packet_headergenerator_bb_sptr self) -> bool"""
        return _digital_swig.packet_headergenerator_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(packet_headergenerator_bb_sptr self, int m)"""
        return _digital_swig.packet_headergenerator_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(packet_headergenerator_bb_sptr self) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(packet_headergenerator_bb_sptr self, int i) -> long"""
        return _digital_swig.packet_headergenerator_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(packet_headergenerator_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(packet_headergenerator_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.packet_headergenerator_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(packet_headergenerator_bb_sptr self, int i) -> long"""
        return _digital_swig.packet_headergenerator_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(packet_headergenerator_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(packet_headergenerator_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.packet_headergenerator_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(packet_headergenerator_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(packet_headergenerator_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(packet_headergenerator_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headergenerator_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(packet_headergenerator_bb_sptr self) -> float"""
        return _digital_swig.packet_headergenerator_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(packet_headergenerator_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.packet_headergenerator_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(packet_headergenerator_bb_sptr self)"""
        return _digital_swig.packet_headergenerator_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(packet_headergenerator_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.packet_headergenerator_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(packet_headergenerator_bb_sptr self) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(packet_headergenerator_bb_sptr self) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(packet_headergenerator_bb_sptr self, int priority) -> int"""
        return _digital_swig.packet_headergenerator_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(packet_headergenerator_bb_sptr self) -> std::string"""
        return _digital_swig.packet_headergenerator_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(packet_headergenerator_bb_sptr self) -> std::string"""
        return _digital_swig.packet_headergenerator_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(packet_headergenerator_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(packet_headergenerator_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(packet_headergenerator_bb_sptr self) -> long"""
        return _digital_swig.packet_headergenerator_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(packet_headergenerator_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(packet_headergenerator_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.packet_headergenerator_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(packet_headergenerator_bb_sptr self) -> std::string"""
        return _digital_swig.packet_headergenerator_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(packet_headergenerator_bb_sptr self, std::string name)"""
        return _digital_swig.packet_headergenerator_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(packet_headergenerator_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.packet_headergenerator_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(packet_headergenerator_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(packet_headergenerator_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(packet_headergenerator_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.packet_headergenerator_bb_sptr_message_subscribers(self, *args, **kwargs)

packet_headergenerator_bb_sptr_swigregister = _digital_swig.packet_headergenerator_bb_sptr_swigregister
packet_headergenerator_bb_sptr_swigregister(packet_headergenerator_bb_sptr)

packet_headergenerator_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
packet_headergenerator_bb = packet_headergenerator_bb.make;

class packet_headerparser_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::packet_headerparser_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::packet_headerparser_b)> self) -> packet_headerparser_b_sptr
        __init__(boost::shared_ptr<(gr::digital::packet_headerparser_b)> self, packet_headerparser_b p) -> packet_headerparser_b_sptr
        """
        this = _digital_swig.new_packet_headerparser_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_headerparser_b_sptr self) -> packet_headerparser_b"""
        return _digital_swig.packet_headerparser_b_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_packet_headerparser_b_sptr
    __del__ = lambda self : None;
    def make(self, *args):
        """
        make(packet_headerparser_b_sptr self, packet_header_default_sptr header_formatter) -> packet_headerparser_b_sptr
        make(packet_headerparser_b_sptr self, long header_len, std::string const & len_tag_key) -> packet_headerparser_b_sptr

        Post header metadata as a PMT.

        In a sense, this is the inverse block to packet_headergenerator_bb. The difference is, the parsed header is not output as a stream, but as a PMT dictionary, which is published to message port with the id "header_data".

        The dictionary consists of the tags created by the header formatter object. You should be able to use the exact same formatter object as used on the Tx side in the packet_headergenerator_bb.

        If only a header length is given, this block uses the default header format.

        Constructor Specific Documentation:



        Args:
            header_formatter : Header object. This should be the same as used for packet_headergenerator_bb.
        """
        return _digital_swig.packet_headerparser_b_sptr_make(self, *args)

    def history(self):
        """history(packet_headerparser_b_sptr self) -> unsigned int"""
        return _digital_swig.packet_headerparser_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(packet_headerparser_b_sptr self, int which, int delay)
        declare_sample_delay(packet_headerparser_b_sptr self, unsigned int delay)
        """
        return _digital_swig.packet_headerparser_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(packet_headerparser_b_sptr self, int which) -> unsigned int"""
        return _digital_swig.packet_headerparser_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(packet_headerparser_b_sptr self) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(packet_headerparser_b_sptr self) -> double"""
        return _digital_swig.packet_headerparser_b_sptr_relative_rate(self)

    def start(self):
        """start(packet_headerparser_b_sptr self) -> bool"""
        return _digital_swig.packet_headerparser_b_sptr_start(self)

    def stop(self):
        """stop(packet_headerparser_b_sptr self) -> bool"""
        return _digital_swig.packet_headerparser_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(packet_headerparser_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.packet_headerparser_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(packet_headerparser_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.packet_headerparser_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(packet_headerparser_b_sptr self) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(packet_headerparser_b_sptr self, int m)"""
        return _digital_swig.packet_headerparser_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(packet_headerparser_b_sptr self)"""
        return _digital_swig.packet_headerparser_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(packet_headerparser_b_sptr self) -> bool"""
        return _digital_swig.packet_headerparser_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(packet_headerparser_b_sptr self, int m)"""
        return _digital_swig.packet_headerparser_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(packet_headerparser_b_sptr self) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(packet_headerparser_b_sptr self, int i) -> long"""
        return _digital_swig.packet_headerparser_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(packet_headerparser_b_sptr self, long max_output_buffer)
        set_max_output_buffer(packet_headerparser_b_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.packet_headerparser_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(packet_headerparser_b_sptr self, int i) -> long"""
        return _digital_swig.packet_headerparser_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(packet_headerparser_b_sptr self, long min_output_buffer)
        set_min_output_buffer(packet_headerparser_b_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.packet_headerparser_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(packet_headerparser_b_sptr self, int which) -> float
        pc_input_buffers_full_var(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(packet_headerparser_b_sptr self, int which) -> float
        pc_output_buffers_full_var(packet_headerparser_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_headerparser_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(packet_headerparser_b_sptr self) -> float"""
        return _digital_swig.packet_headerparser_b_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(packet_headerparser_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.packet_headerparser_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(packet_headerparser_b_sptr self)"""
        return _digital_swig.packet_headerparser_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(packet_headerparser_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.packet_headerparser_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(packet_headerparser_b_sptr self) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(packet_headerparser_b_sptr self) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(packet_headerparser_b_sptr self, int priority) -> int"""
        return _digital_swig.packet_headerparser_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(packet_headerparser_b_sptr self) -> std::string"""
        return _digital_swig.packet_headerparser_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(packet_headerparser_b_sptr self) -> std::string"""
        return _digital_swig.packet_headerparser_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(packet_headerparser_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_headerparser_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(packet_headerparser_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_headerparser_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(packet_headerparser_b_sptr self) -> long"""
        return _digital_swig.packet_headerparser_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(packet_headerparser_b_sptr self) -> basic_block_sptr"""
        return _digital_swig.packet_headerparser_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(packet_headerparser_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.packet_headerparser_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(packet_headerparser_b_sptr self) -> std::string"""
        return _digital_swig.packet_headerparser_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(packet_headerparser_b_sptr self, std::string name)"""
        return _digital_swig.packet_headerparser_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(packet_headerparser_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.packet_headerparser_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(packet_headerparser_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_headerparser_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(packet_headerparser_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_headerparser_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(packet_headerparser_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.packet_headerparser_b_sptr_message_subscribers(self, *args, **kwargs)

packet_headerparser_b_sptr_swigregister = _digital_swig.packet_headerparser_b_sptr_swigregister
packet_headerparser_b_sptr_swigregister(packet_headerparser_b_sptr)

packet_headerparser_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
packet_headerparser_b = packet_headerparser_b.make;

class packet_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::packet_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::packet_sink)> self) -> packet_sink_sptr
        __init__(boost::shared_ptr<(gr::digital::packet_sink)> self, packet_sink p) -> packet_sink_sptr
        """
        this = _digital_swig.new_packet_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_sink_sptr self) -> packet_sink"""
        return _digital_swig.packet_sink_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_packet_sink_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(packet_sink_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & sync_vector, 
            msg_queue_sptr target_queue, int threshold=-1) -> packet_sink_sptr

        process received bits looking for packet sync, header, and process bits into packet

        input: stream of symbols to be sliced.

        output: none. Pushes assembled packet into target queue

        The packet sink takes in a stream of binary symbols that are sliced around 0. The bits are then checked for the  to determine find and decode the packet. It then expects a fixed length header of 2 16-bit shorts containing the payload length, followed by the payload. If the 2 16-bit shorts are not identical, this packet is ignored. Better algs are welcome.

        This block is not very useful anymore as it only works with 2-level modulations such as BPSK or GMSK. The block can generally be replaced with a correlate access code and frame sink blocks.

        Constructor Specific Documentation:

        Make a packet_sink block.

        Args:
            sync_vector : The synchronization vector as a vector of 1's and 0's.
            target_queue : The message queue that packets are sent to.
            threshold : Number of bits that can be incorrect in the .
        """
        return _digital_swig.packet_sink_sptr_make(self, *args, **kwargs)

    def carrier_sensed(self):
        """
        carrier_sensed(packet_sink_sptr self) -> bool

        return true if we detect carrier
        """
        return _digital_swig.packet_sink_sptr_carrier_sensed(self)

    def history(self):
        """history(packet_sink_sptr self) -> unsigned int"""
        return _digital_swig.packet_sink_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(packet_sink_sptr self, int which, int delay)
        declare_sample_delay(packet_sink_sptr self, unsigned int delay)
        """
        return _digital_swig.packet_sink_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(packet_sink_sptr self, int which) -> unsigned int"""
        return _digital_swig.packet_sink_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(packet_sink_sptr self) -> int"""
        return _digital_swig.packet_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(packet_sink_sptr self) -> double"""
        return _digital_swig.packet_sink_sptr_relative_rate(self)

    def start(self):
        """start(packet_sink_sptr self) -> bool"""
        return _digital_swig.packet_sink_sptr_start(self)

    def stop(self):
        """stop(packet_sink_sptr self) -> bool"""
        return _digital_swig.packet_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(packet_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.packet_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(packet_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.packet_sink_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(packet_sink_sptr self) -> int"""
        return _digital_swig.packet_sink_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(packet_sink_sptr self, int m)"""
        return _digital_swig.packet_sink_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(packet_sink_sptr self)"""
        return _digital_swig.packet_sink_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(packet_sink_sptr self) -> bool"""
        return _digital_swig.packet_sink_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(packet_sink_sptr self, int m)"""
        return _digital_swig.packet_sink_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(packet_sink_sptr self) -> int"""
        return _digital_swig.packet_sink_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(packet_sink_sptr self, int i) -> long"""
        return _digital_swig.packet_sink_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(packet_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(packet_sink_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.packet_sink_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(packet_sink_sptr self, int i) -> long"""
        return _digital_swig.packet_sink_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(packet_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(packet_sink_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.packet_sink_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(packet_sink_sptr self, int which) -> float
        pc_input_buffers_full(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(packet_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(packet_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(packet_sink_sptr self, int which) -> float
        pc_output_buffers_full(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(packet_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(packet_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(packet_sink_sptr self) -> pmt_vector_float
        """
        return _digital_swig.packet_sink_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(packet_sink_sptr self) -> float"""
        return _digital_swig.packet_sink_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(packet_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.packet_sink_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(packet_sink_sptr self)"""
        return _digital_swig.packet_sink_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(packet_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.packet_sink_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(packet_sink_sptr self) -> int"""
        return _digital_swig.packet_sink_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(packet_sink_sptr self) -> int"""
        return _digital_swig.packet_sink_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(packet_sink_sptr self, int priority) -> int"""
        return _digital_swig.packet_sink_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(packet_sink_sptr self) -> std::string"""
        return _digital_swig.packet_sink_sptr_name(self)

    def symbol_name(self):
        """symbol_name(packet_sink_sptr self) -> std::string"""
        return _digital_swig.packet_sink_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(packet_sink_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(packet_sink_sptr self) -> io_signature_sptr"""
        return _digital_swig.packet_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(packet_sink_sptr self) -> long"""
        return _digital_swig.packet_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(packet_sink_sptr self) -> basic_block_sptr"""
        return _digital_swig.packet_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(packet_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.packet_sink_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(packet_sink_sptr self) -> std::string"""
        return _digital_swig.packet_sink_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(packet_sink_sptr self, std::string name)"""
        return _digital_swig.packet_sink_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(packet_sink_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.packet_sink_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(packet_sink_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_sink_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(packet_sink_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_sink_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(packet_sink_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.packet_sink_sptr_message_subscribers(self, *args, **kwargs)

packet_sink_sptr_swigregister = _digital_swig.packet_sink_sptr_swigregister
packet_sink_sptr_swigregister(packet_sink_sptr)

packet_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
packet_sink = packet_sink.make;

class pfb_clock_sync_ccf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::pfb_clock_sync_ccf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::pfb_clock_sync_ccf)> self) -> pfb_clock_sync_ccf_sptr
        __init__(boost::shared_ptr<(gr::digital::pfb_clock_sync_ccf)> self, pfb_clock_sync_ccf p) -> pfb_clock_sync_ccf_sptr
        """
        this = _digital_swig.new_pfb_clock_sync_ccf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_clock_sync_ccf_sptr self) -> pfb_clock_sync_ccf"""
        return _digital_swig.pfb_clock_sync_ccf_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_pfb_clock_sync_ccf_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_clock_sync_ccf_sptr self, double sps, float loop_bw, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
            float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_ccf_sptr

        Timing synchronizer using polyphase filterbanks.

        This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

        This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

        If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

        The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

        The block's parameters are:








        Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
        Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

        Constructor Specific Documentation:

        Build the polyphase filterbank timing synchronizer.

        Args:
            sps : (double) The number of samples per symbol in the incoming signal
            loop_bw : (float) The bandwidth of the control loop; set's alpha and beta.
            taps : (vector<int>) The filter taps.
            filter_size : (uint) The number of filters in the filterbank (default = 32).
            init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
            max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
            osps : (int) The number of output samples per symbol (default=1).
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_make(self, *args, **kwargs)

    def update_gains(self):
        """
        update_gains(pfb_clock_sync_ccf_sptr self)

        update the system gains from omega and eta

        This function updates the system gains based on the loop bandwidth and damping factor of the system. These two factors can be set separately through their own set functions.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_update_gains(self)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_clock_sync_ccf_sptr self, pmt_vector_float taps, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > & ourtaps, 
            std::vector< gr::filter::kernel::fir_filter_ccf *,std::allocator< gr::filter::kernel::fir_filter_ccf * > > & ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_clock_sync_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the matched filter
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_taps(self)

    def diff_taps(self):
        """
        diff_taps(pfb_clock_sync_ccf_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_diff_taps(self)

    def channel_taps(self, *args, **kwargs):
        """
        channel_taps(pfb_clock_sync_ccf_sptr self, int channel) -> pmt_vector_float

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_channel_taps(self, *args, **kwargs)

    def diff_channel_taps(self, *args, **kwargs):
        """
        diff_channel_taps(pfb_clock_sync_ccf_sptr self, int channel) -> pmt_vector_float

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_diff_channel_taps(self, *args, **kwargs)

    def taps_as_string(self):
        """
        taps_as_string(pfb_clock_sync_ccf_sptr self) -> std::string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_taps_as_string(self)

    def diff_taps_as_string(self):
        """
        diff_taps_as_string(pfb_clock_sync_ccf_sptr self) -> std::string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(pfb_clock_sync_ccf_sptr self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(pfb_clock_sync_ccf_sptr self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(pfb_clock_sync_ccf_sptr self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(pfb_clock_sync_ccf_sptr self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(pfb_clock_sync_ccf_sptr self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def loop_bandwidth(self):
        """
        loop_bandwidth(pfb_clock_sync_ccf_sptr self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_loop_bandwidth(self)

    def damping_factor(self):
        """
        damping_factor(pfb_clock_sync_ccf_sptr self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_damping_factor(self)

    def alpha(self):
        """
        alpha(pfb_clock_sync_ccf_sptr self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_alpha(self)

    def beta(self):
        """
        beta(pfb_clock_sync_ccf_sptr self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_beta(self)

    def clock_rate(self):
        """
        clock_rate(pfb_clock_sync_ccf_sptr self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_clock_rate(self)

    def error(self):
        """
        error(pfb_clock_sync_ccf_sptr self) -> float

        Returns the current error of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_error(self)

    def rate(self):
        """
        rate(pfb_clock_sync_ccf_sptr self) -> float

        Returns the current rate of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_rate(self)

    def phase(self):
        """
        phase(pfb_clock_sync_ccf_sptr self) -> float

        Returns the current phase arm of the control loop.
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_phase(self)

    def history(self):
        """history(pfb_clock_sync_ccf_sptr self) -> unsigned int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_clock_sync_ccf_sptr self, int which, int delay)
        declare_sample_delay(pfb_clock_sync_ccf_sptr self, unsigned int delay)
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_clock_sync_ccf_sptr self, int which) -> unsigned int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_clock_sync_ccf_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_clock_sync_ccf_sptr self) -> double"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_relative_rate(self)

    def start(self):
        """start(pfb_clock_sync_ccf_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_start(self)

    def stop(self):
        """stop(pfb_clock_sync_ccf_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_clock_sync_ccf_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_clock_sync_ccf_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_clock_sync_ccf_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_clock_sync_ccf_sptr self, int m)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_clock_sync_ccf_sptr self)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_clock_sync_ccf_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_clock_sync_ccf_sptr self, int m)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_clock_sync_ccf_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_clock_sync_ccf_sptr self, int i) -> long"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_clock_sync_ccf_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_clock_sync_ccf_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_clock_sync_ccf_sptr self, int i) -> long"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_clock_sync_ccf_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_clock_sync_ccf_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_input_buffers_full(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_output_buffers_full(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_clock_sync_ccf_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_clock_sync_ccf_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_clock_sync_ccf_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_clock_sync_ccf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_clock_sync_ccf_sptr self)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_clock_sync_ccf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_clock_sync_ccf_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_clock_sync_ccf_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_clock_sync_ccf_sptr self, int priority) -> int"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_clock_sync_ccf_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_clock_sync_ccf_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_clock_sync_ccf_sptr self) -> io_signature_sptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_clock_sync_ccf_sptr self) -> io_signature_sptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_clock_sync_ccf_sptr self) -> long"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_clock_sync_ccf_sptr self) -> basic_block_sptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_clock_sync_ccf_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_clock_sync_ccf_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_clock_sync_ccf_sptr self, std::string name)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_clock_sync_ccf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.pfb_clock_sync_ccf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_clock_sync_ccf_sptr self) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_clock_sync_ccf_sptr self) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_clock_sync_ccf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_ccf_sptr_message_subscribers(self, *args, **kwargs)

pfb_clock_sync_ccf_sptr_swigregister = _digital_swig.pfb_clock_sync_ccf_sptr_swigregister
pfb_clock_sync_ccf_sptr_swigregister(pfb_clock_sync_ccf_sptr)

pfb_clock_sync_ccf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_clock_sync_ccf = pfb_clock_sync_ccf.make;

class pfb_clock_sync_fff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::pfb_clock_sync_fff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::pfb_clock_sync_fff)> self) -> pfb_clock_sync_fff_sptr
        __init__(boost::shared_ptr<(gr::digital::pfb_clock_sync_fff)> self, pfb_clock_sync_fff p) -> pfb_clock_sync_fff_sptr
        """
        this = _digital_swig.new_pfb_clock_sync_fff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pfb_clock_sync_fff_sptr self) -> pfb_clock_sync_fff"""
        return _digital_swig.pfb_clock_sync_fff_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_pfb_clock_sync_fff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pfb_clock_sync_fff_sptr self, double sps, float gain, pmt_vector_float taps, unsigned int filter_size=32, float init_phase=0, 
            float max_rate_deviation=1.5, int osps=1) -> pfb_clock_sync_fff_sptr

        Timing synchronizer using polyphase filterbanks.

        This block performs timing synchronization for PAM signals by minimizing the derivative of the filtered signal, which in turn maximizes the SNR and minimizes ISI.

        This approach works by setting up two filterbanks; one filterbank contains the signal's pulse shaping matched filter (such as a root raised cosine filter), where each branch of the filterbank contains a different phase of the filter. The second filterbank contains the derivatives of the filters in the first filterbank. Thinking of this in the time domain, the first filterbank contains filters that have a sinc shape to them. We want to align the output signal to be sampled at exactly the peak of the sinc shape. The derivative of the sinc contains a zero at the maximum point of the sinc (sinc(0) = 1, sinc(0)' = 0). Furthermore, the region around the zero point is relatively linear. We make use of this fact to generate the error signal.

        If the signal out of the derivative filters is d_i[n] for the ith filter, and the output of the matched filter is x_i[n], we calculate the error as: e[n] = (Re{x_i[n]} * Re{d_i[n]} + Im{x_i[n]} * Im{d_i[n]}) / 2.0 This equation averages the error in the real and imaginary parts. There are two reasons we multiply by the signal itself. First, if the symbol could be positive or negative going, but we want the error term to always tell us to go in the same direction depending on which side of the zero point we are on. The sign of x_i[n] adjusts the error term to do this. Second, the magnitude of x_i[n] scales the error term depending on the symbol's amplitude, so larger signals give us a stronger error term because we have more confidence in that symbol's value. Using the magnitude of x_i[n] instead of just the sign is especially good for signals with low SNR.

        The error signal, e[n], gives us a value proportional to how far away from the zero point we are in the derivative signal. We want to drive this value to zero, so we set up a second order loop. We have two variables for this loop; d_k is the filter number in the filterbank we are on and d_rate is the rate which we travel through the filters in the steady state. That is, due to the natural clock differences between the transmitter and receiver, d_rate represents that difference and would traverse the filter phase paths to keep the receiver locked. Thinking of this as a second-order PLL, the d_rate is the frequency and d_k is the phase. So we update d_rate and d_k using the standard loop equations based on two error signals, d_alpha and d_beta. We have these two values set based on each other for a critically damped system, so in the block constructor, we just ask for "gain," which is d_alpha while d_beta is equal to (gain^2)/4.

        The block's parameters are:








        Reference: f. j. harris and M. Rice, "Multirate Digital Filters for Symbol
        Timing Synchronization in Software Defined Radios", IEEE Selected Areas in Communications, Vol. 19, No. 12, Dec., 2001.

        Constructor Specific Documentation:

        Build the polyphase filterbank timing synchronizer.

        Args:
            sps : (double) The number of samples per second in the incoming signal
            gain : (float) The alpha gain of the control loop; beta = (gain^2)/4 by default.
            taps : (vector<int>) The filter taps.
            filter_size : (uint) The number of filters in the filterbank (default = 32).
            init_phase : (float) The initial phase to look at, or which filter to start with (default = 0).
            max_rate_deviation : (float) Distance from 0 d_rate can get (default = 1.5).
            osps : (int) The number of output samples per symbol (default=1).
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_make(self, *args, **kwargs)

    def update_gains(self):
        """
        update_gains(pfb_clock_sync_fff_sptr self)

        update the system gains from omega and eta

        This function updates the system gains based on the loop bandwidth and damping factor of the system. These two factors can be set separately through their own set functions.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_update_gains(self)

    def set_taps(self, *args, **kwargs):
        """
        set_taps(pfb_clock_sync_fff_sptr self, pmt_vector_float taps, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > & ourtaps, 
            std::vector< gr::filter::kernel::fir_filter_fff *,std::allocator< gr::filter::kernel::fir_filter_fff * > > & ourfilter)

        Resets the filterbank's filter taps with the new prototype filter
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_taps(self, *args, **kwargs)

    def taps(self):
        """
        taps(pfb_clock_sync_fff_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the matched filter
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_taps(self)

    def diff_taps(self):
        """
        diff_taps(pfb_clock_sync_fff_sptr self) -> std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > >

        Returns all of the taps of the derivative filter
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_diff_taps(self)

    def channel_taps(self, *args, **kwargs):
        """
        channel_taps(pfb_clock_sync_fff_sptr self, int channel) -> pmt_vector_float

        Returns the taps of the matched filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_channel_taps(self, *args, **kwargs)

    def diff_channel_taps(self, *args, **kwargs):
        """
        diff_channel_taps(pfb_clock_sync_fff_sptr self, int channel) -> pmt_vector_float

        Returns the taps in the derivative filter for a particular channel
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_diff_channel_taps(self, *args, **kwargs)

    def taps_as_string(self):
        """
        taps_as_string(pfb_clock_sync_fff_sptr self) -> std::string

        Return the taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_taps_as_string(self)

    def diff_taps_as_string(self):
        """
        diff_taps_as_string(pfb_clock_sync_fff_sptr self) -> std::string

        Return the derivative filter taps as a formatted string for printing
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_diff_taps_as_string(self)

    def set_loop_bandwidth(self, *args, **kwargs):
        """
        set_loop_bandwidth(pfb_clock_sync_fff_sptr self, float bw)

        Set the loop bandwidth.

        Set the loop filter's bandwidth to . This should be between 2*pi/200 and 2*pi/100 (in rads/samp). It must also be a positive number.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_loop_bandwidth(self, *args, **kwargs)

    def set_damping_factor(self, *args, **kwargs):
        """
        set_damping_factor(pfb_clock_sync_fff_sptr self, float df)

        Set the loop damping factor.

        Set the loop filter's damping factor to . The damping factor should be sqrt(2)/2.0 for critically damped systems. Set it to anything else only if you know what you are doing. It must be a number between 0 and 1.

        When a new damping factor is set, the gains, alpha and beta, of the loop are recalculated by a call to update_gains().
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_damping_factor(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(pfb_clock_sync_fff_sptr self, float alpha)

        Set the loop gain alpha.

        Set's the loop filter's alpha gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_alpha(self, *args, **kwargs)

    def set_beta(self, *args, **kwargs):
        """
        set_beta(pfb_clock_sync_fff_sptr self, float beta)

        Set the loop gain beta.

        Set's the loop filter's beta gain parameter.

        This value should really only be set by adjusting the loop bandwidth and damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_beta(self, *args, **kwargs)

    def set_max_rate_deviation(self, *args, **kwargs):
        """
        set_max_rate_deviation(pfb_clock_sync_fff_sptr self, float m)

        Set the maximum deviation from 0 d_rate can have
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_max_rate_deviation(self, *args, **kwargs)

    def loop_bandwidth(self):
        """
        loop_bandwidth(pfb_clock_sync_fff_sptr self) -> float

        Returns the loop bandwidth.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_loop_bandwidth(self)

    def damping_factor(self):
        """
        damping_factor(pfb_clock_sync_fff_sptr self) -> float

        Returns the loop damping factor.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_damping_factor(self)

    def alpha(self):
        """
        alpha(pfb_clock_sync_fff_sptr self) -> float

        Returns the loop gain alpha.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_alpha(self)

    def beta(self):
        """
        beta(pfb_clock_sync_fff_sptr self) -> float

        Returns the loop gain beta.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_beta(self)

    def clock_rate(self):
        """
        clock_rate(pfb_clock_sync_fff_sptr self) -> float

        Returns the current clock rate.
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_clock_rate(self)

    def history(self):
        """history(pfb_clock_sync_fff_sptr self) -> unsigned int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pfb_clock_sync_fff_sptr self, int which, int delay)
        declare_sample_delay(pfb_clock_sync_fff_sptr self, unsigned int delay)
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pfb_clock_sync_fff_sptr self, int which) -> unsigned int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pfb_clock_sync_fff_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pfb_clock_sync_fff_sptr self) -> double"""
        return _digital_swig.pfb_clock_sync_fff_sptr_relative_rate(self)

    def start(self):
        """start(pfb_clock_sync_fff_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_fff_sptr_start(self)

    def stop(self):
        """stop(pfb_clock_sync_fff_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_fff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pfb_clock_sync_fff_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.pfb_clock_sync_fff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pfb_clock_sync_fff_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.pfb_clock_sync_fff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pfb_clock_sync_fff_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pfb_clock_sync_fff_sptr self, int m)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pfb_clock_sync_fff_sptr self)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pfb_clock_sync_fff_sptr self) -> bool"""
        return _digital_swig.pfb_clock_sync_fff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pfb_clock_sync_fff_sptr self, int m)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pfb_clock_sync_fff_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pfb_clock_sync_fff_sptr self, int i) -> long"""
        return _digital_swig.pfb_clock_sync_fff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pfb_clock_sync_fff_sptr self, long max_output_buffer)
        set_max_output_buffer(pfb_clock_sync_fff_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pfb_clock_sync_fff_sptr self, int i) -> long"""
        return _digital_swig.pfb_clock_sync_fff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pfb_clock_sync_fff_sptr self, long min_output_buffer)
        set_min_output_buffer(pfb_clock_sync_fff_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_input_buffers_full(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_input_buffers_full_avg(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_input_buffers_full_var(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_output_buffers_full(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_output_buffers_full_avg(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pfb_clock_sync_fff_sptr self, int which) -> float
        pc_output_buffers_full_var(pfb_clock_sync_fff_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pfb_clock_sync_fff_sptr self) -> float"""
        return _digital_swig.pfb_clock_sync_fff_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pfb_clock_sync_fff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pfb_clock_sync_fff_sptr self)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pfb_clock_sync_fff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.pfb_clock_sync_fff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pfb_clock_sync_fff_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pfb_clock_sync_fff_sptr self) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pfb_clock_sync_fff_sptr self, int priority) -> int"""
        return _digital_swig.pfb_clock_sync_fff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pfb_clock_sync_fff_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_fff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pfb_clock_sync_fff_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_fff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pfb_clock_sync_fff_sptr self) -> io_signature_sptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pfb_clock_sync_fff_sptr self) -> io_signature_sptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pfb_clock_sync_fff_sptr self) -> long"""
        return _digital_swig.pfb_clock_sync_fff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pfb_clock_sync_fff_sptr self) -> basic_block_sptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pfb_clock_sync_fff_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.pfb_clock_sync_fff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pfb_clock_sync_fff_sptr self) -> std::string"""
        return _digital_swig.pfb_clock_sync_fff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pfb_clock_sync_fff_sptr self, std::string name)"""
        return _digital_swig.pfb_clock_sync_fff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pfb_clock_sync_fff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.pfb_clock_sync_fff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pfb_clock_sync_fff_sptr self) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pfb_clock_sync_fff_sptr self) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pfb_clock_sync_fff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.pfb_clock_sync_fff_sptr_message_subscribers(self, *args, **kwargs)

pfb_clock_sync_fff_sptr_swigregister = _digital_swig.pfb_clock_sync_fff_sptr_swigregister
pfb_clock_sync_fff_sptr_swigregister(pfb_clock_sync_fff_sptr)

pfb_clock_sync_fff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pfb_clock_sync_fff = pfb_clock_sync_fff.make;

class pn_correlator_cc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::pn_correlator_cc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::pn_correlator_cc)> self) -> pn_correlator_cc_sptr
        __init__(boost::shared_ptr<(gr::digital::pn_correlator_cc)> self, pn_correlator_cc p) -> pn_correlator_cc_sptr
        """
        this = _digital_swig.new_pn_correlator_cc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(pn_correlator_cc_sptr self) -> pn_correlator_cc"""
        return _digital_swig.pn_correlator_cc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_pn_correlator_cc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(pn_correlator_cc_sptr self, int degree, int mask=0, int seed=1) -> pn_correlator_cc_sptr

        PN code sequential search correlator.

        Receives complex baseband signal, outputs complex correlation against reference PN code, one sample per PN code period. The PN sequence is generated using a GLFSR.

        Constructor Specific Documentation:

        Make PN code sequential search correlator block.

        Args:
            degree : Degree of shift register must be in [1, 32]. If mask is 0, the degree determines a default mask (see digital_impl_glfsr.cc for the mapping).
            mask : Allows a user-defined bit mask for indexes of the shift register to feed back.
            seed : Initial setting for values in shift register.
        """
        return _digital_swig.pn_correlator_cc_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(pn_correlator_cc_sptr self) -> unsigned int"""
        return _digital_swig.pn_correlator_cc_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(pn_correlator_cc_sptr self, int which, int delay)
        declare_sample_delay(pn_correlator_cc_sptr self, unsigned int delay)
        """
        return _digital_swig.pn_correlator_cc_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(pn_correlator_cc_sptr self, int which) -> unsigned int"""
        return _digital_swig.pn_correlator_cc_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(pn_correlator_cc_sptr self) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(pn_correlator_cc_sptr self) -> double"""
        return _digital_swig.pn_correlator_cc_sptr_relative_rate(self)

    def start(self):
        """start(pn_correlator_cc_sptr self) -> bool"""
        return _digital_swig.pn_correlator_cc_sptr_start(self)

    def stop(self):
        """stop(pn_correlator_cc_sptr self) -> bool"""
        return _digital_swig.pn_correlator_cc_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(pn_correlator_cc_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.pn_correlator_cc_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(pn_correlator_cc_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.pn_correlator_cc_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(pn_correlator_cc_sptr self) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(pn_correlator_cc_sptr self, int m)"""
        return _digital_swig.pn_correlator_cc_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(pn_correlator_cc_sptr self)"""
        return _digital_swig.pn_correlator_cc_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(pn_correlator_cc_sptr self) -> bool"""
        return _digital_swig.pn_correlator_cc_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(pn_correlator_cc_sptr self, int m)"""
        return _digital_swig.pn_correlator_cc_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(pn_correlator_cc_sptr self) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(pn_correlator_cc_sptr self, int i) -> long"""
        return _digital_swig.pn_correlator_cc_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(pn_correlator_cc_sptr self, long max_output_buffer)
        set_max_output_buffer(pn_correlator_cc_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.pn_correlator_cc_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(pn_correlator_cc_sptr self, int i) -> long"""
        return _digital_swig.pn_correlator_cc_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(pn_correlator_cc_sptr self, long min_output_buffer)
        set_min_output_buffer(pn_correlator_cc_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.pn_correlator_cc_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(pn_correlator_cc_sptr self, int which) -> float
        pc_input_buffers_full(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(pn_correlator_cc_sptr self, int which) -> float
        pc_input_buffers_full_avg(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(pn_correlator_cc_sptr self, int which) -> float
        pc_input_buffers_full_var(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(pn_correlator_cc_sptr self, int which) -> float
        pc_output_buffers_full(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(pn_correlator_cc_sptr self, int which) -> float
        pc_output_buffers_full_avg(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(pn_correlator_cc_sptr self, int which) -> float
        pc_output_buffers_full_var(pn_correlator_cc_sptr self) -> pmt_vector_float
        """
        return _digital_swig.pn_correlator_cc_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(pn_correlator_cc_sptr self) -> float"""
        return _digital_swig.pn_correlator_cc_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(pn_correlator_cc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.pn_correlator_cc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(pn_correlator_cc_sptr self)"""
        return _digital_swig.pn_correlator_cc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(pn_correlator_cc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.pn_correlator_cc_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(pn_correlator_cc_sptr self) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(pn_correlator_cc_sptr self) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(pn_correlator_cc_sptr self, int priority) -> int"""
        return _digital_swig.pn_correlator_cc_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(pn_correlator_cc_sptr self) -> std::string"""
        return _digital_swig.pn_correlator_cc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(pn_correlator_cc_sptr self) -> std::string"""
        return _digital_swig.pn_correlator_cc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(pn_correlator_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.pn_correlator_cc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(pn_correlator_cc_sptr self) -> io_signature_sptr"""
        return _digital_swig.pn_correlator_cc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(pn_correlator_cc_sptr self) -> long"""
        return _digital_swig.pn_correlator_cc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(pn_correlator_cc_sptr self) -> basic_block_sptr"""
        return _digital_swig.pn_correlator_cc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(pn_correlator_cc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.pn_correlator_cc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(pn_correlator_cc_sptr self) -> std::string"""
        return _digital_swig.pn_correlator_cc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(pn_correlator_cc_sptr self, std::string name)"""
        return _digital_swig.pn_correlator_cc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(pn_correlator_cc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.pn_correlator_cc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(pn_correlator_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.pn_correlator_cc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(pn_correlator_cc_sptr self) -> swig_int_ptr"""
        return _digital_swig.pn_correlator_cc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(pn_correlator_cc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.pn_correlator_cc_sptr_message_subscribers(self, *args, **kwargs)

pn_correlator_cc_sptr_swigregister = _digital_swig.pn_correlator_cc_sptr_swigregister
pn_correlator_cc_sptr_swigregister(pn_correlator_cc_sptr)

pn_correlator_cc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
pn_correlator_cc = pn_correlator_cc.make;

class probe_density_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::probe_density_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::probe_density_b)> self) -> probe_density_b_sptr
        __init__(boost::shared_ptr<(gr::digital::probe_density_b)> self, probe_density_b p) -> probe_density_b_sptr
        """
        this = _digital_swig.new_probe_density_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(probe_density_b_sptr self) -> probe_density_b"""
        return _digital_swig.probe_density_b_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_probe_density_b_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(probe_density_b_sptr self, double alpha) -> probe_density_b_sptr

        This block maintains a running average of the input stream and makes it available as an accessor function. The input stream is type unsigned char.

        If you send this block a stream of unpacked bytes, it will tell you what the bit density is.

        Constructor Specific Documentation:

        Make a density probe block.

        Args:
            alpha : Average filter constant
        """
        return _digital_swig.probe_density_b_sptr_make(self, *args, **kwargs)

    def density(self):
        """
        density(probe_density_b_sptr self) -> double

        Returns the current density value.
        """
        return _digital_swig.probe_density_b_sptr_density(self)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(probe_density_b_sptr self, double alpha)

        Set the average filter constant.
        """
        return _digital_swig.probe_density_b_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(probe_density_b_sptr self) -> unsigned int"""
        return _digital_swig.probe_density_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(probe_density_b_sptr self, int which, int delay)
        declare_sample_delay(probe_density_b_sptr self, unsigned int delay)
        """
        return _digital_swig.probe_density_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(probe_density_b_sptr self, int which) -> unsigned int"""
        return _digital_swig.probe_density_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(probe_density_b_sptr self) -> int"""
        return _digital_swig.probe_density_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(probe_density_b_sptr self) -> double"""
        return _digital_swig.probe_density_b_sptr_relative_rate(self)

    def start(self):
        """start(probe_density_b_sptr self) -> bool"""
        return _digital_swig.probe_density_b_sptr_start(self)

    def stop(self):
        """stop(probe_density_b_sptr self) -> bool"""
        return _digital_swig.probe_density_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(probe_density_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.probe_density_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(probe_density_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.probe_density_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(probe_density_b_sptr self) -> int"""
        return _digital_swig.probe_density_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(probe_density_b_sptr self, int m)"""
        return _digital_swig.probe_density_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(probe_density_b_sptr self)"""
        return _digital_swig.probe_density_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(probe_density_b_sptr self) -> bool"""
        return _digital_swig.probe_density_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(probe_density_b_sptr self, int m)"""
        return _digital_swig.probe_density_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(probe_density_b_sptr self) -> int"""
        return _digital_swig.probe_density_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(probe_density_b_sptr self, int i) -> long"""
        return _digital_swig.probe_density_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(probe_density_b_sptr self, long max_output_buffer)
        set_max_output_buffer(probe_density_b_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.probe_density_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(probe_density_b_sptr self, int i) -> long"""
        return _digital_swig.probe_density_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(probe_density_b_sptr self, long min_output_buffer)
        set_min_output_buffer(probe_density_b_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.probe_density_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(probe_density_b_sptr self, int which) -> float
        pc_input_buffers_full(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(probe_density_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(probe_density_b_sptr self, int which) -> float
        pc_input_buffers_full_var(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(probe_density_b_sptr self, int which) -> float
        pc_output_buffers_full(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(probe_density_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(probe_density_b_sptr self, int which) -> float
        pc_output_buffers_full_var(probe_density_b_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_density_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(probe_density_b_sptr self) -> float"""
        return _digital_swig.probe_density_b_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(probe_density_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.probe_density_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(probe_density_b_sptr self)"""
        return _digital_swig.probe_density_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(probe_density_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.probe_density_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(probe_density_b_sptr self) -> int"""
        return _digital_swig.probe_density_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(probe_density_b_sptr self) -> int"""
        return _digital_swig.probe_density_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(probe_density_b_sptr self, int priority) -> int"""
        return _digital_swig.probe_density_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(probe_density_b_sptr self) -> std::string"""
        return _digital_swig.probe_density_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(probe_density_b_sptr self) -> std::string"""
        return _digital_swig.probe_density_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(probe_density_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.probe_density_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(probe_density_b_sptr self) -> io_signature_sptr"""
        return _digital_swig.probe_density_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(probe_density_b_sptr self) -> long"""
        return _digital_swig.probe_density_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(probe_density_b_sptr self) -> basic_block_sptr"""
        return _digital_swig.probe_density_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(probe_density_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.probe_density_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(probe_density_b_sptr self) -> std::string"""
        return _digital_swig.probe_density_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(probe_density_b_sptr self, std::string name)"""
        return _digital_swig.probe_density_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(probe_density_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.probe_density_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(probe_density_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.probe_density_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(probe_density_b_sptr self) -> swig_int_ptr"""
        return _digital_swig.probe_density_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(probe_density_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.probe_density_b_sptr_message_subscribers(self, *args, **kwargs)

probe_density_b_sptr_swigregister = _digital_swig.probe_density_b_sptr_swigregister
probe_density_b_sptr_swigregister(probe_density_b_sptr)

probe_density_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
probe_density_b = probe_density_b.make;

class probe_mpsk_snr_est_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::probe_mpsk_snr_est_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::probe_mpsk_snr_est_c)> self) -> probe_mpsk_snr_est_c_sptr
        __init__(boost::shared_ptr<(gr::digital::probe_mpsk_snr_est_c)> self, probe_mpsk_snr_est_c p) -> probe_mpsk_snr_est_c_sptr
        """
        this = _digital_swig.new_probe_mpsk_snr_est_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(probe_mpsk_snr_est_c_sptr self) -> probe_mpsk_snr_est_c"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_probe_mpsk_snr_est_c_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(probe_mpsk_snr_est_c_sptr self, gr::digital::snr_est_type_t type, int msg_nsamples=10000, double alpha=0.001) -> probe_mpsk_snr_est_c_sptr

        A probe for computing SNR of a signal.

        This is a probe block (a sink) that can be used to monitor and retrieve estimations of the signal SNR. This probe is designed for use with M-PSK signals especially. The type of estimator is specified as the  parameter in the constructor. The estimators tend to trade off performance for accuracy, although experimentation should be done to figure out the right approach for a given implementation. Further, the current set of estimators are designed and proven theoretically under AWGN conditions; some amount of error should be assumed and/or estimated for real channel conditions.

        Constructor Specific Documentation:

        Make an MPSK SNR probe.

        Parameters:

        Args:
            type : the type of estimator to use see gr::digital::snr_est_type_t for details about the types.
            msg_nsamples : [not implemented yet] after this many samples, a message containing the SNR (key='snr') will be sent
            alpha : the update rate of internal running average calculations.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_make(self, *args, **kwargs)

    def snr(self):
        """
        snr(probe_mpsk_snr_est_c_sptr self) -> double

        Return the estimated signal-to-noise ratio in decibels.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_snr(self)

    def type(self):
        """
        type(probe_mpsk_snr_est_c_sptr self) -> gr::digital::snr_est_type_t

        Return the type of estimator in use.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_type(self)

    def msg_nsample(self):
        """
        msg_nsample(probe_mpsk_snr_est_c_sptr self) -> int

        Return how many samples between SNR messages.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_msg_nsample(self)

    def alpha(self):
        """
        alpha(probe_mpsk_snr_est_c_sptr self) -> double

        Get the running-average coefficient.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_alpha(self)

    def set_type(self, *args, **kwargs):
        """
        set_type(probe_mpsk_snr_est_c_sptr self, gr::digital::snr_est_type_t t)

        Set type of estimator to use.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_type(self, *args, **kwargs)

    def set_msg_nsample(self, *args, **kwargs):
        """
        set_msg_nsample(probe_mpsk_snr_est_c_sptr self, int n)

        Set the number of samples between SNR messages.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_msg_nsample(self, *args, **kwargs)

    def set_alpha(self, *args, **kwargs):
        """
        set_alpha(probe_mpsk_snr_est_c_sptr self, double alpha)

        Set the running-average coefficient.
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_alpha(self, *args, **kwargs)

    def history(self):
        """history(probe_mpsk_snr_est_c_sptr self) -> unsigned int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(probe_mpsk_snr_est_c_sptr self, int which, int delay)
        declare_sample_delay(probe_mpsk_snr_est_c_sptr self, unsigned int delay)
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(probe_mpsk_snr_est_c_sptr self, int which) -> unsigned int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(probe_mpsk_snr_est_c_sptr self) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(probe_mpsk_snr_est_c_sptr self) -> double"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_relative_rate(self)

    def start(self):
        """start(probe_mpsk_snr_est_c_sptr self) -> bool"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_start(self)

    def stop(self):
        """stop(probe_mpsk_snr_est_c_sptr self) -> bool"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(probe_mpsk_snr_est_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(probe_mpsk_snr_est_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(probe_mpsk_snr_est_c_sptr self) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(probe_mpsk_snr_est_c_sptr self, int m)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(probe_mpsk_snr_est_c_sptr self)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(probe_mpsk_snr_est_c_sptr self) -> bool"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(probe_mpsk_snr_est_c_sptr self, int m)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(probe_mpsk_snr_est_c_sptr self) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(probe_mpsk_snr_est_c_sptr self, int i) -> long"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(probe_mpsk_snr_est_c_sptr self, long max_output_buffer)
        set_max_output_buffer(probe_mpsk_snr_est_c_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(probe_mpsk_snr_est_c_sptr self, int i) -> long"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(probe_mpsk_snr_est_c_sptr self, long min_output_buffer)
        set_min_output_buffer(probe_mpsk_snr_est_c_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_input_buffers_full(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_input_buffers_full_var(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_output_buffers_full(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(probe_mpsk_snr_est_c_sptr self, int which) -> float
        pc_output_buffers_full_var(probe_mpsk_snr_est_c_sptr self) -> pmt_vector_float
        """
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(probe_mpsk_snr_est_c_sptr self) -> float"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(probe_mpsk_snr_est_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(probe_mpsk_snr_est_c_sptr self)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(probe_mpsk_snr_est_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(probe_mpsk_snr_est_c_sptr self) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(probe_mpsk_snr_est_c_sptr self) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(probe_mpsk_snr_est_c_sptr self, int priority) -> int"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(probe_mpsk_snr_est_c_sptr self) -> std::string"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_name(self)

    def symbol_name(self):
        """symbol_name(probe_mpsk_snr_est_c_sptr self) -> std::string"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(probe_mpsk_snr_est_c_sptr self) -> io_signature_sptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(probe_mpsk_snr_est_c_sptr self) -> io_signature_sptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(probe_mpsk_snr_est_c_sptr self) -> long"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(probe_mpsk_snr_est_c_sptr self) -> basic_block_sptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(probe_mpsk_snr_est_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(probe_mpsk_snr_est_c_sptr self) -> std::string"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(probe_mpsk_snr_est_c_sptr self, std::string name)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(probe_mpsk_snr_est_c_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(probe_mpsk_snr_est_c_sptr self) -> swig_int_ptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(probe_mpsk_snr_est_c_sptr self) -> swig_int_ptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(probe_mpsk_snr_est_c_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.probe_mpsk_snr_est_c_sptr_message_subscribers(self, *args, **kwargs)

probe_mpsk_snr_est_c_sptr_swigregister = _digital_swig.probe_mpsk_snr_est_c_sptr_swigregister
probe_mpsk_snr_est_c_sptr_swigregister(probe_mpsk_snr_est_c_sptr)

probe_mpsk_snr_est_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
probe_mpsk_snr_est_c = probe_mpsk_snr_est_c.make;

class scrambler_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::scrambler_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::scrambler_bb)> self) -> scrambler_bb_sptr
        __init__(boost::shared_ptr<(gr::digital::scrambler_bb)> self, scrambler_bb p) -> scrambler_bb_sptr
        """
        this = _digital_swig.new_scrambler_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(scrambler_bb_sptr self) -> scrambler_bb"""
        return _digital_swig.scrambler_bb_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_scrambler_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(scrambler_bb_sptr self, int mask, int seed, int len) -> scrambler_bb_sptr

        Scramble an input stream using an LFSR.

        This block works on the LSB only of the input data stream, i.e., on an "unpacked binary" stream, and produces the same format on its output.

        Constructor Specific Documentation:

        Make a scramber block.

        Args:
            mask : Polynomial mask for LFSR
            seed : Initial shift register contents
            len : Shift register length
        """
        return _digital_swig.scrambler_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(scrambler_bb_sptr self) -> unsigned int"""
        return _digital_swig.scrambler_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(scrambler_bb_sptr self, int which, int delay)
        declare_sample_delay(scrambler_bb_sptr self, unsigned int delay)
        """
        return _digital_swig.scrambler_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(scrambler_bb_sptr self, int which) -> unsigned int"""
        return _digital_swig.scrambler_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(scrambler_bb_sptr self) -> int"""
        return _digital_swig.scrambler_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(scrambler_bb_sptr self) -> double"""
        return _digital_swig.scrambler_bb_sptr_relative_rate(self)

    def start(self):
        """start(scrambler_bb_sptr self) -> bool"""
        return _digital_swig.scrambler_bb_sptr_start(self)

    def stop(self):
        """stop(scrambler_bb_sptr self) -> bool"""
        return _digital_swig.scrambler_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(scrambler_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.scrambler_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(scrambler_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.scrambler_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(scrambler_bb_sptr self) -> int"""
        return _digital_swig.scrambler_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(scrambler_bb_sptr self, int m)"""
        return _digital_swig.scrambler_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(scrambler_bb_sptr self)"""
        return _digital_swig.scrambler_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(scrambler_bb_sptr self) -> bool"""
        return _digital_swig.scrambler_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(scrambler_bb_sptr self, int m)"""
        return _digital_swig.scrambler_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(scrambler_bb_sptr self) -> int"""
        return _digital_swig.scrambler_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(scrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.scrambler_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(scrambler_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(scrambler_bb_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.scrambler_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(scrambler_bb_sptr self, int i) -> long"""
        return _digital_swig.scrambler_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(scrambler_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(scrambler_bb_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.scrambler_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(scrambler_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(scrambler_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(scrambler_bb_sptr self) -> pmt_vector_float
        """
        return _digital_swig.scrambler_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(scrambler_bb_sptr self) -> float"""
        return _digital_swig.scrambler_bb_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(scrambler_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.scrambler_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(scrambler_bb_sptr self)"""
        return _digital_swig.scrambler_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(scrambler_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.scrambler_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(scrambler_bb_sptr self) -> int"""
        return _digital_swig.scrambler_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(scrambler_bb_sptr self) -> int"""
        return _digital_swig.scrambler_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(scrambler_bb_sptr self, int priority) -> int"""
        return _digital_swig.scrambler_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.scrambler_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.scrambler_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(scrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.scrambler_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(scrambler_bb_sptr self) -> io_signature_sptr"""
        return _digital_swig.scrambler_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(scrambler_bb_sptr self) -> long"""
        return _digital_swig.scrambler_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(scrambler_bb_sptr self) -> basic_block_sptr"""
        return _digital_swig.scrambler_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(scrambler_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.scrambler_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(scrambler_bb_sptr self) -> std::string"""
        return _digital_swig.scrambler_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(scrambler_bb_sptr self, std::string name)"""
        return _digital_swig.scrambler_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(scrambler_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.scrambler_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(scrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.scrambler_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(scrambler_bb_sptr self) -> swig_int_ptr"""
        return _digital_swig.scrambler_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(scrambler_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.scrambler_bb_sptr_message_subscribers(self, *args, **kwargs)

scrambler_bb_sptr_swigregister = _digital_swig.scrambler_bb_sptr_swigregister
scrambler_bb_sptr_swigregister(scrambler_bb_sptr)

scrambler_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
scrambler_bb = scrambler_bb.make;

class simple_correlator_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::simple_correlator)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::simple_correlator)> self) -> simple_correlator_sptr
        __init__(boost::shared_ptr<(gr::digital::simple_correlator)> self, simple_correlator p) -> simple_correlator_sptr
        """
        this = _digital_swig.new_simple_correlator_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(simple_correlator_sptr self) -> simple_correlator"""
        return _digital_swig.simple_correlator_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_simple_correlator_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(simple_correlator_sptr self, int payload_bytesize) -> simple_correlator_sptr

        inverse of simple_framer (more or less)

        Constructor Specific Documentation:



        Args:
            payload_bytesize : 
        """
        return _digital_swig.simple_correlator_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(simple_correlator_sptr self) -> unsigned int"""
        return _digital_swig.simple_correlator_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(simple_correlator_sptr self, int which, int delay)
        declare_sample_delay(simple_correlator_sptr self, unsigned int delay)
        """
        return _digital_swig.simple_correlator_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(simple_correlator_sptr self, int which) -> unsigned int"""
        return _digital_swig.simple_correlator_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(simple_correlator_sptr self) -> int"""
        return _digital_swig.simple_correlator_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(simple_correlator_sptr self) -> double"""
        return _digital_swig.simple_correlator_sptr_relative_rate(self)

    def start(self):
        """start(simple_correlator_sptr self) -> bool"""
        return _digital_swig.simple_correlator_sptr_start(self)

    def stop(self):
        """stop(simple_correlator_sptr self) -> bool"""
        return _digital_swig.simple_correlator_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(simple_correlator_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.simple_correlator_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(simple_correlator_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.simple_correlator_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(simple_correlator_sptr self) -> int"""
        return _digital_swig.simple_correlator_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(simple_correlator_sptr self, int m)"""
        return _digital_swig.simple_correlator_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(simple_correlator_sptr self)"""
        return _digital_swig.simple_correlator_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(simple_correlator_sptr self) -> bool"""
        return _digital_swig.simple_correlator_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(simple_correlator_sptr self, int m)"""
        return _digital_swig.simple_correlator_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(simple_correlator_sptr self) -> int"""
        return _digital_swig.simple_correlator_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(simple_correlator_sptr self, int i) -> long"""
        return _digital_swig.simple_correlator_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(simple_correlator_sptr self, long max_output_buffer)
        set_max_output_buffer(simple_correlator_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.simple_correlator_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(simple_correlator_sptr self, int i) -> long"""
        return _digital_swig.simple_correlator_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(simple_correlator_sptr self, long min_output_buffer)
        set_min_output_buffer(simple_correlator_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.simple_correlator_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(simple_correlator_sptr self, int which) -> float
        pc_input_buffers_full(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(simple_correlator_sptr self, int which) -> float
        pc_input_buffers_full_avg(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(simple_correlator_sptr self, int which) -> float
        pc_input_buffers_full_var(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(simple_correlator_sptr self, int which) -> float
        pc_output_buffers_full(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(simple_correlator_sptr self, int which) -> float
        pc_output_buffers_full_avg(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(simple_correlator_sptr self, int which) -> float
        pc_output_buffers_full_var(simple_correlator_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_correlator_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(simple_correlator_sptr self) -> float"""
        return _digital_swig.simple_correlator_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(simple_correlator_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.simple_correlator_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(simple_correlator_sptr self)"""
        return _digital_swig.simple_correlator_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(simple_correlator_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.simple_correlator_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(simple_correlator_sptr self) -> int"""
        return _digital_swig.simple_correlator_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(simple_correlator_sptr self) -> int"""
        return _digital_swig.simple_correlator_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(simple_correlator_sptr self, int priority) -> int"""
        return _digital_swig.simple_correlator_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(simple_correlator_sptr self) -> std::string"""
        return _digital_swig.simple_correlator_sptr_name(self)

    def symbol_name(self):
        """symbol_name(simple_correlator_sptr self) -> std::string"""
        return _digital_swig.simple_correlator_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(simple_correlator_sptr self) -> io_signature_sptr"""
        return _digital_swig.simple_correlator_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(simple_correlator_sptr self) -> io_signature_sptr"""
        return _digital_swig.simple_correlator_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(simple_correlator_sptr self) -> long"""
        return _digital_swig.simple_correlator_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(simple_correlator_sptr self) -> basic_block_sptr"""
        return _digital_swig.simple_correlator_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(simple_correlator_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.simple_correlator_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(simple_correlator_sptr self) -> std::string"""
        return _digital_swig.simple_correlator_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(simple_correlator_sptr self, std::string name)"""
        return _digital_swig.simple_correlator_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(simple_correlator_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.simple_correlator_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(simple_correlator_sptr self) -> swig_int_ptr"""
        return _digital_swig.simple_correlator_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(simple_correlator_sptr self) -> swig_int_ptr"""
        return _digital_swig.simple_correlator_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(simple_correlator_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.simple_correlator_sptr_message_subscribers(self, *args, **kwargs)

simple_correlator_sptr_swigregister = _digital_swig.simple_correlator_sptr_swigregister
simple_correlator_sptr_swigregister(simple_correlator_sptr)

simple_correlator_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
simple_correlator = simple_correlator.make;

class simple_framer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::simple_framer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::simple_framer)> self) -> simple_framer_sptr
        __init__(boost::shared_ptr<(gr::digital::simple_framer)> self, simple_framer p) -> simple_framer_sptr
        """
        this = _digital_swig.new_simple_framer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(simple_framer_sptr self) -> simple_framer"""
        return _digital_swig.simple_framer_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_simple_framer_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(simple_framer_sptr self, int payload_bytesize) -> simple_framer_sptr

        add sync field, seq number and command field to payload

        Takes in enough samples to create a full output frame. The frame is prepended with the GRSF_SYNC (defind in simple_framer_sync.h) and an 8-bit sequence number.

        Constructor Specific Documentation:

        Make a simple_framer block.

        Args:
            payload_bytesize : The size of the payload in bytes.
        """
        return _digital_swig.simple_framer_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(simple_framer_sptr self) -> unsigned int"""
        return _digital_swig.simple_framer_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(simple_framer_sptr self, int which, int delay)
        declare_sample_delay(simple_framer_sptr self, unsigned int delay)
        """
        return _digital_swig.simple_framer_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(simple_framer_sptr self, int which) -> unsigned int"""
        return _digital_swig.simple_framer_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(simple_framer_sptr self) -> int"""
        return _digital_swig.simple_framer_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(simple_framer_sptr self) -> double"""
        return _digital_swig.simple_framer_sptr_relative_rate(self)

    def start(self):
        """start(simple_framer_sptr self) -> bool"""
        return _digital_swig.simple_framer_sptr_start(self)

    def stop(self):
        """stop(simple_framer_sptr self) -> bool"""
        return _digital_swig.simple_framer_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(simple_framer_sptr self, unsigned int which_input) -> uint64_t"""
        return _digital_swig.simple_framer_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(simple_framer_sptr self, unsigned int which_output) -> uint64_t"""
        return _digital_swig.simple_framer_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(simple_framer_sptr self) -> int"""
        return _digital_swig.simple_framer_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(simple_framer_sptr self, int m)"""
        return _digital_swig.simple_framer_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(simple_framer_sptr self)"""
        return _digital_swig.simple_framer_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(simple_framer_sptr self) -> bool"""
        return _digital_swig.simple_framer_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(simple_framer_sptr self, int m)"""
        return _digital_swig.simple_framer_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(simple_framer_sptr self) -> int"""
        return _digital_swig.simple_framer_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(simple_framer_sptr self, int i) -> long"""
        return _digital_swig.simple_framer_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(simple_framer_sptr self, long max_output_buffer)
        set_max_output_buffer(simple_framer_sptr self, int port, long max_output_buffer)
        """
        return _digital_swig.simple_framer_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(simple_framer_sptr self, int i) -> long"""
        return _digital_swig.simple_framer_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(simple_framer_sptr self, long min_output_buffer)
        set_min_output_buffer(simple_framer_sptr self, int port, long min_output_buffer)
        """
        return _digital_swig.simple_framer_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(simple_framer_sptr self, int which) -> float
        pc_input_buffers_full(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(simple_framer_sptr self, int which) -> float
        pc_input_buffers_full_avg(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(simple_framer_sptr self, int which) -> float
        pc_input_buffers_full_var(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(simple_framer_sptr self, int which) -> float
        pc_output_buffers_full(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(simple_framer_sptr self, int which) -> float
        pc_output_buffers_full_avg(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(simple_framer_sptr self, int which) -> float
        pc_output_buffers_full_var(simple_framer_sptr self) -> pmt_vector_float
        """
        return _digital_swig.simple_framer_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(simple_framer_sptr self) -> float"""
        return _digital_swig.simple_framer_sptr_pc_work_time_total(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(simple_framer_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.simple_framer_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(simple_framer_sptr self)"""
        return _digital_swig.simple_framer_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(simple_framer_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.simple_framer_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(simple_framer_sptr self) -> int"""
        return _digital_swig.simple_framer_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(simple_framer_sptr self) -> int"""
        return _digital_swig.simple_framer_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(simple_framer_sptr self, int priority) -> int"""
        return _digital_swig.simple_framer_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(simple_framer_sptr self) -> std::string"""
        return _digital_swig.simple_framer_sptr_name(self)

    def symbol_name(self):
        """symbol_name(simple_framer_sptr self) -> std::string"""
        return _digital_swig.simple_framer_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(simple_framer_sptr self) -> io_signature_sptr"""
        return _digital_swig.simple_framer_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(simple_framer_sptr self) -> io_signature_sptr"""
        return _digital_swig.simple_framer_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(simple_framer_sptr self) -> long"""
        return _digital_swig.simple_framer_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(simple_framer_sptr self) -> basic_block_sptr"""
        return _digital_swig.simple_framer_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(simple_framer_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.simple_framer_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(simple_framer_sptr self) -> std::string"""
        return _digital_swig.simple_framer_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(simple_framer_sptr self, std::string name)"""
        return _digital_swig.simple_framer_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(simple_framer_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.simple_framer_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(simple_framer_sptr self) -> swig_int_ptr"""
        return _digital_swig.simple_framer_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(simple_framer_sptr self) -> swig_int_ptr"""
        return _digital_swig.simple_framer_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(simple_framer_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.simple_framer_sptr_message_subscribers(self, *args, **kwargs)

simple_framer_sptr_swigregister = _digital_swig.simple_framer_sptr_swigregister
simple_framer_sptr_swigregister(simple_framer_sptr)

simple_framer_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
simple_framer = simple_framer.make;

class gmskmod_bc_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::cpmmod_bc)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::cpmmod_bc)> self) -> gmskmod_bc_sptr
        __init__(boost::shared_ptr<(gr::digital::cpmmod_bc)> self, cpmmod_bc p) -> gmskmod_bc_sptr
        """
        this = _digital_swig.new_gmskmod_bc_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(gmskmod_bc_sptr self) -> cpmmod_bc"""
        return _digital_swig.gmskmod_bc_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_gmskmod_bc_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(gmskmod_bc_sptr self, gr::analog::cpm::cpm_type type, float h, int samples_per_sym, int L, double beta=0.3) -> cpmmod_bc_sptr

        Generic CPM modulator.

        Examples:


        The input of this block are symbols from an M-ary alphabet +/-1, +/-3, ..., +/-(M-1). Usually, M = 2 and therefore, the valid inputs are +/-1. The modulator will silently accept any other inputs, though. The output is the phase-modulated signal.

        Constructor Specific Documentation:

        Make CPM modulator block.

        Args:
            type : The modulation type. Can be one of LREC, LRC, LSRC, TFM or GAUSSIAN. See gr_cpm::phase_response() for a detailed description.
            h : The modulation index.  is the maximum phase change that can occur between two symbols, i.e., if you only send ones, the phase will increase by  every  samples. Set this to 0.5 for Minimum Shift Keying variants.
            samples_per_sym : Samples per symbol.
            L : The length of the phase duration in symbols. For L=1, this yields full- response CPM symbols, for L > 1, partial-response.
            beta : For LSRC, this is the rolloff factor. For Gaussian pulses, this is the 3 dB time-bandwidth product.
        """
        return _digital_swig.gmskmod_bc_sptr_make(self, *args, **kwargs)

    def make_gmskmod_bc(self, samples_per_sym=2, L=4, beta=0.3):
        """
        make_gmskmod_bc(gmskmod_bc_sptr self, int samples_per_sym=2, int L=4, double beta=0.3) -> cpmmod_bc_sptr

        Make GMSK modulator block.

        The type is GAUSSIAN and the modulation index for GMSK is 0.5. This are populated automatically by this factory function.
        """
        return _digital_swig.gmskmod_bc_sptr_make_gmskmod_bc(self, samples_per_sym, L, beta)

    def taps(self):
        """
        taps(gmskmod_bc_sptr self) -> pmt_vector_float

        Return the phase response FIR taps.
        """
        return _digital_swig.gmskmod_bc_sptr_taps(self)

    def type(self):
        """
        type(gmskmod_bc_sptr self) -> int

        Return the type of CPM modulator.
        """
        return _digital_swig.gmskmod_bc_sptr_type(self)

    def index(self):
        """
        index(gmskmod_bc_sptr self) -> float

        Return the modulation index of the modulator.
        """
        return _digital_swig.gmskmod_bc_sptr_index(self)

    def samples_per_sym(self):
        """
        samples_per_sym(gmskmod_bc_sptr self) -> int

        Return the number of samples per symbol.
        """
        return _digital_swig.gmskmod_bc_sptr_samples_per_sym(self)

    def length(self):
        """
        length(gmskmod_bc_sptr self) -> int

        Return the length of the phase duration (in symbols)
        """
        return _digital_swig.gmskmod_bc_sptr_length(self)

    def beta(self):
        """
        beta(gmskmod_bc_sptr self) -> double

        Return the value of beta for the modulator.
        """
        return _digital_swig.gmskmod_bc_sptr_beta(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(gmskmod_bc_sptr self, basic_block_sptr block)
        primitive_connect(gmskmod_bc_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.gmskmod_bc_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(gmskmod_bc_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(gmskmod_bc_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.gmskmod_bc_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(gmskmod_bc_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(gmskmod_bc_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _digital_swig.gmskmod_bc_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(gmskmod_bc_sptr self, basic_block_sptr block)
        primitive_disconnect(gmskmod_bc_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)
        """
        return _digital_swig.gmskmod_bc_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """disconnect_all(gmskmod_bc_sptr self)"""
        return _digital_swig.gmskmod_bc_sptr_disconnect_all(self)

    def lock(self):
        """lock(gmskmod_bc_sptr self)"""
        return _digital_swig.gmskmod_bc_sptr_lock(self)

    def unlock(self):
        """unlock(gmskmod_bc_sptr self)"""
        return _digital_swig.gmskmod_bc_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(gmskmod_bc_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.gmskmod_bc_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(gmskmod_bc_sptr self, swig_int_ptr port_id)"""
        return _digital_swig.gmskmod_bc_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(gmskmod_bc_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _digital_swig.gmskmod_bc_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(gmskmod_bc_sptr self)"""
        return _digital_swig.gmskmod_bc_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(gmskmod_bc_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _digital_swig.gmskmod_bc_sptr_processor_affinity(self)

    def to_hier_block2(self):
        """to_hier_block2(gmskmod_bc_sptr self) -> hier_block2_sptr"""
        return _digital_swig.gmskmod_bc_sptr_to_hier_block2(self)

    def name(self):
        """name(gmskmod_bc_sptr self) -> std::string"""
        return _digital_swig.gmskmod_bc_sptr_name(self)

    def symbol_name(self):
        """symbol_name(gmskmod_bc_sptr self) -> std::string"""
        return _digital_swig.gmskmod_bc_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(gmskmod_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.gmskmod_bc_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(gmskmod_bc_sptr self) -> io_signature_sptr"""
        return _digital_swig.gmskmod_bc_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(gmskmod_bc_sptr self) -> long"""
        return _digital_swig.gmskmod_bc_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(gmskmod_bc_sptr self) -> basic_block_sptr"""
        return _digital_swig.gmskmod_bc_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(gmskmod_bc_sptr self, int ninputs, int noutputs) -> bool"""
        return _digital_swig.gmskmod_bc_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(gmskmod_bc_sptr self) -> std::string"""
        return _digital_swig.gmskmod_bc_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(gmskmod_bc_sptr self, std::string name)"""
        return _digital_swig.gmskmod_bc_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(gmskmod_bc_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _digital_swig.gmskmod_bc_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(gmskmod_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.gmskmod_bc_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(gmskmod_bc_sptr self) -> swig_int_ptr"""
        return _digital_swig.gmskmod_bc_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(gmskmod_bc_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _digital_swig.gmskmod_bc_sptr_message_subscribers(self, *args, **kwargs)

gmskmod_bc_sptr_swigregister = _digital_swig.gmskmod_bc_sptr_swigregister
gmskmod_bc_sptr_swigregister(gmskmod_bc_sptr)

gmskmod_bc_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
gmskmod_bc = cpmmod_bc_make_gmskmod_bc;

class constellation_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation)> self) -> constellation_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation)> self, constellation p) -> constellation_sptr
        """
        this = _digital_swig.new_constellation_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_sptr self) -> constellation"""
        return _digital_swig.constellation_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_sptr
    __del__ = lambda self : None;
    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_sptr self) -> unsigned int"""
        return _digital_swig.constellation_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_sptr self) -> unsigned int"""
        return _digital_swig.constellation_sptr_arity(self)

    def base(self):
        """base(constellation_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_sptr_swigregister = _digital_swig.constellation_sptr_swigregister
constellation_sptr_swigregister(constellation_sptr)

class constellation_calcdist_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_calcdist)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_calcdist)> self) -> constellation_calcdist_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_calcdist)> self, constellation_calcdist p) -> constellation_calcdist_sptr
        """
        this = _digital_swig.new_constellation_calcdist_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_calcdist_sptr self) -> constellation_calcdist"""
        return _digital_swig.constellation_calcdist_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_calcdist_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_calcdist_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int dimensionality) -> constellation_calcdist_sptr

        Calculate Euclidian distance for any constellation.

        Constellation which calculates the distance to each point in the constellation for decision making. Inefficient for large constellations.

        Constructor Specific Documentation:

        Make a general constellation object that calculates the Euclidean distance for hard decisions.

        Args:
            constell : List of constellation points (order of list matches pre_diff_code)
            pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
            rotational_symmetry : Number of rotations around unit circle that have the same representation.
            dimensionality : Number of dimensions to the constellation.
        """
        return _digital_swig.constellation_calcdist_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_calcdist_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_calcdist_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_calcdist_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_calcdist_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_calcdist_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_calcdist_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_calcdist_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_calcdist_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_calcdist_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_calcdist_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_calcdist_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_calcdist_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_calcdist_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_calcdist_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_calcdist_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_calcdist_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_calcdist_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_calcdist_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_calcdist_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_calcdist_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_calcdist_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_calcdist_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_calcdist_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_calcdist_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_calcdist_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_calcdist_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_calcdist_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_calcdist_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_calcdist_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_calcdist_sptr self) -> unsigned int"""
        return _digital_swig.constellation_calcdist_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_calcdist_sptr self) -> unsigned int"""
        return _digital_swig.constellation_calcdist_sptr_arity(self)

    def base(self):
        """base(constellation_calcdist_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_calcdist_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_calcdist_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_calcdist_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_calcdist_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_calcdist_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_calcdist_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_calcdist_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_calcdist_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_calcdist_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_calcdist_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_calcdist_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_calcdist_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_calcdist_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_calcdist_sptr_swigregister = _digital_swig.constellation_calcdist_sptr_swigregister
constellation_calcdist_sptr_swigregister(constellation_calcdist_sptr)

constellation_calcdist_sptr.__repr__ = lambda self: "<constellation calcdist (m=%d)>" % (len(self.points()))
constellation_calcdist = constellation_calcdist.make;

class constellation_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_rect)> self) -> constellation_rect_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_rect)> self, constellation_rect p) -> constellation_rect_sptr
        """
        this = _digital_swig.new_constellation_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_rect_sptr self) -> constellation_rect"""
        return _digital_swig.constellation_rect_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_rect_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_rect_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors) -> constellation_rect_sptr

        Rectangular digital constellation

        Only implemented for 1-(complex)dimensional constellation.

        Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

        Works well for square QAM.

        Works for any generic constellation provided sectors are not too large.

        Constructor Specific Documentation:

        Make a rectangular constellation object.

        Args:
            constell : List of constellation points (order of list matches pre_diff_code)
            pre_diff_code : List of alphabet symbols (before applying any differential coding) (order of list matches constell)
            rotational_symmetry : Number of rotations around unit circle that have the same representation.
            real_sectors : Number of sectors the real axis is split in to.
            imag_sectors : Number of sectors the imag axis is split in to.
            width_real_sectors : width of each real sector to calculate decision boundaries.
            width_imag_sectors : width of each imag sector to calculate decision boundaries.
        """
        return _digital_swig.constellation_rect_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_rect_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_rect_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_rect_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_rect_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_rect_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_rect_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_rect_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_rect_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_rect_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_rect_sptr self) -> unsigned int"""
        return _digital_swig.constellation_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_rect_sptr self) -> unsigned int"""
        return _digital_swig.constellation_rect_sptr_arity(self)

    def base(self):
        """base(constellation_rect_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_rect_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_rect_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_rect_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_rect_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_rect_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_rect_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_rect_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_rect_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_rect_sptr_swigregister = _digital_swig.constellation_rect_sptr_swigregister
constellation_rect_sptr_swigregister(constellation_rect_sptr)

constellation_rect_sptr.__repr__ = lambda self: "<constellation rect (m=%d)>" % (len(self.points()))
constellation_rect = constellation_rect.make;

class constellation_expl_rect_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_expl_rect)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_expl_rect)> self) -> constellation_expl_rect_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_expl_rect)> self, constellation_expl_rect p) -> constellation_expl_rect_sptr
        """
        this = _digital_swig.new_constellation_expl_rect_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_expl_rect_sptr self) -> constellation_expl_rect"""
        return _digital_swig.constellation_expl_rect_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_expl_rect_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_expl_rect_sptr self, pmt_vector_cfloat constellation, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int rotational_symmetry, unsigned int real_sectors, unsigned int imag_sectors, 
            float width_real_sectors, float width_imag_sectors, std::vector< unsigned int,std::allocator< unsigned int > > sector_values) -> constellation_expl_rect_sptr

        Rectangular digital constellation.

        Only implemented for 1-(complex)dimensional constellation.

        Constellation space is divided into rectangular sectors. Each sector is associated with the nearest constellation point.

        This class is different from constellation_rect in that the mapping from sector to constellation point is explicitly passed into the constructor as sector_values. Usually we do not need this, since we want each sector to be automatically mapped to the closest constellation point, however sometimes it's nice to have the flexibility.

        Constructor Specific Documentation:



        Args:
            constellation : 
            pre_diff_code : 
            rotational_symmetry : 
            real_sectors : 
            imag_sectors : 
            width_real_sectors : 
            width_imag_sectors : 
            sector_values : 
        """
        return _digital_swig.constellation_expl_rect_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_expl_rect_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_expl_rect_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_expl_rect_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_expl_rect_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_expl_rect_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_expl_rect_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_expl_rect_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_expl_rect_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_expl_rect_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_expl_rect_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_expl_rect_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_expl_rect_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_expl_rect_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_expl_rect_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_expl_rect_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_expl_rect_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_expl_rect_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_expl_rect_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_expl_rect_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_expl_rect_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_expl_rect_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_expl_rect_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_expl_rect_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_expl_rect_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_expl_rect_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_expl_rect_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_expl_rect_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_expl_rect_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_expl_rect_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_expl_rect_sptr self) -> unsigned int"""
        return _digital_swig.constellation_expl_rect_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_expl_rect_sptr self) -> unsigned int"""
        return _digital_swig.constellation_expl_rect_sptr_arity(self)

    def base(self):
        """base(constellation_expl_rect_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_expl_rect_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_expl_rect_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_expl_rect_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_expl_rect_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_expl_rect_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_expl_rect_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_expl_rect_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_expl_rect_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_expl_rect_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_expl_rect_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_expl_rect_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_expl_rect_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_expl_rect_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_expl_rect_sptr_swigregister = _digital_swig.constellation_expl_rect_sptr_swigregister
constellation_expl_rect_sptr_swigregister(constellation_expl_rect_sptr)

constellation_expl_rect_sptr.__repr__ = lambda self: "<constellation expl rect (m=%d)>" % (len(self.points()))
constellation_expl_rect = constellation_expl_rect.make;

class constellation_psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_psk)> self) -> constellation_psk_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_psk)> self, constellation_psk p) -> constellation_psk_sptr
        """
        this = _digital_swig.new_constellation_psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_psk_sptr self) -> constellation_psk"""
        return _digital_swig.constellation_psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_psk_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(constellation_psk_sptr self, pmt_vector_cfloat constell, std::vector< int,std::allocator< int > > pre_diff_code, 
            unsigned int n_sectors) -> constellation_psk_sptr

        constellation_psk

        Constellation space is divided into pie slices sectors.

        Each slice is associated with the nearest constellation point.

        Works well for PSK but nothing else.

        Assumes that there is a constellation point at 1.x

        Constructor Specific Documentation:



        Args:
            constell : 
            pre_diff_code : 
            n_sectors : 
        """
        return _digital_swig.constellation_psk_sptr_make(self, *args, **kwargs)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_psk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_psk_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_psk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_psk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_psk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_psk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_psk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_psk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_psk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_psk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_psk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_psk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_psk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_psk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_psk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_psk_sptr_arity(self)

    def base(self):
        """base(constellation_psk_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_psk_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_psk_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_psk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_psk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_psk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_psk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_psk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_psk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_psk_sptr_swigregister = _digital_swig.constellation_psk_sptr_swigregister
constellation_psk_sptr_swigregister(constellation_psk_sptr)

constellation_psk_sptr.__repr__ = lambda self: "<constellation PSK (m=%d)>" % (len(self.points()))
constellation_psk = constellation_psk.make;

class constellation_bpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_bpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_bpsk)> self) -> constellation_bpsk_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_bpsk)> self, constellation_bpsk p) -> constellation_bpsk_sptr
        """
        this = _digital_swig.new_constellation_bpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_bpsk_sptr self) -> constellation_bpsk"""
        return _digital_swig.constellation_bpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_bpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_bpsk_sptr self) -> constellation_bpsk_sptr

        Digital constellation for BPSK .

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_bpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_bpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_bpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_bpsk_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_bpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_bpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_bpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_bpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_bpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_bpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_bpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_bpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_bpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_bpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_bpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_bpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_bpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_bpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_bpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_bpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_bpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_bpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_bpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_bpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_bpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_bpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_bpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_bpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_bpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_bpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_bpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_bpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_bpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_bpsk_sptr_arity(self)

    def base(self):
        """base(constellation_bpsk_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_bpsk_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_bpsk_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_bpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_bpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_bpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_bpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_bpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_bpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_bpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_bpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_bpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_bpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_bpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_bpsk_sptr_swigregister = _digital_swig.constellation_bpsk_sptr_swigregister
constellation_bpsk_sptr_swigregister(constellation_bpsk_sptr)

constellation_bpsk_sptr.__repr__ = lambda self: "<constellation BPSK>"
constellation_bpsk = constellation_bpsk.make;

class constellation_qpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_qpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_qpsk)> self) -> constellation_qpsk_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_qpsk)> self, constellation_qpsk p) -> constellation_qpsk_sptr
        """
        this = _digital_swig.new_constellation_qpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_qpsk_sptr self) -> constellation_qpsk"""
        return _digital_swig.constellation_qpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_qpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_qpsk_sptr self) -> constellation_qpsk_sptr

        Digital constellation for QPSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_qpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_qpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_qpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_qpsk_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_qpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_qpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_qpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_qpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_qpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_qpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_qpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_qpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_qpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_qpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_qpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_qpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_qpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_qpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_qpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_qpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_qpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_qpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_qpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_qpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_qpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_qpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_qpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_qpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_qpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_qpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_qpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_qpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_qpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_qpsk_sptr_arity(self)

    def base(self):
        """base(constellation_qpsk_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_qpsk_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_qpsk_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_qpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_qpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_qpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_qpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_qpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_qpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_qpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_qpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_qpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_qpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_qpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_qpsk_sptr_swigregister = _digital_swig.constellation_qpsk_sptr_swigregister
constellation_qpsk_sptr_swigregister(constellation_qpsk_sptr)

constellation_qpsk_sptr.__repr__ = lambda self: "<constellation QPSK>"
constellation_qpsk = constellation_qpsk.make;

class constellation_dqpsk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_dqpsk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_dqpsk)> self) -> constellation_dqpsk_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_dqpsk)> self, constellation_dqpsk p) -> constellation_dqpsk_sptr
        """
        this = _digital_swig.new_constellation_dqpsk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_dqpsk_sptr self) -> constellation_dqpsk"""
        return _digital_swig.constellation_dqpsk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_dqpsk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_dqpsk_sptr self) -> constellation_dqpsk_sptr

        Digital constellation for DQPSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_dqpsk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_dqpsk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_dqpsk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_dqpsk_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_dqpsk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_dqpsk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_dqpsk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_dqpsk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_dqpsk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_dqpsk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_dqpsk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_dqpsk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_dqpsk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_dqpsk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_dqpsk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_dqpsk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_dqpsk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_dqpsk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_dqpsk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_dqpsk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_dqpsk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_dqpsk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_dqpsk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_dqpsk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_dqpsk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_dqpsk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_dqpsk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_dqpsk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_dqpsk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_dqpsk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_dqpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_dqpsk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_dqpsk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_dqpsk_sptr_arity(self)

    def base(self):
        """base(constellation_dqpsk_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_dqpsk_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_dqpsk_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_dqpsk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_dqpsk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_dqpsk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_dqpsk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_dqpsk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_dqpsk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_dqpsk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_dqpsk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_dqpsk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_dqpsk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_dqpsk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_dqpsk_sptr_swigregister = _digital_swig.constellation_dqpsk_sptr_swigregister
constellation_dqpsk_sptr_swigregister(constellation_dqpsk_sptr)

constellation_dqpsk_sptr.__repr__ = lambda self: "<constellation DQPSK>"
constellation_dqpsk = constellation_dqpsk.make;

class constellation_8psk_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::constellation_8psk)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::constellation_8psk)> self) -> constellation_8psk_sptr
        __init__(boost::shared_ptr<(gr::digital::constellation_8psk)> self, constellation_8psk p) -> constellation_8psk_sptr
        """
        this = _digital_swig.new_constellation_8psk_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(constellation_8psk_sptr self) -> constellation_8psk"""
        return _digital_swig.constellation_8psk_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_constellation_8psk_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(constellation_8psk_sptr self) -> constellation_8psk_sptr

        Digital constellation for 8PSK.

        Constructor Specific Documentation:


        """
        return _digital_swig.constellation_8psk_sptr_make(self)

    def map_to_points(self, *args, **kwargs):
        """
        map_to_points(constellation_8psk_sptr self, unsigned int value, gr_complex * points)

        Returns the constellation points for a symbol value.
        """
        return _digital_swig.constellation_8psk_sptr_map_to_points(self, *args, **kwargs)

    def map_to_points_v(self, *args, **kwargs):
        """map_to_points_v(constellation_8psk_sptr self, unsigned int value) -> pmt_vector_cfloat"""
        return _digital_swig.constellation_8psk_sptr_map_to_points_v(self, *args, **kwargs)

    def decision_maker(self, *args, **kwargs):
        """
        decision_maker(constellation_8psk_sptr self, gr_complex const * sample) -> unsigned int

        Returns the constellation point that matches best.
        """
        return _digital_swig.constellation_8psk_sptr_decision_maker(self, *args, **kwargs)

    def decision_maker_v(self, *args, **kwargs):
        """
        decision_maker_v(constellation_8psk_sptr self, pmt_vector_cfloat sample) -> unsigned int

        Takes a vector rather than a pointer. Better for SWIG wrapping.
        """
        return _digital_swig.constellation_8psk_sptr_decision_maker_v(self, *args, **kwargs)

    def decision_maker_pe(self, *args, **kwargs):
        """
        decision_maker_pe(constellation_8psk_sptr self, gr_complex const * sample, float * phase_error) -> unsigned int

        Also calculates the phase error.
        """
        return _digital_swig.constellation_8psk_sptr_decision_maker_pe(self, *args, **kwargs)

    def calc_metric(self, *args, **kwargs):
        """
        calc_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric, gr::digital::trellis_metric_type_t type)

        Calculates distance.

        Calculates metrics for all points in the constellation. For use with the viterbi algorithm.
        """
        return _digital_swig.constellation_8psk_sptr_calc_metric(self, *args, **kwargs)

    def calc_euclidean_metric(self, *args, **kwargs):
        """calc_euclidean_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_8psk_sptr_calc_euclidean_metric(self, *args, **kwargs)

    def calc_hard_symbol_metric(self, *args, **kwargs):
        """calc_hard_symbol_metric(constellation_8psk_sptr self, gr_complex const * sample, float * metric)"""
        return _digital_swig.constellation_8psk_sptr_calc_hard_symbol_metric(self, *args, **kwargs)

    def points(self):
        """
        points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the set of points in this constellation.
        """
        return _digital_swig.constellation_8psk_sptr_points(self)

    def s_points(self):
        """
        s_points(constellation_8psk_sptr self) -> pmt_vector_cfloat

        Returns the vector of points in this constellation. Raise error if dimensionality is not one.
        """
        return _digital_swig.constellation_8psk_sptr_s_points(self)

    def v_points(self):
        """
        v_points(constellation_8psk_sptr self) -> gr_vector_vector_complexf

        Returns a vector of vectors of points.
        """
        return _digital_swig.constellation_8psk_sptr_v_points(self)

    def apply_pre_diff_code(self):
        """
        apply_pre_diff_code(constellation_8psk_sptr self) -> bool

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_8psk_sptr_apply_pre_diff_code(self)

    def set_pre_diff_code(self, *args, **kwargs):
        """
        set_pre_diff_code(constellation_8psk_sptr self, bool a)

        Whether to apply an encoding before doing differential encoding. (e.g. gray coding)
        """
        return _digital_swig.constellation_8psk_sptr_set_pre_diff_code(self, *args, **kwargs)

    def pre_diff_code(self):
        """
        pre_diff_code(constellation_8psk_sptr self) -> std::vector< int,std::allocator< int > >

        Returns the encoding to apply before differential encoding.
        """
        return _digital_swig.constellation_8psk_sptr_pre_diff_code(self)

    def rotational_symmetry(self):
        """
        rotational_symmetry(constellation_8psk_sptr self) -> unsigned int

        Returns the order of rotational symmetry.
        """
        return _digital_swig.constellation_8psk_sptr_rotational_symmetry(self)

    def dimensionality(self):
        """
        dimensionality(constellation_8psk_sptr self) -> unsigned int

        Returns the number of complex numbers in a single symbol.
        """
        return _digital_swig.constellation_8psk_sptr_dimensionality(self)

    def bits_per_symbol(self):
        """bits_per_symbol(constellation_8psk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_8psk_sptr_bits_per_symbol(self)

    def arity(self):
        """arity(constellation_8psk_sptr self) -> unsigned int"""
        return _digital_swig.constellation_8psk_sptr_arity(self)

    def base(self):
        """base(constellation_8psk_sptr self) -> constellation_sptr"""
        return _digital_swig.constellation_8psk_sptr_base(self)

    def as_pmt(self):
        """as_pmt(constellation_8psk_sptr self) -> swig_int_ptr"""
        return _digital_swig.constellation_8psk_sptr_as_pmt(self)

    def gen_soft_dec_lut(self, *args, **kwargs):
        """
        gen_soft_dec_lut(constellation_8psk_sptr self, int precision, float npwr=1.0)

        Generates the soft decision LUT based on constellation and symbol map.

        Generates the soft decision LUT based on constellation and symbol map. It can be given a estimate of the noise power in the channel as .


        This is expensive to compute.
        """
        return _digital_swig.constellation_8psk_sptr_gen_soft_dec_lut(self, *args, **kwargs)

    def calc_soft_dec(self, *args, **kwargs):
        """
        calc_soft_dec(constellation_8psk_sptr self, gr_complex sample, float npwr=1.0) -> pmt_vector_float

        Calculate soft decisions for the given .

        Calculate the soft decisions from the given  at the given noise power .

        This is a very costly algorithm (especially for higher order modulations) and should be used sparingly. It uses the gen_soft_dec_lut function to generate the LUT, which should be done once or if a large change in the noise floor is detected.

        Instead of using this function, generate the LUT using the gen_soft_dec_lut after creating the constellation object and then use the soft_decision_maker function to return the answer from the LUT.
        """
        return _digital_swig.constellation_8psk_sptr_calc_soft_dec(self, *args, **kwargs)

    def set_soft_dec_lut(self, *args, **kwargs):
        """
        set_soft_dec_lut(constellation_8psk_sptr self, std::vector< std::vector< float,std::allocator< float > >,std::allocator< std::vector< float,std::allocator< float > > > > const & soft_dec_lut, 
            int precision)

        Define a soft decision look-up table.

        Define a soft decision look-up table (LUT). Because soft decisions can be calculated in various ways with various levels of accuracy and complexity, this function allows users to create a LUT in their own way.

        Setting the LUT here means that has_soft_dec_lut will return true. Decision vectors returned by soft_decision_maker will be calculated using this LUT.
        """
        return _digital_swig.constellation_8psk_sptr_set_soft_dec_lut(self, *args, **kwargs)

    def has_soft_dec_lut(self):
        """
        has_soft_dec_lut(constellation_8psk_sptr self) -> bool

        Returns True if the soft decision LUT has been defined, False otherwise.
        """
        return _digital_swig.constellation_8psk_sptr_has_soft_dec_lut(self)

    def soft_decision_maker(self, *args, **kwargs):
        """
        soft_decision_maker(constellation_8psk_sptr self, gr_complex sample) -> pmt_vector_float

        Returns the soft decisions for the given .

        Returns the soft decisions for the given . If a LUT is defined for the object, the decisions will be calculated from there. Otherwise, this function will call calc_soft_dec directly to calculate the soft decisions.
        """
        return _digital_swig.constellation_8psk_sptr_soft_decision_maker(self, *args, **kwargs)

constellation_8psk_sptr_swigregister = _digital_swig.constellation_8psk_sptr_swigregister
constellation_8psk_sptr_swigregister(constellation_8psk_sptr)

constellation_8psk_sptr.__repr__ = lambda self: "<constellation 8PSK>"
constellation_8psk = constellation_8psk.make;

class packet_header_default_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::packet_header_default)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::packet_header_default)> self) -> packet_header_default_sptr
        __init__(boost::shared_ptr<(gr::digital::packet_header_default)> self, packet_header_default p) -> packet_header_default_sptr
        """
        this = _digital_swig.new_packet_header_default_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_header_default_sptr self) -> packet_header_default"""
        return _digital_swig.packet_header_default_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_packet_header_default_sptr
    __del__ = lambda self : None;
    def base(self):
        """base(packet_header_default_sptr self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_default_sptr_base(self)

    def formatter(self):
        """formatter(packet_header_default_sptr self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_default_sptr_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """set_header_num(packet_header_default_sptr self, unsigned int header_num)"""
        return _digital_swig.packet_header_default_sptr_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """header_len(packet_header_default_sptr self) -> long"""
        return _digital_swig.packet_header_default_sptr_header_len(self)

    def len_tag_key(self):
        """len_tag_key(packet_header_default_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_header_default_sptr_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_default_sptr self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.
        """
        return _digital_swig.packet_header_default_sptr_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_default_sptr self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .
        """
        return _digital_swig.packet_header_default_sptr_header_parser(self, *args, **kwargs)

    def make(self, *args, **kwargs):
        """
        make(packet_header_default_sptr self, long header_len, std::string const & len_tag_key="packet_len", std::string const & num_tag_key="packet_num", 
            int bits_per_byte=1) -> packet_header_default_sptr

        Default header formatter for digital packet transmission.

        For bursty/packetized digital transmission, packets are usually prepended with a packet header, containing the number of bytes etc. This class is not a block, but a tool to create these packet header.

        This is a default packet header (see header_formatter()) for a description on the header format). To create other header, derive packet header creator classes from this function.

        gr::digital::packet_headergenerator_bb uses header generators derived from this class to create packet headers from data streams.

        Constructor Specific Documentation:



        Args:
            header_len : 
            len_tag_key : 
            num_tag_key : 
            bits_per_byte : 
        """
        return _digital_swig.packet_header_default_sptr_make(self, *args, **kwargs)

packet_header_default_sptr_swigregister = _digital_swig.packet_header_default_sptr_swigregister
packet_header_default_sptr_swigregister(packet_header_default_sptr)

packet_header_default_sptr.__repr__ = lambda self: "<packet_header_default>"
packet_header_default = packet_header_default .make;

class packet_header_ofdm_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::packet_header_ofdm)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::packet_header_ofdm)> self) -> packet_header_ofdm_sptr
        __init__(boost::shared_ptr<(gr::digital::packet_header_ofdm)> self, packet_header_ofdm p) -> packet_header_ofdm_sptr
        """
        this = _digital_swig.new_packet_header_ofdm_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(packet_header_ofdm_sptr self) -> packet_header_ofdm"""
        return _digital_swig.packet_header_ofdm_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_packet_header_ofdm_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(packet_header_ofdm_sptr self, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers, 
            int n_syms, std::string const & len_tag_key="packet_len", 
            std::string const & frame_len_tag_key="frame_len", 
            std::string const & num_tag_key="packet_num", int bits_per_header_sym=1, 
            int bits_per_payload_sym=1, bool scramble_header=False) -> packet_header_ofdm_sptr

        Header utility for OFDM signals.

        Constructor Specific Documentation:



        Args:
            occupied_carriers : See carrier allocator
            n_syms : The number of OFDM symbols the header should be (usually 1)
            len_tag_key : The tag key used for the packet length (number of bytes)
            frame_len_tag_key : The tag key used for the frame length (number of OFDM symbols, this is the tag key required for the frame equalizer etc.)
            num_tag_key : The tag key used for packet numbering.
            bits_per_header_sym : Bits per complex symbol in the header, e.g. 1 if the header is BPSK modulated, 2 if it's QPSK modulated etc.
            bits_per_payload_sym : Bits per complex symbol in the payload. This is required to figure out how many OFDM symbols are necessary to encode the given number of bytes.
            scramble_header : Set this to true to scramble the bits. This is highly recommended, as it reduces PAPR spikes.
        """
        return _digital_swig.packet_header_ofdm_sptr_make(self, *args, **kwargs)

    def base(self):
        """base(packet_header_ofdm_sptr self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_ofdm_sptr_base(self)

    def formatter(self):
        """formatter(packet_header_ofdm_sptr self) -> packet_header_default_sptr"""
        return _digital_swig.packet_header_ofdm_sptr_formatter(self)

    def set_header_num(self, *args, **kwargs):
        """set_header_num(packet_header_ofdm_sptr self, unsigned int header_num)"""
        return _digital_swig.packet_header_ofdm_sptr_set_header_num(self, *args, **kwargs)

    def header_len(self):
        """header_len(packet_header_ofdm_sptr self) -> long"""
        return _digital_swig.packet_header_ofdm_sptr_header_len(self)

    def len_tag_key(self):
        """len_tag_key(packet_header_ofdm_sptr self) -> swig_int_ptr"""
        return _digital_swig.packet_header_ofdm_sptr_len_tag_key(self)

    def header_formatter(self, *args, **kwargs):
        """
        header_formatter(packet_header_ofdm_sptr self, long packet_len, unsigned char * out, tags_vector_t tags=std::vector< gr::tag_t >()) -> bool

        Encodes the header information in the given tags into bits and places them into .

        Uses the following header format: Bits 0-11: The packet length (what was stored in the tag with key ) Bits 12-23: The header number (counts up everytime this function is called) Bit 24-31: 8-Bit CRC All other bits: Are set to zero

        If the header length is smaller than 32, bits are simply left out. For this reason, they always start with the LSB.

        However, it is recommended to stay above 32 Bits, in order to have a working CRC.
        """
        return _digital_swig.packet_header_ofdm_sptr_header_formatter(self, *args, **kwargs)

    def header_parser(self, *args, **kwargs):
        """
        header_parser(packet_header_ofdm_sptr self, unsigned char const * header, tags_vector_t tags) -> bool

        Inverse function to header_formatter().

        Reads the bit stream in  and writes a corresponding tag into .
        """
        return _digital_swig.packet_header_ofdm_sptr_header_parser(self, *args, **kwargs)

packet_header_ofdm_sptr_swigregister = _digital_swig.packet_header_ofdm_sptr_swigregister
packet_header_ofdm_sptr_swigregister(packet_header_ofdm_sptr)

packet_header_ofdm_sptr.__repr__ = lambda self: "<packet_header_ofdm>"
packet_header_ofdm = packet_header_ofdm .make;

class ofdm_equalizer_base_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_equalizer_base)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_base)> self) -> ofdm_equalizer_base_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_base)> self, ofdm_equalizer_base p) -> ofdm_equalizer_base_sptr
        """
        this = _digital_swig.new_ofdm_equalizer_base_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_base_sptr self) -> ofdm_equalizer_base"""
        return _digital_swig.ofdm_equalizer_base_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_base_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_base_sptr self)

        Reset the channel information state knowledge.
        """
        return _digital_swig.ofdm_equalizer_base_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_base_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.
        """
        return _digital_swig.ofdm_equalizer_base_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_base_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.
        """
        return _digital_swig.ofdm_equalizer_base_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """fft_len(ofdm_equalizer_base_sptr self) -> int"""
        return _digital_swig.ofdm_equalizer_base_sptr_fft_len(self)

    def base(self):
        """base(ofdm_equalizer_base_sptr self) -> ofdm_equalizer_base_sptr"""
        return _digital_swig.ofdm_equalizer_base_sptr_base(self)

ofdm_equalizer_base_sptr_swigregister = _digital_swig.ofdm_equalizer_base_sptr_swigregister
ofdm_equalizer_base_sptr_swigregister(ofdm_equalizer_base_sptr)

class ofdm_equalizer_1d_pilots_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_equalizer_1d_pilots)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_1d_pilots)> self) -> ofdm_equalizer_1d_pilots_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_1d_pilots)> self, ofdm_equalizer_1d_pilots p) -> ofdm_equalizer_1d_pilots_sptr
        """
        this = _digital_swig.new_ofdm_equalizer_1d_pilots_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_1d_pilots_sptr self) -> ofdm_equalizer_1d_pilots"""
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_1d_pilots_sptr
    __del__ = lambda self : None;
    def reset(self):
        """
        reset(ofdm_equalizer_1d_pilots_sptr self)

        Reset the channel information state knowledge.
        """
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_1d_pilots_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.
        """
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_1d_pilots_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.
        """
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """fft_len(ofdm_equalizer_1d_pilots_sptr self) -> int"""
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr_fft_len(self)

    def base(self):
        """base(ofdm_equalizer_1d_pilots_sptr self) -> ofdm_equalizer_base_sptr"""
        return _digital_swig.ofdm_equalizer_1d_pilots_sptr_base(self)

ofdm_equalizer_1d_pilots_sptr_swigregister = _digital_swig.ofdm_equalizer_1d_pilots_sptr_swigregister
ofdm_equalizer_1d_pilots_sptr_swigregister(ofdm_equalizer_1d_pilots_sptr)

ofdm_equalizer_1d_pilots_sptr.__repr__ = lambda self: "<OFDM equalizer 1D base class>"

class ofdm_equalizer_simpledfe_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_equalizer_simpledfe)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_simpledfe)> self) -> ofdm_equalizer_simpledfe_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_simpledfe)> self, ofdm_equalizer_simpledfe p) -> ofdm_equalizer_simpledfe_sptr
        """
        this = _digital_swig.new_ofdm_equalizer_simpledfe_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_simpledfe_sptr self) -> ofdm_equalizer_simpledfe"""
        return _digital_swig.ofdm_equalizer_simpledfe_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_simpledfe_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_equalizer_simpledfe_sptr self, int fft_len, constellation_sptr constellation, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            float alpha=0.1, 
            bool input_is_shifted=True) -> ofdm_equalizer_simpledfe_sptr

        Constructor Specific Documentation:



        Args:
            fft_len : 
            constellation : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            symbols_skipped : 
            alpha : 
            input_is_shifted : 
        """
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_make(self, *args, **kwargs)

    def reset(self):
        """
        reset(ofdm_equalizer_simpledfe_sptr self)

        Reset the channel information state knowledge.
        """
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_simpledfe_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.
        """
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_simpledfe_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.
        """
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """fft_len(ofdm_equalizer_simpledfe_sptr self) -> int"""
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_fft_len(self)

    def base(self):
        """base(ofdm_equalizer_simpledfe_sptr self) -> ofdm_equalizer_base_sptr"""
        return _digital_swig.ofdm_equalizer_simpledfe_sptr_base(self)

ofdm_equalizer_simpledfe_sptr_swigregister = _digital_swig.ofdm_equalizer_simpledfe_sptr_swigregister
ofdm_equalizer_simpledfe_sptr_swigregister(ofdm_equalizer_simpledfe_sptr)

ofdm_equalizer_simpledfe_sptr.__repr__ = lambda self: "<OFDM equalizer simpledfe>"
ofdm_equalizer_simpledfe = ofdm_equalizer_simpledfe.make;

class ofdm_equalizer_static_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::digital::ofdm_equalizer_static)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_static)> self) -> ofdm_equalizer_static_sptr
        __init__(boost::shared_ptr<(gr::digital::ofdm_equalizer_static)> self, ofdm_equalizer_static p) -> ofdm_equalizer_static_sptr
        """
        this = _digital_swig.new_ofdm_equalizer_static_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ofdm_equalizer_static_sptr self) -> ofdm_equalizer_static"""
        return _digital_swig.ofdm_equalizer_static_sptr___deref__(self)

    __swig_destroy__ = _digital_swig.delete_ofdm_equalizer_static_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ofdm_equalizer_static_sptr self, int fft_len, std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & occupied_carriers=std::vector< std::vector< int > >(), 
            std::vector< std::vector< int,std::allocator< int > >,std::allocator< std::vector< int,std::allocator< int > > > > const & pilot_carriers=std::vector< std::vector< int > >(), 
            gr_vector_vector_complexf pilot_symbols=std::vector< std::vector< gr_complex > >(), 
            int symbols_skipped=0, 
            bool input_is_shifted=True) -> ofdm_equalizer_static_sptr

        Constructor Specific Documentation:



        Args:
            fft_len : 
            occupied_carriers : 
            pilot_carriers : 
            pilot_symbols : 
            symbols_skipped : 
            input_is_shifted : 
        """
        return _digital_swig.ofdm_equalizer_static_sptr_make(self, *args, **kwargs)

    def reset(self):
        """
        reset(ofdm_equalizer_static_sptr self)

        Reset the channel information state knowledge.
        """
        return _digital_swig.ofdm_equalizer_static_sptr_reset(self)

    def equalize(self, *args, **kwargs):
        """
        equalize(ofdm_equalizer_static_sptr self, gr_complex * frame, int n_sym, pmt_vector_cfloat initial_taps=std::vector< gr_complex >(), 
            tags_vector_t tags=std::vector< gr::tag_t >())

        Run the actual equalization.
        """
        return _digital_swig.ofdm_equalizer_static_sptr_equalize(self, *args, **kwargs)

    def get_channel_state(self, *args, **kwargs):
        """
        get_channel_state(ofdm_equalizer_static_sptr self, pmt_vector_cfloat taps)

        Return the current channel state.
        """
        return _digital_swig.ofdm_equalizer_static_sptr_get_channel_state(self, *args, **kwargs)

    def fft_len(self):
        """fft_len(ofdm_equalizer_static_sptr self) -> int"""
        return _digital_swig.ofdm_equalizer_static_sptr_fft_len(self)

    def base(self):
        """base(ofdm_equalizer_static_sptr self) -> ofdm_equalizer_base_sptr"""
        return _digital_swig.ofdm_equalizer_static_sptr_base(self)

ofdm_equalizer_static_sptr_swigregister = _digital_swig.ofdm_equalizer_static_sptr_swigregister
ofdm_equalizer_static_sptr_swigregister(ofdm_equalizer_static_sptr)

ofdm_equalizer_static_sptr.__repr__ = lambda self: "<OFDM equalizer static>"
ofdm_equalizer_static = ofdm_equalizer_static.make;



